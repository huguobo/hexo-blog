{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/images/clientHeight.png","path":"images/clientHeight.png","modified":1,"renderable":0},{"_id":"source/images/offsetHeight.png","path":"images/offsetHeight.png","modified":1,"renderable":0},{"_id":"source/images/iv.png","path":"images/iv.png","modified":1,"renderable":0},{"_id":"source/images/scollHeight.png","path":"images/scollHeight.png","modified":1,"renderable":0},{"_id":"source/images/scrollTop.png","path":"images/scrollTop.png","modified":1,"renderable":0},{"_id":"source/images/HHKB.jpeg","path":"images/HHKB.jpeg","modified":1,"renderable":0},{"_id":"source/images/encrypt.png","path":"images/encrypt.png","modified":1,"renderable":0},{"_id":"source/images/login.png","path":"images/login.png","modified":1,"renderable":0},{"_id":"source/images/success.png","path":"images/success.png","modified":1,"renderable":0},{"_id":"source/images/weekend.jpeg","path":"images/weekend.jpeg","modified":1,"renderable":0},{"_id":"themes/archer/source/assets/algolia_logo.svg","path":"assets/algolia_logo.svg","modified":1,"renderable":1},{"_id":"themes/archer/source/assets/loading.svg","path":"assets/loading.svg","modified":1,"renderable":1},{"_id":"themes/archer/source/assets/Home.svg","path":"assets/Home.svg","modified":1,"renderable":1},{"_id":"themes/archer/source/assets/favicon.ico","path":"assets/favicon.ico","modified":1,"renderable":1},{"_id":"themes/archer/source/assets/qr.png","path":"assets/qr.png","modified":1,"renderable":1},{"_id":"themes/archer/source/css/mobile.css","path":"css/mobile.css","modified":1,"renderable":1},{"_id":"themes/archer/source/avatar/logo.jpg","path":"avatar/logo.jpg","modified":1,"renderable":1},{"_id":"themes/archer/source/css/style.css","path":"css/style.css","modified":1,"renderable":1},{"_id":"themes/archer/source/font/Source Sans Pro.woff","path":"font/Source Sans Pro.woff","modified":1,"renderable":1},{"_id":"themes/archer/source/font/Source Sans Pro.woff2","path":"font/Source Sans Pro.woff2","modified":1,"renderable":1},{"_id":"themes/archer/source/lib/webfontloader.min.js","path":"lib/webfontloader.min.js","modified":1,"renderable":1},{"_id":"themes/archer/source/scripts/main.js","path":"scripts/main.js","modified":1,"renderable":1},{"_id":"themes/archer/source/scripts/search.js","path":"scripts/search.js","modified":1,"renderable":1},{"_id":"themes/archer/source/scripts/share.js","path":"scripts/share.js","modified":1,"renderable":1},{"_id":"source/images/travis.png","path":"images/travis.png","modified":1,"renderable":0},{"_id":"themes/archer/source/font/Oswald-Regular.ttf","path":"font/Oswald-Regular.ttf","modified":1,"renderable":1},{"_id":"themes/archer/source/font/SourceCodePro-Regular.ttf.woff","path":"font/SourceCodePro-Regular.ttf.woff","modified":1,"renderable":1},{"_id":"themes/archer/source/font/SourceCodePro-Regular.ttf.woff2","path":"font/SourceCodePro-Regular.ttf.woff2","modified":1,"renderable":1},{"_id":"themes/archer/source/intro/404-bg.jpg","path":"intro/404-bg.jpg","modified":1,"renderable":1},{"_id":"themes/archer/source/lib/jquery.min.js","path":"lib/jquery.min.js","modified":1,"renderable":1},{"_id":"themes/archer/source/avatar/avtar.jpg","path":"avatar/avtar.jpg","modified":1,"renderable":1},{"_id":"themes/archer/source/intro/about-bg.jpg","path":"intro/about-bg.jpg","modified":1,"renderable":1},{"_id":"themes/archer/source/intro/post-bg.jpg","path":"intro/post-bg.jpg","modified":1,"renderable":1},{"_id":"themes/archer/source/intro/bg.jpg","path":"intro/bg.jpg","modified":1,"renderable":1},{"_id":"themes/archer/source/intro/index-bg.jpg","path":"intro/index-bg.jpg","modified":1,"renderable":1}],"Cache":[{"_id":"themes/archer/.gitignore","hash":"e2d7fa953bade3b94ed1cab25ffcf442c7540433","modified":1566989305196},{"_id":"themes/archer/.eslintrc.json","hash":"35eeca97fa5a2d0c6d78ef1257c58f03c42d43df","modified":1566989305195},{"_id":"themes/archer/.gitattributes","hash":"82c1a621642d5b620275ae1ed59845c3f7015a64","modified":1566989305195},{"_id":"themes/archer/.prettierrc.js","hash":"875b0b95f6eb24a23e4ea83a75709b97897135e0","modified":1566989305196},{"_id":"themes/archer/.prettierignore","hash":"58caf761f07e5df9cdc21f7f19f0670fde41089b","modified":1566989305196},{"_id":"themes/archer/LICENSE","hash":"0da0c361bf299375739c6b668a44af0f5faf37bb","modified":1566989305196},{"_id":"themes/archer/README.md","hash":"97edb54cb7aecff714f132110ed4ba8215da7136","modified":1566989305197},{"_id":"themes/archer/_config.yml","hash":"bdb870dbbc5c90e9e01f502e2428cbc81da111fb","modified":1567240624770},{"_id":"themes/archer/gulpfile.js","hash":"46dfe693b00ac4dea4d1b1af56f5ced4ee095c10","modified":1566989305199},{"_id":"themes/archer/package.json","hash":"531fe40833ca63493f62adfa249b6434310a2d0a","modified":1566989305207},{"_id":"themes/archer/webpack.config.js","hash":"d20b6350c50e2981484cb9356a3e21a2124bcd72","modified":1566989305236},{"_id":"themes/archer/webpack.prod.js","hash":"48de76cfa6274895801d3afc89ecbf04ee182a1c","modified":1566989305236},{"_id":"source/_posts/ElonAndJack.md","hash":"b656bfcf192b7a721d7e3540b80486d7f4949c3a","modified":1567909507239},{"_id":"source/_posts/Travis-CI持续集成Hexo到云服务器.md","hash":"59c72d8ce7a97f35733d54890ffaef57b3c232e0","modified":1567909623487},{"_id":"source/_posts/HHKB.md","hash":"b30c810b0530244360d8154cd52fbf0f59694e6e","modified":1568111932632},{"_id":"source/_posts/node-1.md","hash":"ac470b6075f561719e779aefd91a3e8dd1f17998","modified":1569244856430},{"_id":"source/_posts/weekend.md","hash":"ad4142aaf7a06ed2cee60af4e6131de225f8f9aa","modified":1567388247401},{"_id":"source/_posts/新网站.md","hash":"f23ae2c0f14c6ef9d9dc224f01d9e486bc0fe0f6","modified":1567388250425},{"_id":"source/_posts/JsWidthAndHeight.md","hash":"baa429170557075e736a95be9e0e0ea343c56761","modified":1568012235756},{"_id":"source/about/index.md","hash":"31da4ed509e6c46b81eeb4b109a5ec6cb16deb3d","modified":1567159452263},{"_id":"source/_posts/sshLogin.md","hash":"fd54a7734fc1d9824fd818cf1d3e99ecdd81c0f6","modified":1567909643466},{"_id":"source/_posts/nginx配置ssl.md","hash":"216571d6ebd2812a2036be368a4565ad211e014e","modified":1567909595860},{"_id":"source/images/clientHeight.png","hash":"5a21a3c25d2a7365d091badad9a1ba1e744e56c6","modified":1568011238055},{"_id":"source/images/offsetHeight.png","hash":"cdd3708195bd5d239627cb102a01e59904ba22ea","modified":1568011234417},{"_id":"source/images/iv.png","hash":"06614226fd14f6f18c96133bfff6d3a4663c6f5f","modified":1567341098856},{"_id":"source/images/scollHeight.png","hash":"551e31ada5f37fcbd51ca49b6b1687b9fcb1b4b8","modified":1568011788453},{"_id":"source/images/scrollTop.png","hash":"514d96fffb254b1a785204f66e9acb37ba45087e","modified":1568012085732},{"_id":"source/tags/index.md","hash":"594f738b83fedfa653d5c96da20510c8ea8b0de4","modified":1566911678021},{"_id":"themes/archer/docs/README-en.md","hash":"f325565c0bb94501fd046268659c7752709895d1","modified":1566989305197},{"_id":"themes/archer/docs/develop-guide-en.md","hash":"0bb09c3c9d5f56820cb84e3316f60352b731d70c","modified":1566989305197},{"_id":"themes/archer/docs/develop-guide-zh.md","hash":"effc2bc9e0cecfd228b19283337ff29649ea5985","modified":1566989305197},{"_id":"themes/archer/dev/archer.sh","hash":"4065c4e55462d5ecf016464adea0d1db967ef4b4","modified":1566989305197},{"_id":"themes/archer/languages/default.yml","hash":"d56b6923c70efdef09cd1f0270d7adc9cc338f6b","modified":1566989305199},{"_id":"themes/archer/languages/en.yml","hash":"ad75d3e5f7f5f0463d3077e1b5a26f40938a1faa","modified":1566989305199},{"_id":"themes/archer/layout/404.ejs","hash":"879641b1b5e49c43f2e096cad281f7d74df05127","modified":1566989305200},{"_id":"themes/archer/layout/about.ejs","hash":"06019d835c0a51fed8aa086d1dfcf368f9921b42","modified":1566989305204},{"_id":"themes/archer/layout/index.ejs","hash":"716ba4a30860e36077dfdfffa02c1cd60301d8a3","modified":1566989305204},{"_id":"themes/archer/layout/layout.ejs","hash":"08ebd10c1b2bfc11be8f5115a836a98e6c6ba13c","modified":1566989305204},{"_id":"themes/archer/layout/post.ejs","hash":"b61156aff41641a14d5e4e45d9fd776309f2801a","modified":1566989305204},{"_id":"themes/archer/layout/site-meta.ejs","hash":"d866aa1a892d4bfe3368f6dbd0f1baa8c5831947","modified":1566989305205},{"_id":"themes/archer/source/.DS_Store","hash":"930c6508268f48a80018d8abc30d3bec638b3a99","modified":1566994101548},{"_id":"source/images/HHKB.jpeg","hash":"6289b7afd3c66c9790ff04c012092c18e90028bd","modified":1568107105381},{"_id":"source/images/encrypt.png","hash":"fd22fcba73ccc1eadade3e1323e4a240beea8913","modified":1567340650980},{"_id":"source/images/login.png","hash":"c2813d57bd6a01800858baf8ee561f5b366f3837","modified":1567340645957},{"_id":"themes/archer/.github/ISSUE_TEMPLATE/-----------bug--help-wanted-or-bug-report-.md","hash":"012bd3afea5565204f75d8c89048ad33b9c2f948","modified":1566989305195},{"_id":"source/images/success.png","hash":"926c35dbd53f5354611b28eaf84b605f682d1698","modified":1567353433317},{"_id":"themes/archer/.github/ISSUE_TEMPLATE/-----feature-request-.md","hash":"886fb1252702d46c89536b579d35ce49e53ec54d","modified":1566989305196},{"_id":"themes/archer/.github/ISSUE_TEMPLATE/-----other-issue-.md","hash":"4bf3c8ebef14a81bb55e8e0468d816e83c4133ac","modified":1566989305196},{"_id":"source/images/weekend.jpeg","hash":"e27bd6ad7cabf0957104cc143c209e8fdef5c428","modified":1567306494349},{"_id":"themes/archer/layout/_partial/algolia.ejs","hash":"2f5f9073378f628a9124792b5301c1540bc5a264","modified":1566989305200},{"_id":"themes/archer/layout/_partial/base-background-image.ejs","hash":"82203d9a1c6e16ef2d37b8b587f56bf6d16edaf2","modified":1566989305200},{"_id":"themes/archer/layout/_partial/base-header.ejs","hash":"34ea3178ad7e363297e4372bf9501d7de9f3f8be","modified":1568954035715},{"_id":"themes/archer/layout/_partial/base-preload-polyfill.ejs","hash":"2aea84cb43f4479131620b3c3dfd7cebe9be36ba","modified":1566989305200},{"_id":"themes/archer/layout/_partial/base-footer.ejs","hash":"3a526d495f3380faf85892e42d59a87ac19d32db","modified":1568606156153},{"_id":"themes/archer/layout/_partial/base-social.ejs","hash":"2d068432031b3bebf9438c775370a2d1b4492d6b","modified":1566989305201},{"_id":"themes/archer/layout/_partial/base-title-tags.ejs","hash":"418559ab11726f69621c3a58cd21903adff1e48e","modified":1566989305201},{"_id":"themes/archer/layout/_partial/base-head.ejs","hash":"f2e8d4dfd11d879491a4b10f74f8c886cd392240","modified":1568949307693},{"_id":"themes/archer/layout/_partial/base-profile.ejs","hash":"c5b34e7edd135f0c3970cd746263ed1679f41af4","modified":1567059592519},{"_id":"themes/archer/layout/_partial/intro-height.ejs","hash":"cd0d34a811dc4666980d57c00d70dd82bd5450eb","modified":1566989305202},{"_id":"themes/archer/source/assets/algolia_logo.svg","hash":"90035272fa31a3f65b3c0e2cb8a633876ef457dc","modified":1566989305208},{"_id":"themes/archer/source/assets/loading.svg","hash":"45be17d07697d604d8981890eb21e308530c7a38","modified":1566989305208},{"_id":"themes/archer/source/assets/Home.svg","hash":"6c172208dd4e5b4c997c4ea830c0f340a3d0e267","modified":1568953628631},{"_id":"themes/archer/source/assets/favicon.ico","hash":"f46fc2c74d1eca053022ce404ea79ee7b0ffb7af","modified":1567155394087},{"_id":"themes/archer/source/assets/qr.png","hash":"cfe2c27eeee47b5b25072167b19b56dd5f0134f3","modified":1566991188244},{"_id":"themes/archer/source/css/mobile.css","hash":"51d7b5cf26c8f82a3daad4bc55518673fdf281f5","modified":1566989305209},{"_id":"themes/archer/source/avatar/logo.jpg","hash":"38450b286f7ec1a526fec5e557f58106e127eec9","modified":1567155568021},{"_id":"themes/archer/source/css/style.css","hash":"c5c4148e5041afafd1fabdebd80d156379e7b7a6","modified":1568606432330},{"_id":"themes/archer/source/font/Source Sans Pro.woff","hash":"a6722c9b6439b7a020a9be3d3178970757a9265c","modified":1566989305211},{"_id":"themes/archer/source/font/Source Sans Pro.woff2","hash":"da65f527a8da65d5eb6721626d28cfdb46ab104a","modified":1566989305211},{"_id":"themes/archer/source/intro/.DS_Store","hash":"f2e2b1d02471a3df83adf04897c9afdb9b1d49b5","modified":1566994101546},{"_id":"themes/archer/source/lib/webfontloader.min.js","hash":"bc6ffe9c0d8b3285564619a445c6ca575eb9d0f5","modified":1566989305221},{"_id":"themes/archer/source/scripts/main.js","hash":"e89a9651131684204118fa74bd19cb781d76a372","modified":1566989305221},{"_id":"themes/archer/source/scripts/search.js","hash":"d5f739e261e8ce74f993c6157b248663bda122bf","modified":1566989305222},{"_id":"themes/archer/src/js/browser.js","hash":"ce061db99db5b880db0ddb768246352ca885b13c","modified":1566989305224},{"_id":"themes/archer/src/js/fancybox.js","hash":"0daf0e83deca055102268e3bd95cb1962acc2264","modified":1566989305225},{"_id":"themes/archer/source/scripts/share.js","hash":"bb5bb37ce7f47f8c084b232df3e5fe2378d7ca01","modified":1566989305223},{"_id":"themes/archer/src/js/init.js","hash":"346c6ef75ae85e4350c1b0811985172fdaa0d3a5","modified":1566989305225},{"_id":"themes/archer/src/js/initSidebar.js","hash":"b25615ff254913db83e2a20263d445f35083843b","modified":1566989305225},{"_id":"themes/archer/src/js/main.js","hash":"e1a48d5822326792e38d44efee86e01473549eba","modified":1566989305226},{"_id":"themes/archer/src/js/mobile.js","hash":"228a68d851517b5e47d2132f1d499cb812a64171","modified":1566989305226},{"_id":"themes/archer/src/js/scroll.js","hash":"aa2315a80daaa183a7e462c7e879ff9d2f050933","modified":1566989305226},{"_id":"themes/archer/src/js/search.js","hash":"2e59ac745da7c22801d9029cf9904a4fc3c384f1","modified":1566989305227},{"_id":"themes/archer/src/js/share.js","hash":"1314b19a852e291e35d6809f7f58652d3e7c524c","modified":1566989305227},{"_id":"themes/archer/src/js/sidebar.js","hash":"68d5fe0ee5e86df810d304e5efe11e5e1fddc46d","modified":1566989305227},{"_id":"themes/archer/src/js/tag.js","hash":"e0f0a914c02922e42977d78dc4993b3855167cd8","modified":1566989305228},{"_id":"themes/archer/src/js/toc.js","hash":"b3482031e4c8728535d480bfaec76229469e3aba","modified":1566989305228},{"_id":"themes/archer/src/js/util.js","hash":"27de6446892bcf399430dd5776df0b8759ca0eea","modified":1566989305228},{"_id":"themes/archer/src/scss/_common.scss","hash":"dedc313b082e0a16daf87213badd21b13be11af8","modified":1566989305228},{"_id":"themes/archer/src/scss/_mixin.scss","hash":"e7deb20a16868ae9d3e35ba3c5693de71fdf6999","modified":1566989305229},{"_id":"themes/archer/src/scss/_normalize.scss","hash":"a2dbeb38ad08bb8975856d75954cc697bf8e5ff7","modified":1566989305229},{"_id":"themes/archer/src/scss/_variables.scss","hash":"136e5d990c4f8eadf6cabdfa5a053941e90bcd20","modified":1566989305235},{"_id":"themes/archer/src/scss/style.scss","hash":"78e31370d45089b97fa91929345f1a29f2e6a0a2","modified":1566989305235},{"_id":"themes/archer/src/scss/mobile.scss","hash":"aadc2fbf37fefc2ad391d8172d5b61817f9db0c5","modified":1566989305235},{"_id":"source/images/travis.png","hash":"52333b84a76abf24152585bf0045b279ef3e0f35","modified":1567337141690},{"_id":"themes/archer/layout/_partial/comment/custom.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1566989305201},{"_id":"themes/archer/source/font/Oswald-Regular.ttf","hash":"965d729546a43a8490ad4cf33c25ac475682100c","modified":1566989305211},{"_id":"themes/archer/source/font/SourceCodePro-Regular.ttf.woff","hash":"12eef75e1ad3eca9dae42b65505010ce4464a315","modified":1566989305212},{"_id":"themes/archer/source/font/SourceCodePro-Regular.ttf.woff2","hash":"f5991289ec17884cb641da0646d278d36702a190","modified":1566989305213},{"_id":"themes/archer/source/intro/404-bg.jpg","hash":"3afb5bb26f4ff0bd0e0a28df955c8aa7d746d3c5","modified":1566989305214},{"_id":"themes/archer/source/lib/jquery.min.js","hash":"0dc32db4aa9c5f03f3b38c47d883dbd4fed13aae","modified":1566989305220},{"_id":"themes/archer/package-lock.json","hash":"89a3b67d32f6916cdc21d590d87e43d8a44be8c3","modified":1566989305207},{"_id":"themes/archer/layout/_partial/comment/changyan.ejs","hash":"7691642fb9375607e0ac988a7420999e242cb2c9","modified":1566989305201},{"_id":"themes/archer/layout/_partial/comment/gitment.ejs","hash":"794647a8a4ac9e1d01d74c07717175a141b1e01c","modified":1566989305201},{"_id":"themes/archer/layout/_partial/comment/disqus.ejs","hash":"cadd97820a23d01d8b7e2f19a86e5290cef5a8a6","modified":1566989305201},{"_id":"themes/archer/layout/_partial/comment/livere.ejs","hash":"b27469f19f35ec2037c7bce736a12e9dfb5e360b","modified":1566989305202},{"_id":"themes/archer/layout/_partial/comment/valine.ejs","hash":"2154360e330dab94540e168e9d301c7b7091968e","modified":1566989305202},{"_id":"themes/archer/layout/_partial/comment/youyan.ejs","hash":"790d76f2667377db78a7d04bad8d629e47e7aab0","modified":1566989305202},{"_id":"themes/archer/layout/_partial/script/font-loader.ejs","hash":"291cc0a4a444a93b93c32e2c39383c70e36e46de","modified":1566989305202},{"_id":"themes/archer/layout/_partial/sidebar/base-sidebar.ejs","hash":"2d38af7cb5aabc0af99de239bd180c516ec4c56c","modified":1566989305203},{"_id":"themes/archer/layout/_partial/sidebar/sidebar-archives.ejs","hash":"daa78b17a773bca569f1c8ca2c916495ca138da6","modified":1566989305203},{"_id":"themes/archer/layout/_partial/critical-css/critical-style.ejs","hash":"bbad4bf73858f50e99eb678d966cd6ee1d534408","modified":1566992802836},{"_id":"themes/archer/layout/_partial/sidebar/sidebar-categories.ejs","hash":"147214469c4909eb94943599883f9fa0f3cc090d","modified":1566989305203},{"_id":"themes/archer/layout/_partial/sidebar/sidebar-tags.ejs","hash":"d6e1a192cac5dcf365ce1a52df4f23feafeeb849","modified":1566989305203},{"_id":"themes/archer/source/avatar/avtar.jpg","hash":"8d693792ba6e95b9eeefcfd62cb30e4ad91af519","modified":1566993846251},{"_id":"themes/archer/src/scss/_partial/_404.scss","hash":"a2b56f441a9a44d7f5b9b41eaa8136321328d7e9","modified":1566989305229},{"_id":"themes/archer/src/scss/_partial/_algolia.scss","hash":"c679578d2feb0bd7d3f80c2f693ba58cbca4428b","modified":1566989305230},{"_id":"themes/archer/src/scss/_partial/_index-page.scss","hash":"fa993cf0bbe0086cd8ec3d9a639b2d5b28ccfa8e","modified":1566989305230},{"_id":"themes/archer/src/scss/_partial/_post-page.scss","hash":"7c557844850d53cc4fc36aaf6d59847d8f238947","modified":1566989305232},{"_id":"themes/archer/docs/snap.png","hash":"0b2a8bf016f6eed576abfdcdb7dcf8de51c12562","modified":1566989305199},{"_id":"themes/archer/source/intro/about-bg.jpg","hash":"ab388276822417cc4e703312c14e20280ec783b3","modified":1566989305216},{"_id":"themes/archer/source/intro/post-bg.jpg","hash":"525fafb2238c27754d8fa751f143ff1de9b8482d","modified":1566989305220},{"_id":"themes/archer/source/intro/bg.jpg","hash":"f028bd23507f9ef5d3aa2aec1913fccfa4e674d9","modified":1566993760559},{"_id":"themes/archer/src/scss/_partial/_partial/_footer.scss","hash":"726c543ee066e0b3222b236d9b4ef0109c0bdddf","modified":1566989305230},{"_id":"themes/archer/src/scss/_partial/_partial/_paginator.scss","hash":"67c2e697a5fbb3b8006cf358ea45eb7f75b496f8","modified":1566989305231},{"_id":"themes/archer/src/scss/_partial/_partial/_header.scss","hash":"77003ff22b1a10fae2d2768938277959b3f93a72","modified":1566989305230},{"_id":"themes/archer/src/scss/_partial/_partial/_intro.scss","hash":"a1569f39eccd64a12425d81b794c53df126a4d87","modified":1566989305231},{"_id":"themes/archer/src/scss/_partial/_partial/_scrollbar.scss","hash":"f2514031f9d7e4ed4a126694e78618ce6ff3a574","modified":1566989305232},{"_id":"themes/archer/src/scss/_partial/_post/_code.scss","hash":"9c9a4e470da8732c9a3be3d5ce0d2f80f53714fe","modified":1566989305233},{"_id":"themes/archer/src/scss/_partial/_partial/_profile.scss","hash":"0c986b52ce9083f08c37c5c9b5de045ac5e1d2fa","modified":1566989305231},{"_id":"themes/archer/src/scss/_partial/_sidebar/_sidebar-archive.scss","hash":"14bc42292873880c61b5fa9f47ee9d2e08d46871","modified":1566989305233},{"_id":"themes/archer/src/scss/_partial/_sidebar/_sidebar-tags.scss","hash":"9ab6f96d0df0c4ad4c72e2515fa2599d487d8f1a","modified":1566989305234},{"_id":"themes/archer/src/scss/_partial/_sidebar/_sidebar.scss","hash":"981a94978535769cb51c29e12b627f83c6fcedc5","modified":1566989305234},{"_id":"themes/archer/source/intro/index-bg.jpg","hash":"96b52e177b8bc53e64ec6ee1e10b2b6a4e13083b","modified":1566989305218}],"Category":[{"name":"daily","_id":"ck0wfvhpx0002uhox59huamsw"},{"name":"devOps","_id":"ck0wfvhq10007uhox4jnzsuk8"},{"name":"NODE","_id":"ck0wfvhq2000auhoxx391gi8r"},{"name":"JavaScript","_id":"ck0wfvhr40014uhox3l59jkwb"}],"Data":[],"Page":[{"title":"I'm Cooper","date":"2019-08-29T06:58:14.000Z","layout":"about","_content":"\n> 在我一生的黄金时代，我有好多奢望。\n> 我想爱，想吃，还想在一瞬间变成天上半明半暗的云。\n> 后来我才知道，生活就是个缓慢受锤的过程。\n> 人一天天老下去，奢望也一天天消失，最后变得像挨了锤的牛一样。\n> 我希望自己会永远生猛下去，什么也锤不了我。 \n\n## 靓仔\n<img src=\"https://github.com/huguobo/public/blob/master/avtar.jpg?raw=true\" width=\"25%\" style=\"margin: 0\">\n\n## 基本信息\n- 男\n- 性格开朗\n- 1992 年生人\n\n## 学习生涯\n- 吉林大学\n- 软件工程\n- 硕士\n\n## 职业信息\n- 前端工程师(全干工程师)\n\n### 工作经历\n- 2017.7 ~ 2019.7 [美团点评](https://about.meituan.com/home) \n- 2019.8 ~ 至今 [腾讯科技](https://www.tencent.com/zh-cn/index.html)\n\n### 技能（别问，问就是‘熟悉’）\n- Javascript、Css 和 HTML 基础3件套\n- 基于 React、Vue 等的流行前端框架\n- webpack、gulp 等前端工程化工具\n- 前端 CI/CD 流程，基础 devOps\n- Node\n- Koa、Express 等 node 前端框架\n- Mysql curd\n- git、shell、nginx 等基础工具\n\n## 状态\n- 在职\n- 身体还算健康\n- 心理非常健康\n- 价值观很正\n\n## 爱好\n- 主机游戏\n- 旅行\n- 🏀\n- 发呆\n\n## 其他\n- 小语种学习中\n\n","source":"about/index.md","raw":"---\ntitle: I'm Cooper\ndate: 2019-08-29 14:58:14\nlayout: about\n---\n\n> 在我一生的黄金时代，我有好多奢望。\n> 我想爱，想吃，还想在一瞬间变成天上半明半暗的云。\n> 后来我才知道，生活就是个缓慢受锤的过程。\n> 人一天天老下去，奢望也一天天消失，最后变得像挨了锤的牛一样。\n> 我希望自己会永远生猛下去，什么也锤不了我。 \n\n## 靓仔\n<img src=\"https://github.com/huguobo/public/blob/master/avtar.jpg?raw=true\" width=\"25%\" style=\"margin: 0\">\n\n## 基本信息\n- 男\n- 性格开朗\n- 1992 年生人\n\n## 学习生涯\n- 吉林大学\n- 软件工程\n- 硕士\n\n## 职业信息\n- 前端工程师(全干工程师)\n\n### 工作经历\n- 2017.7 ~ 2019.7 [美团点评](https://about.meituan.com/home) \n- 2019.8 ~ 至今 [腾讯科技](https://www.tencent.com/zh-cn/index.html)\n\n### 技能（别问，问就是‘熟悉’）\n- Javascript、Css 和 HTML 基础3件套\n- 基于 React、Vue 等的流行前端框架\n- webpack、gulp 等前端工程化工具\n- 前端 CI/CD 流程，基础 devOps\n- Node\n- Koa、Express 等 node 前端框架\n- Mysql curd\n- git、shell、nginx 等基础工具\n\n## 状态\n- 在职\n- 身体还算健康\n- 心理非常健康\n- 价值观很正\n\n## 爱好\n- 主机游戏\n- 旅行\n- 🏀\n- 发呆\n\n## 其他\n- 小语种学习中\n\n","updated":"2019-08-30T10:04:12.263Z","path":"about/index.html","comments":1,"_id":"ck0wfvhr0000zuhoxn54qxxhy","content":"<blockquote>\n<p>在我一生的黄金时代，我有好多奢望。<br>我想爱，想吃，还想在一瞬间变成天上半明半暗的云。<br>后来我才知道，生活就是个缓慢受锤的过程。<br>人一天天老下去，奢望也一天天消失，最后变得像挨了锤的牛一样。<br>我希望自己会永远生猛下去，什么也锤不了我。 </p>\n</blockquote>\n<h2 id=\"靓仔\"><a href=\"#靓仔\" class=\"headerlink\" title=\"靓仔\"></a>靓仔</h2><img src=\"https://github.com/huguobo/public/blob/master/avtar.jpg?raw=true\" width=\"25%\" style=\"margin: 0\">\n\n<h2 id=\"基本信息\"><a href=\"#基本信息\" class=\"headerlink\" title=\"基本信息\"></a>基本信息</h2><ul>\n<li>男</li>\n<li>性格开朗</li>\n<li>1992 年生人</li>\n</ul>\n<h2 id=\"学习生涯\"><a href=\"#学习生涯\" class=\"headerlink\" title=\"学习生涯\"></a>学习生涯</h2><ul>\n<li>吉林大学</li>\n<li>软件工程</li>\n<li>硕士</li>\n</ul>\n<h2 id=\"职业信息\"><a href=\"#职业信息\" class=\"headerlink\" title=\"职业信息\"></a>职业信息</h2><ul>\n<li>前端工程师(全干工程师)</li>\n</ul>\n<h3 id=\"工作经历\"><a href=\"#工作经历\" class=\"headerlink\" title=\"工作经历\"></a>工作经历</h3><ul>\n<li>2017.7 ~ 2019.7 <a href=\"https://about.meituan.com/home\" target=\"_blank\" rel=\"noopener\">美团点评</a> </li>\n<li>2019.8 ~ 至今 <a href=\"https://www.tencent.com/zh-cn/index.html\" target=\"_blank\" rel=\"noopener\">腾讯科技</a></li>\n</ul>\n<h3 id=\"技能（别问，问就是‘熟悉’）\"><a href=\"#技能（别问，问就是‘熟悉’）\" class=\"headerlink\" title=\"技能（别问，问就是‘熟悉’）\"></a>技能（别问，问就是‘熟悉’）</h3><ul>\n<li>Javascript、Css 和 HTML 基础3件套</li>\n<li>基于 React、Vue 等的流行前端框架</li>\n<li>webpack、gulp 等前端工程化工具</li>\n<li>前端 CI/CD 流程，基础 devOps</li>\n<li>Node</li>\n<li>Koa、Express 等 node 前端框架</li>\n<li>Mysql curd</li>\n<li>git、shell、nginx 等基础工具</li>\n</ul>\n<h2 id=\"状态\"><a href=\"#状态\" class=\"headerlink\" title=\"状态\"></a>状态</h2><ul>\n<li>在职</li>\n<li>身体还算健康</li>\n<li>心理非常健康</li>\n<li>价值观很正</li>\n</ul>\n<h2 id=\"爱好\"><a href=\"#爱好\" class=\"headerlink\" title=\"爱好\"></a>爱好</h2><ul>\n<li>主机游戏</li>\n<li>旅行</li>\n<li>🏀</li>\n<li>发呆</li>\n</ul>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><ul>\n<li>小语种学习中</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>在我一生的黄金时代，我有好多奢望。<br>我想爱，想吃，还想在一瞬间变成天上半明半暗的云。<br>后来我才知道，生活就是个缓慢受锤的过程。<br>人一天天老下去，奢望也一天天消失，最后变得像挨了锤的牛一样。<br>我希望自己会永远生猛下去，什么也锤不了我。 </p>\n</blockquote>\n<h2 id=\"靓仔\"><a href=\"#靓仔\" class=\"headerlink\" title=\"靓仔\"></a>靓仔</h2><img src=\"https://github.com/huguobo/public/blob/master/avtar.jpg?raw=true\" width=\"25%\" style=\"margin: 0\">\n\n<h2 id=\"基本信息\"><a href=\"#基本信息\" class=\"headerlink\" title=\"基本信息\"></a>基本信息</h2><ul>\n<li>男</li>\n<li>性格开朗</li>\n<li>1992 年生人</li>\n</ul>\n<h2 id=\"学习生涯\"><a href=\"#学习生涯\" class=\"headerlink\" title=\"学习生涯\"></a>学习生涯</h2><ul>\n<li>吉林大学</li>\n<li>软件工程</li>\n<li>硕士</li>\n</ul>\n<h2 id=\"职业信息\"><a href=\"#职业信息\" class=\"headerlink\" title=\"职业信息\"></a>职业信息</h2><ul>\n<li>前端工程师(全干工程师)</li>\n</ul>\n<h3 id=\"工作经历\"><a href=\"#工作经历\" class=\"headerlink\" title=\"工作经历\"></a>工作经历</h3><ul>\n<li>2017.7 ~ 2019.7 <a href=\"https://about.meituan.com/home\" target=\"_blank\" rel=\"noopener\">美团点评</a> </li>\n<li>2019.8 ~ 至今 <a href=\"https://www.tencent.com/zh-cn/index.html\" target=\"_blank\" rel=\"noopener\">腾讯科技</a></li>\n</ul>\n<h3 id=\"技能（别问，问就是‘熟悉’）\"><a href=\"#技能（别问，问就是‘熟悉’）\" class=\"headerlink\" title=\"技能（别问，问就是‘熟悉’）\"></a>技能（别问，问就是‘熟悉’）</h3><ul>\n<li>Javascript、Css 和 HTML 基础3件套</li>\n<li>基于 React、Vue 等的流行前端框架</li>\n<li>webpack、gulp 等前端工程化工具</li>\n<li>前端 CI/CD 流程，基础 devOps</li>\n<li>Node</li>\n<li>Koa、Express 等 node 前端框架</li>\n<li>Mysql curd</li>\n<li>git、shell、nginx 等基础工具</li>\n</ul>\n<h2 id=\"状态\"><a href=\"#状态\" class=\"headerlink\" title=\"状态\"></a>状态</h2><ul>\n<li>在职</li>\n<li>身体还算健康</li>\n<li>心理非常健康</li>\n<li>价值观很正</li>\n</ul>\n<h2 id=\"爱好\"><a href=\"#爱好\" class=\"headerlink\" title=\"爱好\"></a>爱好</h2><ul>\n<li>主机游戏</li>\n<li>旅行</li>\n<li>🏀</li>\n<li>发呆</li>\n</ul>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><ul>\n<li>小语种学习中</li>\n</ul>\n"},{"title":"tags","date":"2019-08-27T13:13:30.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2019-08-27 21:13:30\ntype: \"tags\"\n---\n","updated":"2019-08-27T13:14:38.021Z","path":"tags/index.html","comments":1,"layout":"page","_id":"ck0wfvhr20011uhoxf3hf4dxt","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"关于双马谈话的感悟","date":"2019-09-07T13:53:38.000Z","_content":"\n刚看完双马对话的视频。\n马云跟马斯克的观点是基于未来跟现在、是唯心与唯物、是中国的中庸文化跟西方科学严谨的碰撞。\n每个人都是特定时代及环境的产物，就算牛如马云及马斯克也不例外。\n但是elon的一句话让我更为印象深刻，不以营利为目的的火星探索也印证了这句话的真正含义。 \n> 预测未来最好的方法是创造未来","source":"_posts/ElonAndJack.md","raw":"---\ntitle: 关于双马谈话的感悟\ndate: 2019-09-07 21:53:38\ncategories: \n- daily\ntags:\n- 日常\n- 思考\n---\n\n刚看完双马对话的视频。\n马云跟马斯克的观点是基于未来跟现在、是唯心与唯物、是中国的中庸文化跟西方科学严谨的碰撞。\n每个人都是特定时代及环境的产物，就算牛如马云及马斯克也不例外。\n但是elon的一句话让我更为印象深刻，不以营利为目的的火星探索也印证了这句话的真正含义。 \n> 预测未来最好的方法是创造未来","slug":"ElonAndJack","published":1,"updated":"2019-09-08T02:25:07.239Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0wfvhps0000uhoxm4zeu14s","content":"<p>刚看完双马对话的视频。<br>马云跟马斯克的观点是基于未来跟现在、是唯心与唯物、是中国的中庸文化跟西方科学严谨的碰撞。<br>每个人都是特定时代及环境的产物，就算牛如马云及马斯克也不例外。<br>但是elon的一句话让我更为印象深刻，不以营利为目的的火星探索也印证了这句话的真正含义。 </p>\n<blockquote>\n<p>预测未来最好的方法是创造未来</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<p>刚看完双马对话的视频。<br>马云跟马斯克的观点是基于未来跟现在、是唯心与唯物、是中国的中庸文化跟西方科学严谨的碰撞。<br>每个人都是特定时代及环境的产物，就算牛如马云及马斯克也不例外。<br>但是elon的一句话让我更为印象深刻，不以营利为目的的火星探索也印证了这句话的真正含义。 </p>\n<blockquote>\n<p>预测未来最好的方法是创造未来</p>\n</blockquote>\n"},{"title":"Travis-CI 持续集成 hexo 到云服务器","date":"2019-09-01T10:35:40.000Z","_content":"\n> 烦：每次本地提交代码到 GitHub 上后还要自己手动同步文件到云服务器，完成所谓的部署工作有点麻烦和脱节。\n> 懒：程序员等所有自称工程师进步的先决动力，想实现一个我每次提交代码后，后面的构建，打包和部署都自动进行的流程。\n> 因为本身代码托管在 Github 上，所以就开始折腾 Travis-CI了。\n\n\n## 什么是CI\n持续集成服务（Continuous Integration，简称 CI）。\n一般指的是提供一个运行环境，自动化执行单元测试，规范检查，基于环境的构建，服务部署等流水线作业。\n持续集成的目的，就是让产品可以快速迭代，同时还能保持高质量。\n另外，这个是工程化实践，如果你觉得自己手动操作比整这些繁琐的流程方便多了，我觉得也是没问题的。\n\n## Travis CI \n[Travis CI](https://travis-ci.com/) 对 Github 上的开源项目提供免费服务，这要求必须有 Github 账号。界面也很赞~，让我想起了前东家的 PLUS 发布系统。 \n![travis](/images/travis.png)\n可以使用 github 账号直接登录， public 的仓库也直接同步到 Travis 上了， 选择想开启 Travis CI 的仓库，打开开关即可。详细配置不细说了，图形化界面，进去就知道了。\n\n### .travis.yml\nTravis-CI配置文件，存放在项目根目录下。\n支持多种语言，在配置文件中 `language: node_js`\n一个比较完整的生命周期\n\n```bash\nbefore_install\ninstall\nbefore_script\nscript\naftersuccess or afterfailure\n[OPTIONAL] before_deploy\n[OPTIONAL] deploy\n[OPTIONAL] after_deploy\nafter_script\n```\n详细配置参考 [官方文档](https://docs.travis-ci.com)\n\n## 一些准备工作\n由于后面的免密登录和部署流程会涉及一些环境和配置类的操作，这个部分介绍下前置条件。\n\n### SCP命令\nscp 命令用于linux下的跨主机之间的文件和目录复制\n在首次连接服务器时，会弹出公钥确认的提示。这会导致某些自动化任务，由于初次连接服务器而导致自动化任务中断，\n可在 StrictHostKeyChecking选项，用 -o 参数指定后，则不检查该项。\n\n```bash\nscp [可选参数] file_source file_target\n#将public目录下的所有文件复制到$DEPLOY_IP下的/path/to/blog目录中。不检查key，\nscp -o StrictHostKeyChecking=no -r public/*  user@$DEPLOY_IP:/path/to/blog/\n#可用-i指定私钥。\nscp -o  StrictHostKeyChecking=no -i .ssh/id_rsa yourfile user@destinate_ip:/dest_folder\n#或将自己的公钥放到目标机的authorized_keys文件里，使自己为目标机的信任机器，实现无密码登录\n#这个是在生成ssh key 后，将公钥放到authorized_keys文件中。使用密钥对可以实现不输入密码\ncd ~/.ssh\ncat id_rsa.pub >> authorized_keys\n```\n\n### rsync 命令\n最终采用了 rsync 命令，我觉得都行，主要是这个同步成功了。\n```bash\nrsync -e \"ssh -o PubkeyAuthentication=yes  -o stricthostkeychecking=no\" -r --delete-after --quiet $TRAVIS_BUILD_DIR/public/* root@$DEPLOY_IP:/opt/hexoBlog\n```\n\n### centOS使用gem\n因为后面要使用 `gem install travis` ,所以可能会需要 升级 ruby 和 切换 gem 源（亲测 ruby 版本低会安装报错，gem 用官方源真的是动都不动啊，太难了）\n\n\n#### 切换gem源\n```bash\n$ gem sources --add https://gems.ruby-china.com/ --remove https://rubygems.org/\n$ gem sources -l\nhttps://gems.ruby-china.com\n# 确保只有 gems.ruby-china.com\n$ gem update --system \n$ gem -v\n2.6.3\n```\n#### 升级Ruby\n安装[RAM](https://rvm.io/), 一款ruby版本管理工具，类似 node 的 nvm。\n```bash\ngpg --keyserver hkp://keys.gnupg.net --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3 7D2BAF1CF37B13E2069D6956105BD0E739499BDB\ncurl -sSL https://get.rvm.io | bash -s stable\nsource /etc/profile.d/rvm.sh\nrvm -v\n```\n\n安装新版 ruby\n```bash\nrvm install 2.6\n```\n\n## 自动部署到远程服务器\n对于项目的构建来说都是 执行配置文件中写好的脚本，这个项目可能 就是 `npm install && hexo clean && hexo g`, 那么怎么执行最后一步，把文件同步传输到 云服务器上呢。 我们使用CI就是手动过程太繁琐，重复没有意义，怎么实现 `免密` 部署呢。\n\n登录到 `云服务器(centOS 7.x)`,进行如下操作\n### gem install travis 并登录\n```bash\ngem install travis #  这步失败的话请看上面关于升级ruby和切换gem源的部分\ntravis login\n```\n登录 github 账号密码，这个安全直接连接的 github 服务\n![login](/images/login.png)\n\n### 生成 ssh key 并输出对应加密的私钥到 travis \n进到云服务器对应的 git 仓库目录里\n```bash\nssh-keygen -t rsa -b 4096 -C 'build@travis-ci.org' -f ./deploy_rsa\ntravis encrypt-file deploy_rsa --add\nssh-copy-id -i deploy_rsa.pub <ssh-user>@<deploy-host>\n\nrm -f deploy_rsa deploy_rsa.pub\ngit add deploy_rsa.enc .travis.yml\n```\n项目根目录下的 `deploy_rsa.enc` 文件就是我们加密的私钥文件， `.travis.yml` 是我们的配置文件。\n$encrypted_XXXXXX_key 和 $encrypted_XXXXXXXX_iv 是travis 帮忙生成的环境变量，已经同步到 huguobo/hexo-blog 这个项目上了。\n![iv](/images/iv.png)\n\n还有一点可能会用上，因为 travis 第一次登录远程服务器会出现 SSH 主机验证，这边会有一个主机信任问题。官方给出的方案是添加 addons 配置，然后修改 .travis.yml 的相关配置\n```bash\naddons:\n  ssh_known_hosts: your-ip\n\nbefore_deploy:\n- openssl aes-256-cbc -K $encrypted_<...>_key -iv $encrypted_<...>_iv -in deploy_rsa.enc -out /tmp/deploy_rsa -d\n- eval \"$(ssh-agent -s)\"\n- chmod 600 /tmp/deploy_rsa\n- ssh-add /tmp/deploy_rsa\n```\n\n最终的部署配置, 我的是静态页面，部署就是同步文件到服务器固定目录，用的是 `rsync`，其中 -e \"ssh -o PubkeyAuthentication=yes  -o stricthostkeychecking=no\" 参数可以跳过第一次登录的验证。\n```bash\ndeploy:\n  provider: script\n  skip_cleanup: true\n  script: rsync -e \"ssh -o PubkeyAuthentication=yes  -o stricthostkeychecking=no\" -r --delete-after --quiet $TRAVIS_BUILD_DIR/public/* root@$DEPLOY_IP:/opt/hexoBlog\n  on:\n    branch: master\n```\n其他的 yml 配置需要自己根据情况配置了~\n\n## 我最终的 .travis.yml 配置\n\n```bash\nlanguage: node_js\n\nnode_js:\n  - \"10\"\n\ncache:\n  apt: true\n  directories:\n    - node_modules\n\naddons:\n  ssh_known_hosts: $DEPLOY_IP\n\ninstall:\n  - npm install hexo-cli@2.0.0 -g\n  - npm install\n\nscript:\n  - hexo clean \n  - hexo g\n\nbefore_deploy:\n- openssl aes-256-cbc -K $encrypted_25ad2a76f550_key -iv $encrypted_25ad2a76f550_iv -in deploy_rsa.enc -out deploy_rsa -d\n- eval \"$(ssh-agent -s)\"\n- chmod 600 deploy_rsa\n- ssh-add deploy_rsa\n\ndeploy:\n  provider: script\n  skip_cleanup: true\n  script: rsync -e \"ssh -o PubkeyAuthentication=yes  -o stricthostkeychecking=no\" -r --delete-after --quiet $TRAVIS_BUILD_DIR/public/* root@$DEPLOY_IP:/opt/hexoBlog\n  on:\n    branch: master\n\n# deploy:\n#   provider: script\n#   skip_cleanup: true\n#   script: scp -o StrictHostKeyChecking=no -r public/*  root@$DEPLOY_IP:/opt/hexoBlog/\n#   on:\n#      branch: master\n\nbranches:\n  only:\n    - master\n\nnotifications:\n  email:\n    - huguobo2010@126.com\n  on_success: change\n  on_failure: always\n```\n\n## 总结\n折腾了大半天，终于看到了 CI-Success 的邮件, 网站也是成功的状态，云主机对应目录的文件也确实更新了。\n以后写博客 终于 只用 git push ，其他的等邮件通知了~~\n另外 文中的 id_rsa.enc 文件一开始我直接 vim 复制的都是乱码，一开始一直报错 `bad decrypt` ，后来上主机 git clone 仓库直接仓库内生成并添加的，这可能是个坑点。\n还有最后用 `rsync` 代替了 `scp`\n最后也把 openssl 放在了 before_deploy 阶段，放在 before_install也是没问题的，这些都是因人而异啦。\n![success](/images/success.png)\n\n## 参考文章\n- https://oncletom.io/2016/travis-ssh-deploy/\n- http://www.ruanyifeng.com/blog/2017/12/travis_ci_tutorial.html\n- https://gems.ruby-china.com/","source":"_posts/Travis-CI持续集成Hexo到云服务器.md","raw":"---\ntitle: Travis-CI 持续集成 hexo 到云服务器\ndate: 2019-09-01 18:35:40\ncategories: \n- devOps\ntags:\n- travis\n- CI\n- hexo\n- gem\n---\n\n> 烦：每次本地提交代码到 GitHub 上后还要自己手动同步文件到云服务器，完成所谓的部署工作有点麻烦和脱节。\n> 懒：程序员等所有自称工程师进步的先决动力，想实现一个我每次提交代码后，后面的构建，打包和部署都自动进行的流程。\n> 因为本身代码托管在 Github 上，所以就开始折腾 Travis-CI了。\n\n\n## 什么是CI\n持续集成服务（Continuous Integration，简称 CI）。\n一般指的是提供一个运行环境，自动化执行单元测试，规范检查，基于环境的构建，服务部署等流水线作业。\n持续集成的目的，就是让产品可以快速迭代，同时还能保持高质量。\n另外，这个是工程化实践，如果你觉得自己手动操作比整这些繁琐的流程方便多了，我觉得也是没问题的。\n\n## Travis CI \n[Travis CI](https://travis-ci.com/) 对 Github 上的开源项目提供免费服务，这要求必须有 Github 账号。界面也很赞~，让我想起了前东家的 PLUS 发布系统。 \n![travis](/images/travis.png)\n可以使用 github 账号直接登录， public 的仓库也直接同步到 Travis 上了， 选择想开启 Travis CI 的仓库，打开开关即可。详细配置不细说了，图形化界面，进去就知道了。\n\n### .travis.yml\nTravis-CI配置文件，存放在项目根目录下。\n支持多种语言，在配置文件中 `language: node_js`\n一个比较完整的生命周期\n\n```bash\nbefore_install\ninstall\nbefore_script\nscript\naftersuccess or afterfailure\n[OPTIONAL] before_deploy\n[OPTIONAL] deploy\n[OPTIONAL] after_deploy\nafter_script\n```\n详细配置参考 [官方文档](https://docs.travis-ci.com)\n\n## 一些准备工作\n由于后面的免密登录和部署流程会涉及一些环境和配置类的操作，这个部分介绍下前置条件。\n\n### SCP命令\nscp 命令用于linux下的跨主机之间的文件和目录复制\n在首次连接服务器时，会弹出公钥确认的提示。这会导致某些自动化任务，由于初次连接服务器而导致自动化任务中断，\n可在 StrictHostKeyChecking选项，用 -o 参数指定后，则不检查该项。\n\n```bash\nscp [可选参数] file_source file_target\n#将public目录下的所有文件复制到$DEPLOY_IP下的/path/to/blog目录中。不检查key，\nscp -o StrictHostKeyChecking=no -r public/*  user@$DEPLOY_IP:/path/to/blog/\n#可用-i指定私钥。\nscp -o  StrictHostKeyChecking=no -i .ssh/id_rsa yourfile user@destinate_ip:/dest_folder\n#或将自己的公钥放到目标机的authorized_keys文件里，使自己为目标机的信任机器，实现无密码登录\n#这个是在生成ssh key 后，将公钥放到authorized_keys文件中。使用密钥对可以实现不输入密码\ncd ~/.ssh\ncat id_rsa.pub >> authorized_keys\n```\n\n### rsync 命令\n最终采用了 rsync 命令，我觉得都行，主要是这个同步成功了。\n```bash\nrsync -e \"ssh -o PubkeyAuthentication=yes  -o stricthostkeychecking=no\" -r --delete-after --quiet $TRAVIS_BUILD_DIR/public/* root@$DEPLOY_IP:/opt/hexoBlog\n```\n\n### centOS使用gem\n因为后面要使用 `gem install travis` ,所以可能会需要 升级 ruby 和 切换 gem 源（亲测 ruby 版本低会安装报错，gem 用官方源真的是动都不动啊，太难了）\n\n\n#### 切换gem源\n```bash\n$ gem sources --add https://gems.ruby-china.com/ --remove https://rubygems.org/\n$ gem sources -l\nhttps://gems.ruby-china.com\n# 确保只有 gems.ruby-china.com\n$ gem update --system \n$ gem -v\n2.6.3\n```\n#### 升级Ruby\n安装[RAM](https://rvm.io/), 一款ruby版本管理工具，类似 node 的 nvm。\n```bash\ngpg --keyserver hkp://keys.gnupg.net --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3 7D2BAF1CF37B13E2069D6956105BD0E739499BDB\ncurl -sSL https://get.rvm.io | bash -s stable\nsource /etc/profile.d/rvm.sh\nrvm -v\n```\n\n安装新版 ruby\n```bash\nrvm install 2.6\n```\n\n## 自动部署到远程服务器\n对于项目的构建来说都是 执行配置文件中写好的脚本，这个项目可能 就是 `npm install && hexo clean && hexo g`, 那么怎么执行最后一步，把文件同步传输到 云服务器上呢。 我们使用CI就是手动过程太繁琐，重复没有意义，怎么实现 `免密` 部署呢。\n\n登录到 `云服务器(centOS 7.x)`,进行如下操作\n### gem install travis 并登录\n```bash\ngem install travis #  这步失败的话请看上面关于升级ruby和切换gem源的部分\ntravis login\n```\n登录 github 账号密码，这个安全直接连接的 github 服务\n![login](/images/login.png)\n\n### 生成 ssh key 并输出对应加密的私钥到 travis \n进到云服务器对应的 git 仓库目录里\n```bash\nssh-keygen -t rsa -b 4096 -C 'build@travis-ci.org' -f ./deploy_rsa\ntravis encrypt-file deploy_rsa --add\nssh-copy-id -i deploy_rsa.pub <ssh-user>@<deploy-host>\n\nrm -f deploy_rsa deploy_rsa.pub\ngit add deploy_rsa.enc .travis.yml\n```\n项目根目录下的 `deploy_rsa.enc` 文件就是我们加密的私钥文件， `.travis.yml` 是我们的配置文件。\n$encrypted_XXXXXX_key 和 $encrypted_XXXXXXXX_iv 是travis 帮忙生成的环境变量，已经同步到 huguobo/hexo-blog 这个项目上了。\n![iv](/images/iv.png)\n\n还有一点可能会用上，因为 travis 第一次登录远程服务器会出现 SSH 主机验证，这边会有一个主机信任问题。官方给出的方案是添加 addons 配置，然后修改 .travis.yml 的相关配置\n```bash\naddons:\n  ssh_known_hosts: your-ip\n\nbefore_deploy:\n- openssl aes-256-cbc -K $encrypted_<...>_key -iv $encrypted_<...>_iv -in deploy_rsa.enc -out /tmp/deploy_rsa -d\n- eval \"$(ssh-agent -s)\"\n- chmod 600 /tmp/deploy_rsa\n- ssh-add /tmp/deploy_rsa\n```\n\n最终的部署配置, 我的是静态页面，部署就是同步文件到服务器固定目录，用的是 `rsync`，其中 -e \"ssh -o PubkeyAuthentication=yes  -o stricthostkeychecking=no\" 参数可以跳过第一次登录的验证。\n```bash\ndeploy:\n  provider: script\n  skip_cleanup: true\n  script: rsync -e \"ssh -o PubkeyAuthentication=yes  -o stricthostkeychecking=no\" -r --delete-after --quiet $TRAVIS_BUILD_DIR/public/* root@$DEPLOY_IP:/opt/hexoBlog\n  on:\n    branch: master\n```\n其他的 yml 配置需要自己根据情况配置了~\n\n## 我最终的 .travis.yml 配置\n\n```bash\nlanguage: node_js\n\nnode_js:\n  - \"10\"\n\ncache:\n  apt: true\n  directories:\n    - node_modules\n\naddons:\n  ssh_known_hosts: $DEPLOY_IP\n\ninstall:\n  - npm install hexo-cli@2.0.0 -g\n  - npm install\n\nscript:\n  - hexo clean \n  - hexo g\n\nbefore_deploy:\n- openssl aes-256-cbc -K $encrypted_25ad2a76f550_key -iv $encrypted_25ad2a76f550_iv -in deploy_rsa.enc -out deploy_rsa -d\n- eval \"$(ssh-agent -s)\"\n- chmod 600 deploy_rsa\n- ssh-add deploy_rsa\n\ndeploy:\n  provider: script\n  skip_cleanup: true\n  script: rsync -e \"ssh -o PubkeyAuthentication=yes  -o stricthostkeychecking=no\" -r --delete-after --quiet $TRAVIS_BUILD_DIR/public/* root@$DEPLOY_IP:/opt/hexoBlog\n  on:\n    branch: master\n\n# deploy:\n#   provider: script\n#   skip_cleanup: true\n#   script: scp -o StrictHostKeyChecking=no -r public/*  root@$DEPLOY_IP:/opt/hexoBlog/\n#   on:\n#      branch: master\n\nbranches:\n  only:\n    - master\n\nnotifications:\n  email:\n    - huguobo2010@126.com\n  on_success: change\n  on_failure: always\n```\n\n## 总结\n折腾了大半天，终于看到了 CI-Success 的邮件, 网站也是成功的状态，云主机对应目录的文件也确实更新了。\n以后写博客 终于 只用 git push ，其他的等邮件通知了~~\n另外 文中的 id_rsa.enc 文件一开始我直接 vim 复制的都是乱码，一开始一直报错 `bad decrypt` ，后来上主机 git clone 仓库直接仓库内生成并添加的，这可能是个坑点。\n还有最后用 `rsync` 代替了 `scp`\n最后也把 openssl 放在了 before_deploy 阶段，放在 before_install也是没问题的，这些都是因人而异啦。\n![success](/images/success.png)\n\n## 参考文章\n- https://oncletom.io/2016/travis-ssh-deploy/\n- http://www.ruanyifeng.com/blog/2017/12/travis_ci_tutorial.html\n- https://gems.ruby-china.com/","slug":"Travis-CI持续集成Hexo到云服务器","published":1,"updated":"2019-09-08T02:27:03.487Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0wfvhpv0001uhoxds59cq9t","content":"<blockquote>\n<p>烦：每次本地提交代码到 GitHub 上后还要自己手动同步文件到云服务器，完成所谓的部署工作有点麻烦和脱节。<br>懒：程序员等所有自称工程师进步的先决动力，想实现一个我每次提交代码后，后面的构建，打包和部署都自动进行的流程。<br>因为本身代码托管在 Github 上，所以就开始折腾 Travis-CI了。</p>\n</blockquote>\n<h2 id=\"什么是CI\"><a href=\"#什么是CI\" class=\"headerlink\" title=\"什么是CI\"></a>什么是CI</h2><p>持续集成服务（Continuous Integration，简称 CI）。<br>一般指的是提供一个运行环境，自动化执行单元测试，规范检查，基于环境的构建，服务部署等流水线作业。<br>持续集成的目的，就是让产品可以快速迭代，同时还能保持高质量。<br>另外，这个是工程化实践，如果你觉得自己手动操作比整这些繁琐的流程方便多了，我觉得也是没问题的。</p>\n<h2 id=\"Travis-CI\"><a href=\"#Travis-CI\" class=\"headerlink\" title=\"Travis CI\"></a>Travis CI</h2><p><a href=\"https://travis-ci.com/\" target=\"_blank\" rel=\"noopener\">Travis CI</a> 对 Github 上的开源项目提供免费服务，这要求必须有 Github 账号。界面也很赞~，让我想起了前东家的 PLUS 发布系统。<br><img src=\"/images/travis.png\" alt=\"travis\"><br>可以使用 github 账号直接登录， public 的仓库也直接同步到 Travis 上了， 选择想开启 Travis CI 的仓库，打开开关即可。详细配置不细说了，图形化界面，进去就知道了。</p>\n<h3 id=\"travis-yml\"><a href=\"#travis-yml\" class=\"headerlink\" title=\".travis.yml\"></a>.travis.yml</h3><p>Travis-CI配置文件，存放在项目根目录下。<br>支持多种语言，在配置文件中 <code>language: node_js</code><br>一个比较完整的生命周期</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">before_install</span><br><span class=\"line\">install</span><br><span class=\"line\">before_script</span><br><span class=\"line\">script</span><br><span class=\"line\">aftersuccess or afterfailure</span><br><span class=\"line\">[OPTIONAL] before_deploy</span><br><span class=\"line\">[OPTIONAL] deploy</span><br><span class=\"line\">[OPTIONAL] after_deploy</span><br><span class=\"line\">after_script</span><br></pre></td></tr></table></figure>\n\n<p>详细配置参考 <a href=\"https://docs.travis-ci.com\" target=\"_blank\" rel=\"noopener\">官方文档</a></p>\n<h2 id=\"一些准备工作\"><a href=\"#一些准备工作\" class=\"headerlink\" title=\"一些准备工作\"></a>一些准备工作</h2><p>由于后面的免密登录和部署流程会涉及一些环境和配置类的操作，这个部分介绍下前置条件。</p>\n<h3 id=\"SCP命令\"><a href=\"#SCP命令\" class=\"headerlink\" title=\"SCP命令\"></a>SCP命令</h3><p>scp 命令用于linux下的跨主机之间的文件和目录复制<br>在首次连接服务器时，会弹出公钥确认的提示。这会导致某些自动化任务，由于初次连接服务器而导致自动化任务中断，<br>可在 StrictHostKeyChecking选项，用 -o 参数指定后，则不检查该项。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scp [可选参数] file_source file_target</span><br><span class=\"line\"><span class=\"comment\">#将public目录下的所有文件复制到$DEPLOY_IP下的/path/to/blog目录中。不检查key，</span></span><br><span class=\"line\">scp -o StrictHostKeyChecking=no -r public/*  user@<span class=\"variable\">$DEPLOY_IP</span>:/path/to/blog/</span><br><span class=\"line\"><span class=\"comment\">#可用-i指定私钥。</span></span><br><span class=\"line\">scp -o  StrictHostKeyChecking=no -i .ssh/id_rsa yourfile user@destinate_ip:/dest_folder</span><br><span class=\"line\"><span class=\"comment\">#或将自己的公钥放到目标机的authorized_keys文件里，使自己为目标机的信任机器，实现无密码登录</span></span><br><span class=\"line\"><span class=\"comment\">#这个是在生成ssh key 后，将公钥放到authorized_keys文件中。使用密钥对可以实现不输入密码</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> ~/.ssh</span><br><span class=\"line\">cat id_rsa.pub &gt;&gt; authorized_keys</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"rsync-命令\"><a href=\"#rsync-命令\" class=\"headerlink\" title=\"rsync 命令\"></a>rsync 命令</h3><p>最终采用了 rsync 命令，我觉得都行，主要是这个同步成功了。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rsync -e <span class=\"string\">\"ssh -o PubkeyAuthentication=yes  -o stricthostkeychecking=no\"</span> -r --delete-after --quiet <span class=\"variable\">$TRAVIS_BUILD_DIR</span>/public/* root@<span class=\"variable\">$DEPLOY_IP</span>:/opt/hexoBlog</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"centOS使用gem\"><a href=\"#centOS使用gem\" class=\"headerlink\" title=\"centOS使用gem\"></a>centOS使用gem</h3><p>因为后面要使用 <code>gem install travis</code> ,所以可能会需要 升级 ruby 和 切换 gem 源（亲测 ruby 版本低会安装报错，gem 用官方源真的是动都不动啊，太难了）</p>\n<h4 id=\"切换gem源\"><a href=\"#切换gem源\" class=\"headerlink\" title=\"切换gem源\"></a>切换gem源</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ gem sources --add https://gems.ruby-china.com/ --remove https://rubygems.org/</span><br><span class=\"line\">$ gem sources -l</span><br><span class=\"line\">https://gems.ruby-china.com</span><br><span class=\"line\"><span class=\"comment\"># 确保只有 gems.ruby-china.com</span></span><br><span class=\"line\">$ gem update --system </span><br><span class=\"line\">$ gem -v</span><br><span class=\"line\">2.6.3</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"升级Ruby\"><a href=\"#升级Ruby\" class=\"headerlink\" title=\"升级Ruby\"></a>升级Ruby</h4><p>安装<a href=\"https://rvm.io/\" target=\"_blank\" rel=\"noopener\">RAM</a>, 一款ruby版本管理工具，类似 node 的 nvm。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gpg --keyserver hkp://keys.gnupg.net --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3 7D2BAF1CF37B13E2069D6956105BD0E739499BDB</span><br><span class=\"line\">curl -sSL https://get.rvm.io | bash -s stable</span><br><span class=\"line\"><span class=\"built_in\">source</span> /etc/profile.d/rvm.sh</span><br><span class=\"line\">rvm -v</span><br></pre></td></tr></table></figure>\n\n<p>安装新版 ruby</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rvm install 2.6</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"自动部署到远程服务器\"><a href=\"#自动部署到远程服务器\" class=\"headerlink\" title=\"自动部署到远程服务器\"></a>自动部署到远程服务器</h2><p>对于项目的构建来说都是 执行配置文件中写好的脚本，这个项目可能 就是 <code>npm install &amp;&amp; hexo clean &amp;&amp; hexo g</code>, 那么怎么执行最后一步，把文件同步传输到 云服务器上呢。 我们使用CI就是手动过程太繁琐，重复没有意义，怎么实现 <code>免密</code> 部署呢。</p>\n<p>登录到 <code>云服务器(centOS 7.x)</code>,进行如下操作</p>\n<h3 id=\"gem-install-travis-并登录\"><a href=\"#gem-install-travis-并登录\" class=\"headerlink\" title=\"gem install travis 并登录\"></a>gem install travis 并登录</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gem install travis <span class=\"comment\">#  这步失败的话请看上面关于升级ruby和切换gem源的部分</span></span><br><span class=\"line\">travis login</span><br></pre></td></tr></table></figure>\n\n<p>登录 github 账号密码，这个安全直接连接的 github 服务<br><img src=\"/images/login.png\" alt=\"login\"></p>\n<h3 id=\"生成-ssh-key-并输出对应加密的私钥到-travis\"><a href=\"#生成-ssh-key-并输出对应加密的私钥到-travis\" class=\"headerlink\" title=\"生成 ssh key 并输出对应加密的私钥到 travis\"></a>生成 ssh key 并输出对应加密的私钥到 travis</h3><p>进到云服务器对应的 git 仓库目录里</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-keygen -t rsa -b 4096 -C <span class=\"string\">'build@travis-ci.org'</span> -f ./deploy_rsa</span><br><span class=\"line\">travis encrypt-file deploy_rsa --add</span><br><span class=\"line\">ssh-copy-id -i deploy_rsa.pub &lt;ssh-user&gt;@&lt;deploy-host&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">rm -f deploy_rsa deploy_rsa.pub</span><br><span class=\"line\">git add deploy_rsa.enc .travis.yml</span><br></pre></td></tr></table></figure>\n\n<p>项目根目录下的 <code>deploy_rsa.enc</code> 文件就是我们加密的私钥文件， <code>.travis.yml</code> 是我们的配置文件。<br>$encrypted_XXXXXX_key 和 $encrypted_XXXXXXXX_iv 是travis 帮忙生成的环境变量，已经同步到 huguobo/hexo-blog 这个项目上了。<br><img src=\"/images/iv.png\" alt=\"iv\"></p>\n<p>还有一点可能会用上，因为 travis 第一次登录远程服务器会出现 SSH 主机验证，这边会有一个主机信任问题。官方给出的方案是添加 addons 配置，然后修改 .travis.yml 的相关配置</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">addons:</span><br><span class=\"line\">  ssh_known_hosts: your-ip</span><br><span class=\"line\"></span><br><span class=\"line\">before_deploy:</span><br><span class=\"line\">- openssl aes-256-cbc -K <span class=\"variable\">$encrypted_</span>&lt;...&gt;_key -iv <span class=\"variable\">$encrypted_</span>&lt;...&gt;_iv -<span class=\"keyword\">in</span> deploy_rsa.enc -out /tmp/deploy_rsa -d</span><br><span class=\"line\">- <span class=\"built_in\">eval</span> <span class=\"string\">\"<span class=\"variable\">$(ssh-agent -s)</span>\"</span></span><br><span class=\"line\">- chmod 600 /tmp/deploy_rsa</span><br><span class=\"line\">- ssh-add /tmp/deploy_rsa</span><br></pre></td></tr></table></figure>\n\n<p>最终的部署配置, 我的是静态页面，部署就是同步文件到服务器固定目录，用的是 <code>rsync</code>，其中 -e “ssh -o PubkeyAuthentication=yes  -o stricthostkeychecking=no” 参数可以跳过第一次登录的验证。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">  provider: script</span><br><span class=\"line\">  skip_cleanup: <span class=\"literal\">true</span></span><br><span class=\"line\">  script: rsync -e <span class=\"string\">\"ssh -o PubkeyAuthentication=yes  -o stricthostkeychecking=no\"</span> -r --delete-after --quiet <span class=\"variable\">$TRAVIS_BUILD_DIR</span>/public/* root@<span class=\"variable\">$DEPLOY_IP</span>:/opt/hexoBlog</span><br><span class=\"line\">  on:</span><br><span class=\"line\">    branch: master</span><br></pre></td></tr></table></figure>\n\n<p>其他的 yml 配置需要自己根据情况配置了~</p>\n<h2 id=\"我最终的-travis-yml-配置\"><a href=\"#我最终的-travis-yml-配置\" class=\"headerlink\" title=\"我最终的 .travis.yml 配置\"></a>我最终的 .travis.yml 配置</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">language: node_js</span><br><span class=\"line\"></span><br><span class=\"line\">node_js:</span><br><span class=\"line\">  - <span class=\"string\">\"10\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">cache:</span><br><span class=\"line\">  apt: <span class=\"literal\">true</span></span><br><span class=\"line\">  directories:</span><br><span class=\"line\">    - node_modules</span><br><span class=\"line\"></span><br><span class=\"line\">addons:</span><br><span class=\"line\">  ssh_known_hosts: <span class=\"variable\">$DEPLOY_IP</span></span><br><span class=\"line\"></span><br><span class=\"line\">install:</span><br><span class=\"line\">  - npm install hexo-cli@2.0.0 -g</span><br><span class=\"line\">  - npm install</span><br><span class=\"line\"></span><br><span class=\"line\">script:</span><br><span class=\"line\">  - hexo clean </span><br><span class=\"line\">  - hexo g</span><br><span class=\"line\"></span><br><span class=\"line\">before_deploy:</span><br><span class=\"line\">- openssl aes-256-cbc -K <span class=\"variable\">$encrypted_25ad2a76f550_key</span> -iv <span class=\"variable\">$encrypted_25ad2a76f550_iv</span> -<span class=\"keyword\">in</span> deploy_rsa.enc -out deploy_rsa -d</span><br><span class=\"line\">- <span class=\"built_in\">eval</span> <span class=\"string\">\"<span class=\"variable\">$(ssh-agent -s)</span>\"</span></span><br><span class=\"line\">- chmod 600 deploy_rsa</span><br><span class=\"line\">- ssh-add deploy_rsa</span><br><span class=\"line\"></span><br><span class=\"line\">deploy:</span><br><span class=\"line\">  provider: script</span><br><span class=\"line\">  skip_cleanup: <span class=\"literal\">true</span></span><br><span class=\"line\">  script: rsync -e <span class=\"string\">\"ssh -o PubkeyAuthentication=yes  -o stricthostkeychecking=no\"</span> -r --delete-after --quiet <span class=\"variable\">$TRAVIS_BUILD_DIR</span>/public/* root@<span class=\"variable\">$DEPLOY_IP</span>:/opt/hexoBlog</span><br><span class=\"line\">  on:</span><br><span class=\"line\">    branch: master</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># deploy:</span></span><br><span class=\"line\"><span class=\"comment\">#   provider: script</span></span><br><span class=\"line\"><span class=\"comment\">#   skip_cleanup: true</span></span><br><span class=\"line\"><span class=\"comment\">#   script: scp -o StrictHostKeyChecking=no -r public/*  root@$DEPLOY_IP:/opt/hexoBlog/</span></span><br><span class=\"line\"><span class=\"comment\">#   on:</span></span><br><span class=\"line\"><span class=\"comment\">#      branch: master</span></span><br><span class=\"line\"></span><br><span class=\"line\">branches:</span><br><span class=\"line\">  only:</span><br><span class=\"line\">    - master</span><br><span class=\"line\"></span><br><span class=\"line\">notifications:</span><br><span class=\"line\">  email:</span><br><span class=\"line\">    - huguobo2010@126.com</span><br><span class=\"line\">  on_success: change</span><br><span class=\"line\">  on_failure: always</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>折腾了大半天，终于看到了 CI-Success 的邮件, 网站也是成功的状态，云主机对应目录的文件也确实更新了。<br>以后写博客 终于 只用 git push ，其他的等邮件通知了~~<br>另外 文中的 id_rsa.enc 文件一开始我直接 vim 复制的都是乱码，一开始一直报错 <code>bad decrypt</code> ，后来上主机 git clone 仓库直接仓库内生成并添加的，这可能是个坑点。<br>还有最后用 <code>rsync</code> 代替了 <code>scp</code><br>最后也把 openssl 放在了 before_deploy 阶段，放在 before_install也是没问题的，这些都是因人而异啦。<br><img src=\"/images/success.png\" alt=\"success\"></p>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><ul>\n<li><a href=\"https://oncletom.io/2016/travis-ssh-deploy/\" target=\"_blank\" rel=\"noopener\">https://oncletom.io/2016/travis-ssh-deploy/</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2017/12/travis_ci_tutorial.html\" target=\"_blank\" rel=\"noopener\">http://www.ruanyifeng.com/blog/2017/12/travis_ci_tutorial.html</a></li>\n<li><a href=\"https://gems.ruby-china.com/\" target=\"_blank\" rel=\"noopener\">https://gems.ruby-china.com/</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>烦：每次本地提交代码到 GitHub 上后还要自己手动同步文件到云服务器，完成所谓的部署工作有点麻烦和脱节。<br>懒：程序员等所有自称工程师进步的先决动力，想实现一个我每次提交代码后，后面的构建，打包和部署都自动进行的流程。<br>因为本身代码托管在 Github 上，所以就开始折腾 Travis-CI了。</p>\n</blockquote>\n<h2 id=\"什么是CI\"><a href=\"#什么是CI\" class=\"headerlink\" title=\"什么是CI\"></a>什么是CI</h2><p>持续集成服务（Continuous Integration，简称 CI）。<br>一般指的是提供一个运行环境，自动化执行单元测试，规范检查，基于环境的构建，服务部署等流水线作业。<br>持续集成的目的，就是让产品可以快速迭代，同时还能保持高质量。<br>另外，这个是工程化实践，如果你觉得自己手动操作比整这些繁琐的流程方便多了，我觉得也是没问题的。</p>\n<h2 id=\"Travis-CI\"><a href=\"#Travis-CI\" class=\"headerlink\" title=\"Travis CI\"></a>Travis CI</h2><p><a href=\"https://travis-ci.com/\" target=\"_blank\" rel=\"noopener\">Travis CI</a> 对 Github 上的开源项目提供免费服务，这要求必须有 Github 账号。界面也很赞~，让我想起了前东家的 PLUS 发布系统。<br><img src=\"/images/travis.png\" alt=\"travis\"><br>可以使用 github 账号直接登录， public 的仓库也直接同步到 Travis 上了， 选择想开启 Travis CI 的仓库，打开开关即可。详细配置不细说了，图形化界面，进去就知道了。</p>\n<h3 id=\"travis-yml\"><a href=\"#travis-yml\" class=\"headerlink\" title=\".travis.yml\"></a>.travis.yml</h3><p>Travis-CI配置文件，存放在项目根目录下。<br>支持多种语言，在配置文件中 <code>language: node_js</code><br>一个比较完整的生命周期</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">before_install</span><br><span class=\"line\">install</span><br><span class=\"line\">before_script</span><br><span class=\"line\">script</span><br><span class=\"line\">aftersuccess or afterfailure</span><br><span class=\"line\">[OPTIONAL] before_deploy</span><br><span class=\"line\">[OPTIONAL] deploy</span><br><span class=\"line\">[OPTIONAL] after_deploy</span><br><span class=\"line\">after_script</span><br></pre></td></tr></table></figure>\n\n<p>详细配置参考 <a href=\"https://docs.travis-ci.com\" target=\"_blank\" rel=\"noopener\">官方文档</a></p>\n<h2 id=\"一些准备工作\"><a href=\"#一些准备工作\" class=\"headerlink\" title=\"一些准备工作\"></a>一些准备工作</h2><p>由于后面的免密登录和部署流程会涉及一些环境和配置类的操作，这个部分介绍下前置条件。</p>\n<h3 id=\"SCP命令\"><a href=\"#SCP命令\" class=\"headerlink\" title=\"SCP命令\"></a>SCP命令</h3><p>scp 命令用于linux下的跨主机之间的文件和目录复制<br>在首次连接服务器时，会弹出公钥确认的提示。这会导致某些自动化任务，由于初次连接服务器而导致自动化任务中断，<br>可在 StrictHostKeyChecking选项，用 -o 参数指定后，则不检查该项。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scp [可选参数] file_source file_target</span><br><span class=\"line\"><span class=\"comment\">#将public目录下的所有文件复制到$DEPLOY_IP下的/path/to/blog目录中。不检查key，</span></span><br><span class=\"line\">scp -o StrictHostKeyChecking=no -r public/*  user@<span class=\"variable\">$DEPLOY_IP</span>:/path/to/blog/</span><br><span class=\"line\"><span class=\"comment\">#可用-i指定私钥。</span></span><br><span class=\"line\">scp -o  StrictHostKeyChecking=no -i .ssh/id_rsa yourfile user@destinate_ip:/dest_folder</span><br><span class=\"line\"><span class=\"comment\">#或将自己的公钥放到目标机的authorized_keys文件里，使自己为目标机的信任机器，实现无密码登录</span></span><br><span class=\"line\"><span class=\"comment\">#这个是在生成ssh key 后，将公钥放到authorized_keys文件中。使用密钥对可以实现不输入密码</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> ~/.ssh</span><br><span class=\"line\">cat id_rsa.pub &gt;&gt; authorized_keys</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"rsync-命令\"><a href=\"#rsync-命令\" class=\"headerlink\" title=\"rsync 命令\"></a>rsync 命令</h3><p>最终采用了 rsync 命令，我觉得都行，主要是这个同步成功了。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rsync -e <span class=\"string\">\"ssh -o PubkeyAuthentication=yes  -o stricthostkeychecking=no\"</span> -r --delete-after --quiet <span class=\"variable\">$TRAVIS_BUILD_DIR</span>/public/* root@<span class=\"variable\">$DEPLOY_IP</span>:/opt/hexoBlog</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"centOS使用gem\"><a href=\"#centOS使用gem\" class=\"headerlink\" title=\"centOS使用gem\"></a>centOS使用gem</h3><p>因为后面要使用 <code>gem install travis</code> ,所以可能会需要 升级 ruby 和 切换 gem 源（亲测 ruby 版本低会安装报错，gem 用官方源真的是动都不动啊，太难了）</p>\n<h4 id=\"切换gem源\"><a href=\"#切换gem源\" class=\"headerlink\" title=\"切换gem源\"></a>切换gem源</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ gem sources --add https://gems.ruby-china.com/ --remove https://rubygems.org/</span><br><span class=\"line\">$ gem sources -l</span><br><span class=\"line\">https://gems.ruby-china.com</span><br><span class=\"line\"><span class=\"comment\"># 确保只有 gems.ruby-china.com</span></span><br><span class=\"line\">$ gem update --system </span><br><span class=\"line\">$ gem -v</span><br><span class=\"line\">2.6.3</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"升级Ruby\"><a href=\"#升级Ruby\" class=\"headerlink\" title=\"升级Ruby\"></a>升级Ruby</h4><p>安装<a href=\"https://rvm.io/\" target=\"_blank\" rel=\"noopener\">RAM</a>, 一款ruby版本管理工具，类似 node 的 nvm。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gpg --keyserver hkp://keys.gnupg.net --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3 7D2BAF1CF37B13E2069D6956105BD0E739499BDB</span><br><span class=\"line\">curl -sSL https://get.rvm.io | bash -s stable</span><br><span class=\"line\"><span class=\"built_in\">source</span> /etc/profile.d/rvm.sh</span><br><span class=\"line\">rvm -v</span><br></pre></td></tr></table></figure>\n\n<p>安装新版 ruby</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rvm install 2.6</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"自动部署到远程服务器\"><a href=\"#自动部署到远程服务器\" class=\"headerlink\" title=\"自动部署到远程服务器\"></a>自动部署到远程服务器</h2><p>对于项目的构建来说都是 执行配置文件中写好的脚本，这个项目可能 就是 <code>npm install &amp;&amp; hexo clean &amp;&amp; hexo g</code>, 那么怎么执行最后一步，把文件同步传输到 云服务器上呢。 我们使用CI就是手动过程太繁琐，重复没有意义，怎么实现 <code>免密</code> 部署呢。</p>\n<p>登录到 <code>云服务器(centOS 7.x)</code>,进行如下操作</p>\n<h3 id=\"gem-install-travis-并登录\"><a href=\"#gem-install-travis-并登录\" class=\"headerlink\" title=\"gem install travis 并登录\"></a>gem install travis 并登录</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gem install travis <span class=\"comment\">#  这步失败的话请看上面关于升级ruby和切换gem源的部分</span></span><br><span class=\"line\">travis login</span><br></pre></td></tr></table></figure>\n\n<p>登录 github 账号密码，这个安全直接连接的 github 服务<br><img src=\"/images/login.png\" alt=\"login\"></p>\n<h3 id=\"生成-ssh-key-并输出对应加密的私钥到-travis\"><a href=\"#生成-ssh-key-并输出对应加密的私钥到-travis\" class=\"headerlink\" title=\"生成 ssh key 并输出对应加密的私钥到 travis\"></a>生成 ssh key 并输出对应加密的私钥到 travis</h3><p>进到云服务器对应的 git 仓库目录里</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-keygen -t rsa -b 4096 -C <span class=\"string\">'build@travis-ci.org'</span> -f ./deploy_rsa</span><br><span class=\"line\">travis encrypt-file deploy_rsa --add</span><br><span class=\"line\">ssh-copy-id -i deploy_rsa.pub &lt;ssh-user&gt;@&lt;deploy-host&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">rm -f deploy_rsa deploy_rsa.pub</span><br><span class=\"line\">git add deploy_rsa.enc .travis.yml</span><br></pre></td></tr></table></figure>\n\n<p>项目根目录下的 <code>deploy_rsa.enc</code> 文件就是我们加密的私钥文件， <code>.travis.yml</code> 是我们的配置文件。<br>$encrypted_XXXXXX_key 和 $encrypted_XXXXXXXX_iv 是travis 帮忙生成的环境变量，已经同步到 huguobo/hexo-blog 这个项目上了。<br><img src=\"/images/iv.png\" alt=\"iv\"></p>\n<p>还有一点可能会用上，因为 travis 第一次登录远程服务器会出现 SSH 主机验证，这边会有一个主机信任问题。官方给出的方案是添加 addons 配置，然后修改 .travis.yml 的相关配置</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">addons:</span><br><span class=\"line\">  ssh_known_hosts: your-ip</span><br><span class=\"line\"></span><br><span class=\"line\">before_deploy:</span><br><span class=\"line\">- openssl aes-256-cbc -K <span class=\"variable\">$encrypted_</span>&lt;...&gt;_key -iv <span class=\"variable\">$encrypted_</span>&lt;...&gt;_iv -<span class=\"keyword\">in</span> deploy_rsa.enc -out /tmp/deploy_rsa -d</span><br><span class=\"line\">- <span class=\"built_in\">eval</span> <span class=\"string\">\"<span class=\"variable\">$(ssh-agent -s)</span>\"</span></span><br><span class=\"line\">- chmod 600 /tmp/deploy_rsa</span><br><span class=\"line\">- ssh-add /tmp/deploy_rsa</span><br></pre></td></tr></table></figure>\n\n<p>最终的部署配置, 我的是静态页面，部署就是同步文件到服务器固定目录，用的是 <code>rsync</code>，其中 -e “ssh -o PubkeyAuthentication=yes  -o stricthostkeychecking=no” 参数可以跳过第一次登录的验证。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">  provider: script</span><br><span class=\"line\">  skip_cleanup: <span class=\"literal\">true</span></span><br><span class=\"line\">  script: rsync -e <span class=\"string\">\"ssh -o PubkeyAuthentication=yes  -o stricthostkeychecking=no\"</span> -r --delete-after --quiet <span class=\"variable\">$TRAVIS_BUILD_DIR</span>/public/* root@<span class=\"variable\">$DEPLOY_IP</span>:/opt/hexoBlog</span><br><span class=\"line\">  on:</span><br><span class=\"line\">    branch: master</span><br></pre></td></tr></table></figure>\n\n<p>其他的 yml 配置需要自己根据情况配置了~</p>\n<h2 id=\"我最终的-travis-yml-配置\"><a href=\"#我最终的-travis-yml-配置\" class=\"headerlink\" title=\"我最终的 .travis.yml 配置\"></a>我最终的 .travis.yml 配置</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">language: node_js</span><br><span class=\"line\"></span><br><span class=\"line\">node_js:</span><br><span class=\"line\">  - <span class=\"string\">\"10\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">cache:</span><br><span class=\"line\">  apt: <span class=\"literal\">true</span></span><br><span class=\"line\">  directories:</span><br><span class=\"line\">    - node_modules</span><br><span class=\"line\"></span><br><span class=\"line\">addons:</span><br><span class=\"line\">  ssh_known_hosts: <span class=\"variable\">$DEPLOY_IP</span></span><br><span class=\"line\"></span><br><span class=\"line\">install:</span><br><span class=\"line\">  - npm install hexo-cli@2.0.0 -g</span><br><span class=\"line\">  - npm install</span><br><span class=\"line\"></span><br><span class=\"line\">script:</span><br><span class=\"line\">  - hexo clean </span><br><span class=\"line\">  - hexo g</span><br><span class=\"line\"></span><br><span class=\"line\">before_deploy:</span><br><span class=\"line\">- openssl aes-256-cbc -K <span class=\"variable\">$encrypted_25ad2a76f550_key</span> -iv <span class=\"variable\">$encrypted_25ad2a76f550_iv</span> -<span class=\"keyword\">in</span> deploy_rsa.enc -out deploy_rsa -d</span><br><span class=\"line\">- <span class=\"built_in\">eval</span> <span class=\"string\">\"<span class=\"variable\">$(ssh-agent -s)</span>\"</span></span><br><span class=\"line\">- chmod 600 deploy_rsa</span><br><span class=\"line\">- ssh-add deploy_rsa</span><br><span class=\"line\"></span><br><span class=\"line\">deploy:</span><br><span class=\"line\">  provider: script</span><br><span class=\"line\">  skip_cleanup: <span class=\"literal\">true</span></span><br><span class=\"line\">  script: rsync -e <span class=\"string\">\"ssh -o PubkeyAuthentication=yes  -o stricthostkeychecking=no\"</span> -r --delete-after --quiet <span class=\"variable\">$TRAVIS_BUILD_DIR</span>/public/* root@<span class=\"variable\">$DEPLOY_IP</span>:/opt/hexoBlog</span><br><span class=\"line\">  on:</span><br><span class=\"line\">    branch: master</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># deploy:</span></span><br><span class=\"line\"><span class=\"comment\">#   provider: script</span></span><br><span class=\"line\"><span class=\"comment\">#   skip_cleanup: true</span></span><br><span class=\"line\"><span class=\"comment\">#   script: scp -o StrictHostKeyChecking=no -r public/*  root@$DEPLOY_IP:/opt/hexoBlog/</span></span><br><span class=\"line\"><span class=\"comment\">#   on:</span></span><br><span class=\"line\"><span class=\"comment\">#      branch: master</span></span><br><span class=\"line\"></span><br><span class=\"line\">branches:</span><br><span class=\"line\">  only:</span><br><span class=\"line\">    - master</span><br><span class=\"line\"></span><br><span class=\"line\">notifications:</span><br><span class=\"line\">  email:</span><br><span class=\"line\">    - huguobo2010@126.com</span><br><span class=\"line\">  on_success: change</span><br><span class=\"line\">  on_failure: always</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>折腾了大半天，终于看到了 CI-Success 的邮件, 网站也是成功的状态，云主机对应目录的文件也确实更新了。<br>以后写博客 终于 只用 git push ，其他的等邮件通知了~~<br>另外 文中的 id_rsa.enc 文件一开始我直接 vim 复制的都是乱码，一开始一直报错 <code>bad decrypt</code> ，后来上主机 git clone 仓库直接仓库内生成并添加的，这可能是个坑点。<br>还有最后用 <code>rsync</code> 代替了 <code>scp</code><br>最后也把 openssl 放在了 before_deploy 阶段，放在 before_install也是没问题的，这些都是因人而异啦。<br><img src=\"/images/success.png\" alt=\"success\"></p>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><ul>\n<li><a href=\"https://oncletom.io/2016/travis-ssh-deploy/\" target=\"_blank\" rel=\"noopener\">https://oncletom.io/2016/travis-ssh-deploy/</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2017/12/travis_ci_tutorial.html\" target=\"_blank\" rel=\"noopener\">http://www.ruanyifeng.com/blog/2017/12/travis_ci_tutorial.html</a></li>\n<li><a href=\"https://gems.ruby-china.com/\" target=\"_blank\" rel=\"noopener\">https://gems.ruby-china.com/</a></li>\n</ul>\n"},{"title":"Node模块机制","date":"2019-08-31T15:37:17.000Z","_content":"\n## CommonJS 模块规范\n主要分为模块引用、模块定义和模块标识3个部分。\n### 模块引用\n```JavaScript\nconst foo = require('foo')\n```\n### 模块定义\n使用require进行引入，上下文提供了exports对象用于导出当前模块的方法或者变量，并且它是唯一的出口。在模块中还存在一个module对象，代表模块自身。在Node中一个文件就是一个模块，将方法挂载到exports对象上作为属性即可定义导出的方式。\n```JavaScript\n// foo.js\nexports.sum = (a,b) => a+b;\n```\n### 模块标识\n模块标记就是传递给require()方法的参数，其实就是文件模块的路径。\n\n## Node的模块实现\n在Node中，模块分为两类:一类是Node提供的模块，称为核心模块;另一类是用户编写的，称为文件模块。\n- 核心模块在node源代码的编译过程中，编译进了二进制执行文件中。在NOde进程启动时，核心模块就直接被加载到内存中。\n- 文件模块则是在 `运行时动态加载`，需要完整的路径分析、文件定位、编译执行过程，速度比核心模块慢。\n注：Node对引用过的模块多会进行缓存，缓存的是编译和执行后的对象。\n\n在Node中引入模块，需要经历下面3个步骤\n1. 路径分析\n2. 文件定位\n3. 编译执行\n  \n### 路径分析\nrequire接受一个模块标识作为参数，基于这个参数进行模块查找。\n核心模块和路径形式的引用不细作说明。\n这里说下 `自定义模块` 分析过程,自定义模块指的是既非核心模块，也不是路径形式的标识符。\n模块路径是Node在定位未见时的查找策略，具体表现为一个路径组成的数组。路径的生成规则大概如下：\n- 当前文件目录下的node_modules目录。\n- 父目录下的node_modules目录。\n- 父目录的父目录下的node_modules目录。 \n- 沿路径向上逐级递归，直到根目录下的node_modules目录。\n\n### 文件定位\n- 扩展名\nrequire()在分析标识符的过程中，会出现标识符中不包含文件扩展名的情况。CommonJS模块规范也允许在标识符中不包含文件扩展名，这种情况下，Node会按.js、.json、.node的次序补 足扩展名，依次尝试。\n- 目录分析和包\n在分析标识符的过程中，require()通过分析文件扩展名之后，可能没有查找到对应文件，但\n却得到一个目录，这在引入自定义模块和逐个模块路径进行查找时经常会出现，此时Node会将目 录当做一个包来处理。\n在这个过程中，Node对CommonJS包规范进行了一定程度的支持。首先，Node在当前目录下 查找package.json(CommonJS包规范定义的包描述文件)，通过JSON.parse()解析出包描述对象， 从中取出main属性指定的文件名进行定位。如果文件名缺少扩展名，将会进入扩展名分析的步骤。\n而如果main属性指定的文件名错误，或者压根没有package.json文件，Node会将index当做默 认文件名，然后依次查找index.js、index.json、index.node。\n\n### 模块编译\n在Node中每个文件模块都是一个对象\n```JavaScript\nfunction Module(id, parent) { \n  this.id = id;\n  this.exports = {}; \n  this.parent = parent;\n  if (parent && parent.children) { \n    parent.children.push(this);\n  }\n  this.filename = null; \n  this.loaded = false; \n  this.children = [];\n}\n```\n编译和执行是引入文件模块的最后一个阶段。定位到具体的文件后，Node会新建一个模块对 象，然后根据路径载入并编译。对于不同的文件扩展名，其载入方法也有所不同，具体如下所示。\n- .js文件。通过fs模块同步读取文件后编译执行。\n- .node文件。这是用C/C++编写的扩展文件，通过dlopen()方法加载最后编译生成的文件。  .json文件。通过fs模块同步读取文件后，用JSON.parse()解析返回结果。\n- 其余扩展名文件。它们都被当做.js文件载入\n每一个编译成功的模块都会将其文件路径作为索引缓存在Module._cache对象上，以提高二次引入的性能。\n\n#### JavaScript模块的编译\n回到CommonJS模块规范，我们知道每个模块文件中存在着require、exports、module这3个\n变量，但是它们在模块文件中并没有定义，那么从何而来呢?甚至在Node的API文档中，我们知 道每个模块中还有__filename、__dirname这两个变量的存在，它们又是从何而来的呢?如果我们 把直接定义模块的过程放诸在浏览器端，会存在污染全局变量的情况。\n事实上，在编译的过程中，Node对获取的JavaScript文件内容进行了头尾包装。在头部添加 了(function (exports, require, module, __filename, __dirname) {\\n，在尾部添加了\\n});。 一个正常的JavaScript文件会被包装成如下的样子:\n```JavaScript\n(function (exports, require, module, __filename, __dirname) { \n  var math = require('math');\n  exports.area = function (radius) {\n    return Math.PI * radius * radius; \n  };\n });\n```\n这样每个模块文件之间都进行了作用域隔离。包装之后的代码会通过vm原生模块的\nrunInThisContext()方法执行(类似eval，只是具有明确上下文，不污染全局)，返回一个具体的 function对象。最后，将当前模块对象的exports属性、require()方法、module(模块对象自身)， 以及在文件定位中得到的完整文件路径和文件目录作为参数传递给这个function()执行。\n这就是这些变量并没有定义在每个模块文件中却存在的原因。在执行之后，模块的exports 属性被返回给了调用方。exports属性上的任何方法和属性都可以被外部调用到，但是模块中的 其余变量或属性则不可直接被调用。\n\n此外，许多初学者都曾经纠结过为何存在exports的情况下，还存在module.exports。理想情\n况下，只要赋值给exports即可:\n```JavaScript\nexports = function () { // My Class\n```\n}; 但是通常都会得到一个失败的结果。其原因在于，exports对象是通过形参的方式传入的，\n直接赋值形参会改变形参的引用，但并不能改变作用域外的值。测试代码如下:\n```JavaScript\nvar change = function (a) { a = 100;\nconsole.log(a); // => 100\n};\nvar a = 10;\nchange(a); console.log(a); // => 10\n```\n如果要达到require引入一个类的效果，请赋值给module.exports对象。这个迂回的方案不改 变形参的引用。","source":"_posts/node-1.md","raw":"---\ntitle: Node模块机制\ndate: 2019-08-31 23:37:17\ncategories: \n- NODE\ntags:\n- NODE\n---\n\n## CommonJS 模块规范\n主要分为模块引用、模块定义和模块标识3个部分。\n### 模块引用\n```JavaScript\nconst foo = require('foo')\n```\n### 模块定义\n使用require进行引入，上下文提供了exports对象用于导出当前模块的方法或者变量，并且它是唯一的出口。在模块中还存在一个module对象，代表模块自身。在Node中一个文件就是一个模块，将方法挂载到exports对象上作为属性即可定义导出的方式。\n```JavaScript\n// foo.js\nexports.sum = (a,b) => a+b;\n```\n### 模块标识\n模块标记就是传递给require()方法的参数，其实就是文件模块的路径。\n\n## Node的模块实现\n在Node中，模块分为两类:一类是Node提供的模块，称为核心模块;另一类是用户编写的，称为文件模块。\n- 核心模块在node源代码的编译过程中，编译进了二进制执行文件中。在NOde进程启动时，核心模块就直接被加载到内存中。\n- 文件模块则是在 `运行时动态加载`，需要完整的路径分析、文件定位、编译执行过程，速度比核心模块慢。\n注：Node对引用过的模块多会进行缓存，缓存的是编译和执行后的对象。\n\n在Node中引入模块，需要经历下面3个步骤\n1. 路径分析\n2. 文件定位\n3. 编译执行\n  \n### 路径分析\nrequire接受一个模块标识作为参数，基于这个参数进行模块查找。\n核心模块和路径形式的引用不细作说明。\n这里说下 `自定义模块` 分析过程,自定义模块指的是既非核心模块，也不是路径形式的标识符。\n模块路径是Node在定位未见时的查找策略，具体表现为一个路径组成的数组。路径的生成规则大概如下：\n- 当前文件目录下的node_modules目录。\n- 父目录下的node_modules目录。\n- 父目录的父目录下的node_modules目录。 \n- 沿路径向上逐级递归，直到根目录下的node_modules目录。\n\n### 文件定位\n- 扩展名\nrequire()在分析标识符的过程中，会出现标识符中不包含文件扩展名的情况。CommonJS模块规范也允许在标识符中不包含文件扩展名，这种情况下，Node会按.js、.json、.node的次序补 足扩展名，依次尝试。\n- 目录分析和包\n在分析标识符的过程中，require()通过分析文件扩展名之后，可能没有查找到对应文件，但\n却得到一个目录，这在引入自定义模块和逐个模块路径进行查找时经常会出现，此时Node会将目 录当做一个包来处理。\n在这个过程中，Node对CommonJS包规范进行了一定程度的支持。首先，Node在当前目录下 查找package.json(CommonJS包规范定义的包描述文件)，通过JSON.parse()解析出包描述对象， 从中取出main属性指定的文件名进行定位。如果文件名缺少扩展名，将会进入扩展名分析的步骤。\n而如果main属性指定的文件名错误，或者压根没有package.json文件，Node会将index当做默 认文件名，然后依次查找index.js、index.json、index.node。\n\n### 模块编译\n在Node中每个文件模块都是一个对象\n```JavaScript\nfunction Module(id, parent) { \n  this.id = id;\n  this.exports = {}; \n  this.parent = parent;\n  if (parent && parent.children) { \n    parent.children.push(this);\n  }\n  this.filename = null; \n  this.loaded = false; \n  this.children = [];\n}\n```\n编译和执行是引入文件模块的最后一个阶段。定位到具体的文件后，Node会新建一个模块对 象，然后根据路径载入并编译。对于不同的文件扩展名，其载入方法也有所不同，具体如下所示。\n- .js文件。通过fs模块同步读取文件后编译执行。\n- .node文件。这是用C/C++编写的扩展文件，通过dlopen()方法加载最后编译生成的文件。  .json文件。通过fs模块同步读取文件后，用JSON.parse()解析返回结果。\n- 其余扩展名文件。它们都被当做.js文件载入\n每一个编译成功的模块都会将其文件路径作为索引缓存在Module._cache对象上，以提高二次引入的性能。\n\n#### JavaScript模块的编译\n回到CommonJS模块规范，我们知道每个模块文件中存在着require、exports、module这3个\n变量，但是它们在模块文件中并没有定义，那么从何而来呢?甚至在Node的API文档中，我们知 道每个模块中还有__filename、__dirname这两个变量的存在，它们又是从何而来的呢?如果我们 把直接定义模块的过程放诸在浏览器端，会存在污染全局变量的情况。\n事实上，在编译的过程中，Node对获取的JavaScript文件内容进行了头尾包装。在头部添加 了(function (exports, require, module, __filename, __dirname) {\\n，在尾部添加了\\n});。 一个正常的JavaScript文件会被包装成如下的样子:\n```JavaScript\n(function (exports, require, module, __filename, __dirname) { \n  var math = require('math');\n  exports.area = function (radius) {\n    return Math.PI * radius * radius; \n  };\n });\n```\n这样每个模块文件之间都进行了作用域隔离。包装之后的代码会通过vm原生模块的\nrunInThisContext()方法执行(类似eval，只是具有明确上下文，不污染全局)，返回一个具体的 function对象。最后，将当前模块对象的exports属性、require()方法、module(模块对象自身)， 以及在文件定位中得到的完整文件路径和文件目录作为参数传递给这个function()执行。\n这就是这些变量并没有定义在每个模块文件中却存在的原因。在执行之后，模块的exports 属性被返回给了调用方。exports属性上的任何方法和属性都可以被外部调用到，但是模块中的 其余变量或属性则不可直接被调用。\n\n此外，许多初学者都曾经纠结过为何存在exports的情况下，还存在module.exports。理想情\n况下，只要赋值给exports即可:\n```JavaScript\nexports = function () { // My Class\n```\n}; 但是通常都会得到一个失败的结果。其原因在于，exports对象是通过形参的方式传入的，\n直接赋值形参会改变形参的引用，但并不能改变作用域外的值。测试代码如下:\n```JavaScript\nvar change = function (a) { a = 100;\nconsole.log(a); // => 100\n};\nvar a = 10;\nchange(a); console.log(a); // => 10\n```\n如果要达到require引入一个类的效果，请赋值给module.exports对象。这个迂回的方案不改 变形参的引用。","slug":"node-1","published":1,"updated":"2019-09-23T13:24:56.621Z","_id":"ck0wfvhpy0004uhoxve5se6ml","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"CommonJS-模块规范\"><a href=\"#CommonJS-模块规范\" class=\"headerlink\" title=\"CommonJS 模块规范\"></a>CommonJS 模块规范</h2><p>主要分为模块引用、模块定义和模块标识3个部分。</p>\n<h3 id=\"模块引用\"><a href=\"#模块引用\" class=\"headerlink\" title=\"模块引用\"></a>模块引用</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> foo = <span class=\"built_in\">require</span>(<span class=\"string\">'foo'</span>)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"模块定义\"><a href=\"#模块定义\" class=\"headerlink\" title=\"模块定义\"></a>模块定义</h3><p>使用require进行引入，上下文提供了exports对象用于导出当前模块的方法或者变量，并且它是唯一的出口。在模块中还存在一个module对象，代表模块自身。在Node中一个文件就是一个模块，将方法挂载到exports对象上作为属性即可定义导出的方式。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// foo.js</span></span><br><span class=\"line\">exports.sum = <span class=\"function\">(<span class=\"params\">a,b</span>) =&gt;</span> a+b;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"模块标识\"><a href=\"#模块标识\" class=\"headerlink\" title=\"模块标识\"></a>模块标识</h3><p>模块标记就是传递给require()方法的参数，其实就是文件模块的路径。</p>\n<h2 id=\"Node的模块实现\"><a href=\"#Node的模块实现\" class=\"headerlink\" title=\"Node的模块实现\"></a>Node的模块实现</h2><p>在Node中，模块分为两类:一类是Node提供的模块，称为核心模块;另一类是用户编写的，称为文件模块。</p>\n<ul>\n<li>核心模块在node源代码的编译过程中，编译进了二进制执行文件中。在NOde进程启动时，核心模块就直接被加载到内存中。</li>\n<li>文件模块则是在 <code>运行时动态加载</code>，需要完整的路径分析、文件定位、编译执行过程，速度比核心模块慢。<br>注：Node对引用过的模块多会进行缓存，缓存的是编译和执行后的对象。</li>\n</ul>\n<p>在Node中引入模块，需要经历下面3个步骤</p>\n<ol>\n<li>路径分析</li>\n<li>文件定位</li>\n<li>编译执行</li>\n</ol>\n<h3 id=\"路径分析\"><a href=\"#路径分析\" class=\"headerlink\" title=\"路径分析\"></a>路径分析</h3><p>require接受一个模块标识作为参数，基于这个参数进行模块查找。<br>核心模块和路径形式的引用不细作说明。<br>这里说下 <code>自定义模块</code> 分析过程,自定义模块指的是既非核心模块，也不是路径形式的标识符。<br>模块路径是Node在定位未见时的查找策略，具体表现为一个路径组成的数组。路径的生成规则大概如下：</p>\n<ul>\n<li>当前文件目录下的node_modules目录。</li>\n<li>父目录下的node_modules目录。</li>\n<li>父目录的父目录下的node_modules目录。 </li>\n<li>沿路径向上逐级递归，直到根目录下的node_modules目录。</li>\n</ul>\n<h3 id=\"文件定位\"><a href=\"#文件定位\" class=\"headerlink\" title=\"文件定位\"></a>文件定位</h3><ul>\n<li>扩展名<br>require()在分析标识符的过程中，会出现标识符中不包含文件扩展名的情况。CommonJS模块规范也允许在标识符中不包含文件扩展名，这种情况下，Node会按.js、.json、.node的次序补 足扩展名，依次尝试。</li>\n<li>目录分析和包<br>在分析标识符的过程中，require()通过分析文件扩展名之后，可能没有查找到对应文件，但<br>却得到一个目录，这在引入自定义模块和逐个模块路径进行查找时经常会出现，此时Node会将目 录当做一个包来处理。<br>在这个过程中，Node对CommonJS包规范进行了一定程度的支持。首先，Node在当前目录下 查找package.json(CommonJS包规范定义的包描述文件)，通过JSON.parse()解析出包描述对象， 从中取出main属性指定的文件名进行定位。如果文件名缺少扩展名，将会进入扩展名分析的步骤。<br>而如果main属性指定的文件名错误，或者压根没有package.json文件，Node会将index当做默 认文件名，然后依次查找index.js、index.json、index.node。</li>\n</ul>\n<h3 id=\"模块编译\"><a href=\"#模块编译\" class=\"headerlink\" title=\"模块编译\"></a>模块编译</h3><p>在Node中每个文件模块都是一个对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Module</span>(<span class=\"params\">id, parent</span>) </span>&#123; </span><br><span class=\"line\">  <span class=\"keyword\">this</span>.id = id;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.exports = &#123;&#125;; </span><br><span class=\"line\">  <span class=\"keyword\">this</span>.parent = parent;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (parent &amp;&amp; parent.children) &#123; </span><br><span class=\"line\">    parent.children.push(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.filename = <span class=\"literal\">null</span>; </span><br><span class=\"line\">  <span class=\"keyword\">this</span>.loaded = <span class=\"literal\">false</span>; </span><br><span class=\"line\">  <span class=\"keyword\">this</span>.children = [];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>编译和执行是引入文件模块的最后一个阶段。定位到具体的文件后，Node会新建一个模块对 象，然后根据路径载入并编译。对于不同的文件扩展名，其载入方法也有所不同，具体如下所示。</p>\n<ul>\n<li>.js文件。通过fs模块同步读取文件后编译执行。</li>\n<li>.node文件。这是用C/C++编写的扩展文件，通过dlopen()方法加载最后编译生成的文件。  .json文件。通过fs模块同步读取文件后，用JSON.parse()解析返回结果。</li>\n<li>其余扩展名文件。它们都被当做.js文件载入<br>每一个编译成功的模块都会将其文件路径作为索引缓存在Module._cache对象上，以提高二次引入的性能。</li>\n</ul>\n<h4 id=\"JavaScript模块的编译\"><a href=\"#JavaScript模块的编译\" class=\"headerlink\" title=\"JavaScript模块的编译\"></a>JavaScript模块的编译</h4><p>回到CommonJS模块规范，我们知道每个模块文件中存在着require、exports、module这3个<br>变量，但是它们在模块文件中并没有定义，那么从何而来呢?甚至在Node的API文档中，我们知 道每个模块中还有<strong>filename、</strong>dirname这两个变量的存在，它们又是从何而来的呢?如果我们 把直接定义模块的过程放诸在浏览器端，会存在污染全局变量的情况。<br>事实上，在编译的过程中，Node对获取的JavaScript文件内容进行了头尾包装。在头部添加 了(function (exports, require, module, __filename, __dirname) {\\n，在尾部添加了\\n});。 一个正常的JavaScript文件会被包装成如下的样子:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">exports, require, module, __filename, __dirname</span>) </span>&#123; </span><br><span class=\"line\">  <span class=\"keyword\">var</span> math = <span class=\"built_in\">require</span>(<span class=\"string\">'math'</span>);</span><br><span class=\"line\">  exports.area = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">radius</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.PI * radius * radius; </span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"> &#125;);</span><br></pre></td></tr></table></figure>\n\n<p>这样每个模块文件之间都进行了作用域隔离。包装之后的代码会通过vm原生模块的<br>runInThisContext()方法执行(类似eval，只是具有明确上下文，不污染全局)，返回一个具体的 function对象。最后，将当前模块对象的exports属性、require()方法、module(模块对象自身)， 以及在文件定位中得到的完整文件路径和文件目录作为参数传递给这个function()执行。<br>这就是这些变量并没有定义在每个模块文件中却存在的原因。在执行之后，模块的exports 属性被返回给了调用方。exports属性上的任何方法和属性都可以被外部调用到，但是模块中的 其余变量或属性则不可直接被调用。</p>\n<p>此外，许多初学者都曾经纠结过为何存在exports的情况下，还存在module.exports。理想情<br>况下，只要赋值给exports即可:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">exports = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">// My Class</span></span><br></pre></td></tr></table></figure>\n\n<p>}; 但是通常都会得到一个失败的结果。其原因在于，exports对象是通过形参的方式传入的，<br>直接赋值形参会改变形参的引用，但并不能改变作用域外的值。测试代码如下:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> change = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">a</span>) </span>&#123; a = <span class=\"number\">100</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a); <span class=\"comment\">// =&gt; 100</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\">change(a); <span class=\"built_in\">console</span>.log(a); <span class=\"comment\">// =&gt; 10</span></span><br></pre></td></tr></table></figure>\n\n<p>如果要达到require引入一个类的效果，请赋值给module.exports对象。这个迂回的方案不改 变形参的引用。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"CommonJS-模块规范\"><a href=\"#CommonJS-模块规范\" class=\"headerlink\" title=\"CommonJS 模块规范\"></a>CommonJS 模块规范</h2><p>主要分为模块引用、模块定义和模块标识3个部分。</p>\n<h3 id=\"模块引用\"><a href=\"#模块引用\" class=\"headerlink\" title=\"模块引用\"></a>模块引用</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> foo = <span class=\"built_in\">require</span>(<span class=\"string\">'foo'</span>)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"模块定义\"><a href=\"#模块定义\" class=\"headerlink\" title=\"模块定义\"></a>模块定义</h3><p>使用require进行引入，上下文提供了exports对象用于导出当前模块的方法或者变量，并且它是唯一的出口。在模块中还存在一个module对象，代表模块自身。在Node中一个文件就是一个模块，将方法挂载到exports对象上作为属性即可定义导出的方式。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// foo.js</span></span><br><span class=\"line\">exports.sum = <span class=\"function\">(<span class=\"params\">a,b</span>) =&gt;</span> a+b;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"模块标识\"><a href=\"#模块标识\" class=\"headerlink\" title=\"模块标识\"></a>模块标识</h3><p>模块标记就是传递给require()方法的参数，其实就是文件模块的路径。</p>\n<h2 id=\"Node的模块实现\"><a href=\"#Node的模块实现\" class=\"headerlink\" title=\"Node的模块实现\"></a>Node的模块实现</h2><p>在Node中，模块分为两类:一类是Node提供的模块，称为核心模块;另一类是用户编写的，称为文件模块。</p>\n<ul>\n<li>核心模块在node源代码的编译过程中，编译进了二进制执行文件中。在NOde进程启动时，核心模块就直接被加载到内存中。</li>\n<li>文件模块则是在 <code>运行时动态加载</code>，需要完整的路径分析、文件定位、编译执行过程，速度比核心模块慢。<br>注：Node对引用过的模块多会进行缓存，缓存的是编译和执行后的对象。</li>\n</ul>\n<p>在Node中引入模块，需要经历下面3个步骤</p>\n<ol>\n<li>路径分析</li>\n<li>文件定位</li>\n<li>编译执行</li>\n</ol>\n<h3 id=\"路径分析\"><a href=\"#路径分析\" class=\"headerlink\" title=\"路径分析\"></a>路径分析</h3><p>require接受一个模块标识作为参数，基于这个参数进行模块查找。<br>核心模块和路径形式的引用不细作说明。<br>这里说下 <code>自定义模块</code> 分析过程,自定义模块指的是既非核心模块，也不是路径形式的标识符。<br>模块路径是Node在定位未见时的查找策略，具体表现为一个路径组成的数组。路径的生成规则大概如下：</p>\n<ul>\n<li>当前文件目录下的node_modules目录。</li>\n<li>父目录下的node_modules目录。</li>\n<li>父目录的父目录下的node_modules目录。 </li>\n<li>沿路径向上逐级递归，直到根目录下的node_modules目录。</li>\n</ul>\n<h3 id=\"文件定位\"><a href=\"#文件定位\" class=\"headerlink\" title=\"文件定位\"></a>文件定位</h3><ul>\n<li>扩展名<br>require()在分析标识符的过程中，会出现标识符中不包含文件扩展名的情况。CommonJS模块规范也允许在标识符中不包含文件扩展名，这种情况下，Node会按.js、.json、.node的次序补 足扩展名，依次尝试。</li>\n<li>目录分析和包<br>在分析标识符的过程中，require()通过分析文件扩展名之后，可能没有查找到对应文件，但<br>却得到一个目录，这在引入自定义模块和逐个模块路径进行查找时经常会出现，此时Node会将目 录当做一个包来处理。<br>在这个过程中，Node对CommonJS包规范进行了一定程度的支持。首先，Node在当前目录下 查找package.json(CommonJS包规范定义的包描述文件)，通过JSON.parse()解析出包描述对象， 从中取出main属性指定的文件名进行定位。如果文件名缺少扩展名，将会进入扩展名分析的步骤。<br>而如果main属性指定的文件名错误，或者压根没有package.json文件，Node会将index当做默 认文件名，然后依次查找index.js、index.json、index.node。</li>\n</ul>\n<h3 id=\"模块编译\"><a href=\"#模块编译\" class=\"headerlink\" title=\"模块编译\"></a>模块编译</h3><p>在Node中每个文件模块都是一个对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Module</span>(<span class=\"params\">id, parent</span>) </span>&#123; </span><br><span class=\"line\">  <span class=\"keyword\">this</span>.id = id;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.exports = &#123;&#125;; </span><br><span class=\"line\">  <span class=\"keyword\">this</span>.parent = parent;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (parent &amp;&amp; parent.children) &#123; </span><br><span class=\"line\">    parent.children.push(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.filename = <span class=\"literal\">null</span>; </span><br><span class=\"line\">  <span class=\"keyword\">this</span>.loaded = <span class=\"literal\">false</span>; </span><br><span class=\"line\">  <span class=\"keyword\">this</span>.children = [];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>编译和执行是引入文件模块的最后一个阶段。定位到具体的文件后，Node会新建一个模块对 象，然后根据路径载入并编译。对于不同的文件扩展名，其载入方法也有所不同，具体如下所示。</p>\n<ul>\n<li>.js文件。通过fs模块同步读取文件后编译执行。</li>\n<li>.node文件。这是用C/C++编写的扩展文件，通过dlopen()方法加载最后编译生成的文件。  .json文件。通过fs模块同步读取文件后，用JSON.parse()解析返回结果。</li>\n<li>其余扩展名文件。它们都被当做.js文件载入<br>每一个编译成功的模块都会将其文件路径作为索引缓存在Module._cache对象上，以提高二次引入的性能。</li>\n</ul>\n<h4 id=\"JavaScript模块的编译\"><a href=\"#JavaScript模块的编译\" class=\"headerlink\" title=\"JavaScript模块的编译\"></a>JavaScript模块的编译</h4><p>回到CommonJS模块规范，我们知道每个模块文件中存在着require、exports、module这3个<br>变量，但是它们在模块文件中并没有定义，那么从何而来呢?甚至在Node的API文档中，我们知 道每个模块中还有<strong>filename、</strong>dirname这两个变量的存在，它们又是从何而来的呢?如果我们 把直接定义模块的过程放诸在浏览器端，会存在污染全局变量的情况。<br>事实上，在编译的过程中，Node对获取的JavaScript文件内容进行了头尾包装。在头部添加 了(function (exports, require, module, __filename, __dirname) {\\n，在尾部添加了\\n});。 一个正常的JavaScript文件会被包装成如下的样子:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">exports, require, module, __filename, __dirname</span>) </span>&#123; </span><br><span class=\"line\">  <span class=\"keyword\">var</span> math = <span class=\"built_in\">require</span>(<span class=\"string\">'math'</span>);</span><br><span class=\"line\">  exports.area = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">radius</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.PI * radius * radius; </span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"> &#125;);</span><br></pre></td></tr></table></figure>\n\n<p>这样每个模块文件之间都进行了作用域隔离。包装之后的代码会通过vm原生模块的<br>runInThisContext()方法执行(类似eval，只是具有明确上下文，不污染全局)，返回一个具体的 function对象。最后，将当前模块对象的exports属性、require()方法、module(模块对象自身)， 以及在文件定位中得到的完整文件路径和文件目录作为参数传递给这个function()执行。<br>这就是这些变量并没有定义在每个模块文件中却存在的原因。在执行之后，模块的exports 属性被返回给了调用方。exports属性上的任何方法和属性都可以被外部调用到，但是模块中的 其余变量或属性则不可直接被调用。</p>\n<p>此外，许多初学者都曾经纠结过为何存在exports的情况下，还存在module.exports。理想情<br>况下，只要赋值给exports即可:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">exports = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">// My Class</span></span><br></pre></td></tr></table></figure>\n\n<p>}; 但是通常都会得到一个失败的结果。其原因在于，exports对象是通过形参的方式传入的，<br>直接赋值形参会改变形参的引用，但并不能改变作用域外的值。测试代码如下:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> change = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">a</span>) </span>&#123; a = <span class=\"number\">100</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a); <span class=\"comment\">// =&gt; 100</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\">change(a); <span class=\"built_in\">console</span>.log(a); <span class=\"comment\">// =&gt; 10</span></span><br></pre></td></tr></table></figure>\n\n<p>如果要达到require引入一个类的效果，请赋值给module.exports对象。这个迂回的方案不改 变形参的引用。</p>\n"},{"title":"HHKB键盘","date":"2019-09-10T09:15:39.000Z","_content":"\n> 美国西部的牛仔们，会将死去的马儿留在原地，但是仍然会扛着马鞍长途跋涉，穿越一望无垠的沙漠。因为马儿是消耗品，而马鞍却是与人体融合在一起的“知己”。我们要有这样的观念：现在，电脑是消耗品，键盘却是传递情感，陪伴我们一生的“挚友”。\n\n我表示你说的有道理，开箱颜值还算可以，但我表示肉疼，还不是很习惯。。。\n![HHKB](/../images/HHKB.jpeg)\n\n\n","source":"_posts/HHKB.md","raw":"---\ntitle: HHKB键盘\ndate: 2019-09-10 17:15:39\ncategories: \n- daily\ntags:\n- HHKB\n- keyboard\n---\n\n> 美国西部的牛仔们，会将死去的马儿留在原地，但是仍然会扛着马鞍长途跋涉，穿越一望无垠的沙漠。因为马儿是消耗品，而马鞍却是与人体融合在一起的“知己”。我们要有这样的观念：现在，电脑是消耗品，键盘却是传递情感，陪伴我们一生的“挚友”。\n\n我表示你说的有道理，开箱颜值还算可以，但我表示肉疼，还不是很习惯。。。\n![HHKB](/../images/HHKB.jpeg)\n\n\n","slug":"HHKB","published":1,"updated":"2019-09-10T10:38:52.632Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0wfvhpz0005uhoxl2oa99tu","content":"<blockquote>\n<p>美国西部的牛仔们，会将死去的马儿留在原地，但是仍然会扛着马鞍长途跋涉，穿越一望无垠的沙漠。因为马儿是消耗品，而马鞍却是与人体融合在一起的“知己”。我们要有这样的观念：现在，电脑是消耗品，键盘却是传递情感，陪伴我们一生的“挚友”。</p>\n</blockquote>\n<p>我表示你说的有道理，开箱颜值还算可以，但我表示肉疼，还不是很习惯。。。<br><img src=\"/../images/HHKB.jpeg\" alt=\"HHKB\"></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>美国西部的牛仔们，会将死去的马儿留在原地，但是仍然会扛着马鞍长途跋涉，穿越一望无垠的沙漠。因为马儿是消耗品，而马鞍却是与人体融合在一起的“知己”。我们要有这样的观念：现在，电脑是消耗品，键盘却是传递情感，陪伴我们一生的“挚友”。</p>\n</blockquote>\n<p>我表示你说的有道理，开箱颜值还算可以，但我表示肉疼，还不是很习惯。。。<br><img src=\"/../images/HHKB.jpeg\" alt=\"HHKB\"></p>\n"},{"title":"程序员夫妇的周末","date":"2019-09-01T02:40:28.000Z","_content":"\n![weekend](/images/weekend.jpeg)\n\nhave a nice day~","source":"_posts/weekend.md","raw":"---\ntitle: 程序员夫妇的周末\ndate: 2019-09-01 10:40:28\ncategories: \n- daily\ntags:\n- 日常\n- 白话\n---\n\n![weekend](/images/weekend.jpeg)\n\nhave a nice day~","slug":"weekend","published":1,"updated":"2019-09-02T01:37:27.401Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0wfvhq00006uhoxjhr6uleb","content":"<p><img src=\"/images/weekend.jpeg\" alt=\"weekend\"></p>\n<p>have a nice day~</p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"/images/weekend.jpeg\" alt=\"weekend\"></p>\n<p>have a nice day~</p>\n"},{"title":"关于这个网站","date":"2019-08-30T07:53:09.000Z","_content":"\n## WHAT\n个人生活记录网站。(希望能通过备案)\n希望把所有有意义的东西都记录下来，包括但不限于技术范围。\n个人使用，能帮助到人就更好了。\n\n\n## WHY\n上学时候的 [Blog](http://huguobo.github.io) 用的是 [jekyll](https://jekyllrb.com/)+ [GithubPages](https://pages.github.com/)。\n好久没有更新和维护了, 不是很熟悉 ruby，也不想继续浪费 github 的资源。\n加上发觉自己工作后的积累和沉淀明显不够，开始着手使用基于 [node](https://nodejs.org) 的 [hexo](https://hexo.io/zh-cn/) 和自己的云服务器搭建了这个网站。\n\n## HOW\n富强、民主、文明、和谐、自由、平等、公正、法治、爱国、敬业、诚信、友善。\n合法、合规、合理。\nLOVE AND PEACE。","source":"_posts/新网站.md","raw":"---\ntitle: 关于这个网站\ndate: 2019-08-30 15:53:09\ncategories: \n- daily\ntags: \n- 白话\n---\n\n## WHAT\n个人生活记录网站。(希望能通过备案)\n希望把所有有意义的东西都记录下来，包括但不限于技术范围。\n个人使用，能帮助到人就更好了。\n\n\n## WHY\n上学时候的 [Blog](http://huguobo.github.io) 用的是 [jekyll](https://jekyllrb.com/)+ [GithubPages](https://pages.github.com/)。\n好久没有更新和维护了, 不是很熟悉 ruby，也不想继续浪费 github 的资源。\n加上发觉自己工作后的积累和沉淀明显不够，开始着手使用基于 [node](https://nodejs.org) 的 [hexo](https://hexo.io/zh-cn/) 和自己的云服务器搭建了这个网站。\n\n## HOW\n富强、民主、文明、和谐、自由、平等、公正、法治、爱国、敬业、诚信、友善。\n合法、合规、合理。\nLOVE AND PEACE。","slug":"新网站","published":1,"updated":"2019-09-02T01:37:30.425Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0wfvhqz000yuhoxayzruv6f","content":"<h2 id=\"WHAT\"><a href=\"#WHAT\" class=\"headerlink\" title=\"WHAT\"></a>WHAT</h2><p>个人生活记录网站。(希望能通过备案)<br>希望把所有有意义的东西都记录下来，包括但不限于技术范围。<br>个人使用，能帮助到人就更好了。</p>\n<h2 id=\"WHY\"><a href=\"#WHY\" class=\"headerlink\" title=\"WHY\"></a>WHY</h2><p>上学时候的 <a href=\"http://huguobo.github.io\" target=\"_blank\" rel=\"noopener\">Blog</a> 用的是 <a href=\"https://jekyllrb.com/\" target=\"_blank\" rel=\"noopener\">jekyll</a>+ <a href=\"https://pages.github.com/\" target=\"_blank\" rel=\"noopener\">GithubPages</a>。<br>好久没有更新和维护了, 不是很熟悉 ruby，也不想继续浪费 github 的资源。<br>加上发觉自己工作后的积累和沉淀明显不够，开始着手使用基于 <a href=\"https://nodejs.org\" target=\"_blank\" rel=\"noopener\">node</a> 的 <a href=\"https://hexo.io/zh-cn/\" target=\"_blank\" rel=\"noopener\">hexo</a> 和自己的云服务器搭建了这个网站。</p>\n<h2 id=\"HOW\"><a href=\"#HOW\" class=\"headerlink\" title=\"HOW\"></a>HOW</h2><p>富强、民主、文明、和谐、自由、平等、公正、法治、爱国、敬业、诚信、友善。<br>合法、合规、合理。<br>LOVE AND PEACE。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"WHAT\"><a href=\"#WHAT\" class=\"headerlink\" title=\"WHAT\"></a>WHAT</h2><p>个人生活记录网站。(希望能通过备案)<br>希望把所有有意义的东西都记录下来，包括但不限于技术范围。<br>个人使用，能帮助到人就更好了。</p>\n<h2 id=\"WHY\"><a href=\"#WHY\" class=\"headerlink\" title=\"WHY\"></a>WHY</h2><p>上学时候的 <a href=\"http://huguobo.github.io\" target=\"_blank\" rel=\"noopener\">Blog</a> 用的是 <a href=\"https://jekyllrb.com/\" target=\"_blank\" rel=\"noopener\">jekyll</a>+ <a href=\"https://pages.github.com/\" target=\"_blank\" rel=\"noopener\">GithubPages</a>。<br>好久没有更新和维护了, 不是很熟悉 ruby，也不想继续浪费 github 的资源。<br>加上发觉自己工作后的积累和沉淀明显不够，开始着手使用基于 <a href=\"https://nodejs.org\" target=\"_blank\" rel=\"noopener\">node</a> 的 <a href=\"https://hexo.io/zh-cn/\" target=\"_blank\" rel=\"noopener\">hexo</a> 和自己的云服务器搭建了这个网站。</p>\n<h2 id=\"HOW\"><a href=\"#HOW\" class=\"headerlink\" title=\"HOW\"></a>HOW</h2><p>富强、民主、文明、和谐、自由、平等、公正、法治、爱国、敬业、诚信、友善。<br>合法、合规、合理。<br>LOVE AND PEACE。</p>\n"},{"title":"WEB开发中涉及的各种宽高","date":"2019-09-09T05:56:05.000Z","_content":"\n> web开发中经常涉及各种宽高和坐标的概念，相关的属性和概念较多，每次都得查一遍，故作此整理。\n\nJS中Document对象的宽高有3个种类：`client`, `offset` , `scroll` \n\n## Client\n\n### clientHeight 和 clientWidth\n该属性指的是元素可视部分的宽度和高度，即`padding+content`， 不包括滚动轴等。\n![](/../images/clientHeight.png)\n\n### clientTop 和 clientLeft\n该属性是读取元素 `border` 的宽度和高度的。\n\n- clientTop = border-top 的 broder-width\n- clientLeft = border-left 的 border-width\n\n\n## Offset\n\n### offsetHeight 和 offsetWidth\n这一对属性指的是元素的 `border+padding+content` 的宽度和高度。包括padding、border、水平滚动条，但不包括margin的元素的高度。\n该属性和其内部的内容是否超出元素大小无关，只和本来设置的border以及width和height有关。\n![](/../images/offsetHeight.png)\n\n### offsetTop 和 offsetLeft\n这个需要先了解下 `offsetParent`：第一个 position 不为  static 的 父元素，一层层向上，知道 body。\n当前元素顶部距离最近父元素`offsetParent`顶部的距离,和有没有滚动条没有关系。单位px，只读元素。 \n同理left\n\n## Scroll\n\n### scollHeight 和 scrollWidth\n因为子元素比父元素高，父元素不想被子元素撑的一样高就显示出了滚动条，在滚动的过程中本元素有部分被隐藏了，scrollHeight 代表包括当前不可见部分的元素的高度。而可见部分的高度其实就是clientHeight，也就是scrollHeight>=clientHeight恒成立。在有滚动条时讨论scrollHeight才有意义，在没有滚动条时scrollHeight==clientHeight恒成立。单位px，只读元素。 \n![](/../images/scollHeight.png)\n\n### scrollTop 和 scrollLeft\n代表在有滚动条时，滚动条向下滚动的距离也就是元素顶部被遮住部分的高度。在没有滚动条时scrollTop==0恒成立，单位px。\n![](/../images/scrollTop.png)\n\n","source":"_posts/JsWidthAndHeight.md","raw":"---\ntitle: WEB开发中涉及的各种宽高\ndate: 2019-09-09 13:56:05\ncategories: \n- JavaScript\ntags:\n- scorllTop\n- height\n- width\n---\n\n> web开发中经常涉及各种宽高和坐标的概念，相关的属性和概念较多，每次都得查一遍，故作此整理。\n\nJS中Document对象的宽高有3个种类：`client`, `offset` , `scroll` \n\n## Client\n\n### clientHeight 和 clientWidth\n该属性指的是元素可视部分的宽度和高度，即`padding+content`， 不包括滚动轴等。\n![](/../images/clientHeight.png)\n\n### clientTop 和 clientLeft\n该属性是读取元素 `border` 的宽度和高度的。\n\n- clientTop = border-top 的 broder-width\n- clientLeft = border-left 的 border-width\n\n\n## Offset\n\n### offsetHeight 和 offsetWidth\n这一对属性指的是元素的 `border+padding+content` 的宽度和高度。包括padding、border、水平滚动条，但不包括margin的元素的高度。\n该属性和其内部的内容是否超出元素大小无关，只和本来设置的border以及width和height有关。\n![](/../images/offsetHeight.png)\n\n### offsetTop 和 offsetLeft\n这个需要先了解下 `offsetParent`：第一个 position 不为  static 的 父元素，一层层向上，知道 body。\n当前元素顶部距离最近父元素`offsetParent`顶部的距离,和有没有滚动条没有关系。单位px，只读元素。 \n同理left\n\n## Scroll\n\n### scollHeight 和 scrollWidth\n因为子元素比父元素高，父元素不想被子元素撑的一样高就显示出了滚动条，在滚动的过程中本元素有部分被隐藏了，scrollHeight 代表包括当前不可见部分的元素的高度。而可见部分的高度其实就是clientHeight，也就是scrollHeight>=clientHeight恒成立。在有滚动条时讨论scrollHeight才有意义，在没有滚动条时scrollHeight==clientHeight恒成立。单位px，只读元素。 \n![](/../images/scollHeight.png)\n\n### scrollTop 和 scrollLeft\n代表在有滚动条时，滚动条向下滚动的距离也就是元素顶部被遮住部分的高度。在没有滚动条时scrollTop==0恒成立，单位px。\n![](/../images/scrollTop.png)\n\n","slug":"JsWidthAndHeight","published":1,"updated":"2019-09-09T06:57:15.756Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0wfvhr10010uhoxr0jffggo","content":"<blockquote>\n<p>web开发中经常涉及各种宽高和坐标的概念，相关的属性和概念较多，每次都得查一遍，故作此整理。</p>\n</blockquote>\n<p>JS中Document对象的宽高有3个种类：<code>client</code>, <code>offset</code> , <code>scroll</code> </p>\n<h2 id=\"Client\"><a href=\"#Client\" class=\"headerlink\" title=\"Client\"></a>Client</h2><h3 id=\"clientHeight-和-clientWidth\"><a href=\"#clientHeight-和-clientWidth\" class=\"headerlink\" title=\"clientHeight 和 clientWidth\"></a>clientHeight 和 clientWidth</h3><p>该属性指的是元素可视部分的宽度和高度，即<code>padding+content</code>， 不包括滚动轴等。<br><img src=\"/../images/clientHeight.png\" alt></p>\n<h3 id=\"clientTop-和-clientLeft\"><a href=\"#clientTop-和-clientLeft\" class=\"headerlink\" title=\"clientTop 和 clientLeft\"></a>clientTop 和 clientLeft</h3><p>该属性是读取元素 <code>border</code> 的宽度和高度的。</p>\n<ul>\n<li>clientTop = border-top 的 broder-width</li>\n<li>clientLeft = border-left 的 border-width</li>\n</ul>\n<h2 id=\"Offset\"><a href=\"#Offset\" class=\"headerlink\" title=\"Offset\"></a>Offset</h2><h3 id=\"offsetHeight-和-offsetWidth\"><a href=\"#offsetHeight-和-offsetWidth\" class=\"headerlink\" title=\"offsetHeight 和 offsetWidth\"></a>offsetHeight 和 offsetWidth</h3><p>这一对属性指的是元素的 <code>border+padding+content</code> 的宽度和高度。包括padding、border、水平滚动条，但不包括margin的元素的高度。<br>该属性和其内部的内容是否超出元素大小无关，只和本来设置的border以及width和height有关。<br><img src=\"/../images/offsetHeight.png\" alt></p>\n<h3 id=\"offsetTop-和-offsetLeft\"><a href=\"#offsetTop-和-offsetLeft\" class=\"headerlink\" title=\"offsetTop 和 offsetLeft\"></a>offsetTop 和 offsetLeft</h3><p>这个需要先了解下 <code>offsetParent</code>：第一个 position 不为  static 的 父元素，一层层向上，知道 body。<br>当前元素顶部距离最近父元素<code>offsetParent</code>顶部的距离,和有没有滚动条没有关系。单位px，只读元素。<br>同理left</p>\n<h2 id=\"Scroll\"><a href=\"#Scroll\" class=\"headerlink\" title=\"Scroll\"></a>Scroll</h2><h3 id=\"scollHeight-和-scrollWidth\"><a href=\"#scollHeight-和-scrollWidth\" class=\"headerlink\" title=\"scollHeight 和 scrollWidth\"></a>scollHeight 和 scrollWidth</h3><p>因为子元素比父元素高，父元素不想被子元素撑的一样高就显示出了滚动条，在滚动的过程中本元素有部分被隐藏了，scrollHeight 代表包括当前不可见部分的元素的高度。而可见部分的高度其实就是clientHeight，也就是scrollHeight&gt;=clientHeight恒成立。在有滚动条时讨论scrollHeight才有意义，在没有滚动条时scrollHeight==clientHeight恒成立。单位px，只读元素。<br><img src=\"/../images/scollHeight.png\" alt></p>\n<h3 id=\"scrollTop-和-scrollLeft\"><a href=\"#scrollTop-和-scrollLeft\" class=\"headerlink\" title=\"scrollTop 和 scrollLeft\"></a>scrollTop 和 scrollLeft</h3><p>代表在有滚动条时，滚动条向下滚动的距离也就是元素顶部被遮住部分的高度。在没有滚动条时scrollTop==0恒成立，单位px。<br><img src=\"/../images/scrollTop.png\" alt></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>web开发中经常涉及各种宽高和坐标的概念，相关的属性和概念较多，每次都得查一遍，故作此整理。</p>\n</blockquote>\n<p>JS中Document对象的宽高有3个种类：<code>client</code>, <code>offset</code> , <code>scroll</code> </p>\n<h2 id=\"Client\"><a href=\"#Client\" class=\"headerlink\" title=\"Client\"></a>Client</h2><h3 id=\"clientHeight-和-clientWidth\"><a href=\"#clientHeight-和-clientWidth\" class=\"headerlink\" title=\"clientHeight 和 clientWidth\"></a>clientHeight 和 clientWidth</h3><p>该属性指的是元素可视部分的宽度和高度，即<code>padding+content</code>， 不包括滚动轴等。<br><img src=\"/../images/clientHeight.png\" alt></p>\n<h3 id=\"clientTop-和-clientLeft\"><a href=\"#clientTop-和-clientLeft\" class=\"headerlink\" title=\"clientTop 和 clientLeft\"></a>clientTop 和 clientLeft</h3><p>该属性是读取元素 <code>border</code> 的宽度和高度的。</p>\n<ul>\n<li>clientTop = border-top 的 broder-width</li>\n<li>clientLeft = border-left 的 border-width</li>\n</ul>\n<h2 id=\"Offset\"><a href=\"#Offset\" class=\"headerlink\" title=\"Offset\"></a>Offset</h2><h3 id=\"offsetHeight-和-offsetWidth\"><a href=\"#offsetHeight-和-offsetWidth\" class=\"headerlink\" title=\"offsetHeight 和 offsetWidth\"></a>offsetHeight 和 offsetWidth</h3><p>这一对属性指的是元素的 <code>border+padding+content</code> 的宽度和高度。包括padding、border、水平滚动条，但不包括margin的元素的高度。<br>该属性和其内部的内容是否超出元素大小无关，只和本来设置的border以及width和height有关。<br><img src=\"/../images/offsetHeight.png\" alt></p>\n<h3 id=\"offsetTop-和-offsetLeft\"><a href=\"#offsetTop-和-offsetLeft\" class=\"headerlink\" title=\"offsetTop 和 offsetLeft\"></a>offsetTop 和 offsetLeft</h3><p>这个需要先了解下 <code>offsetParent</code>：第一个 position 不为  static 的 父元素，一层层向上，知道 body。<br>当前元素顶部距离最近父元素<code>offsetParent</code>顶部的距离,和有没有滚动条没有关系。单位px，只读元素。<br>同理left</p>\n<h2 id=\"Scroll\"><a href=\"#Scroll\" class=\"headerlink\" title=\"Scroll\"></a>Scroll</h2><h3 id=\"scollHeight-和-scrollWidth\"><a href=\"#scollHeight-和-scrollWidth\" class=\"headerlink\" title=\"scollHeight 和 scrollWidth\"></a>scollHeight 和 scrollWidth</h3><p>因为子元素比父元素高，父元素不想被子元素撑的一样高就显示出了滚动条，在滚动的过程中本元素有部分被隐藏了，scrollHeight 代表包括当前不可见部分的元素的高度。而可见部分的高度其实就是clientHeight，也就是scrollHeight&gt;=clientHeight恒成立。在有滚动条时讨论scrollHeight才有意义，在没有滚动条时scrollHeight==clientHeight恒成立。单位px，只读元素。<br><img src=\"/../images/scollHeight.png\" alt></p>\n<h3 id=\"scrollTop-和-scrollLeft\"><a href=\"#scrollTop-和-scrollLeft\" class=\"headerlink\" title=\"scrollTop 和 scrollLeft\"></a>scrollTop 和 scrollLeft</h3><p>代表在有滚动条时，滚动条向下滚动的距离也就是元素顶部被遮住部分的高度。在没有滚动条时scrollTop==0恒成立，单位px。<br><img src=\"/../images/scrollTop.png\" alt></p>\n"},{"title":"SSH、SSL 和 HTTPS","date":"2019-09-03T02:56:46.000Z","_content":"\n> 一直对 SSH 、SSL 以及 HTTPS 和它们互相之间的关系都云里雾里的，下面参考网上的文章和自己的理解梳理一下，晕了就再回来看一下，总会记住的。\n\n## 加密算法\n首先先说下加密算法，可以分为两大类，`对称加密` 和 `非对称加密`。\n### 对称加密\n通信双方的数据都是用同一套密钥来进行加密和解密。\n在1976年以前，所有的加密都采用对称加密，这种加密方式最大的问题就是如何管理秘钥？既要保证秘钥不泄露，同时还要保证秘钥的共享性。\n### 非对称加密\n1976年有两位数学家提出的一个新的加密概念：\n1. A生成一对两把密钥（公钥和私钥）。\n2. B获取A生成的公钥，然后用公钥对信息加密。\n3. A收到B的加密信息后，用自己的私钥解密。\n\n非对称加密引入了公钥和私钥的概念。公钥加密，私钥解密。公钥是面向所有使用者公开的。\n目前计算机领域使用最广泛的非对称加密算法是[RSA](https://zh.wikipedia.org/wiki/RSA%E5%8A%A0%E5%AF%86%E6%BC%94%E7%AE%97%E6%B3%95)。\n\n对称加密看起来很强大，但是也有缺点：\n\n- 加密更耗时：算法更复杂。\n- 容易受到中间人攻击:即如果有C冒充A利用A的公钥给B发消息，B的所有消息对C其实就是透明的了。\n  \n针对中间人攻击，一般就采用非对称加密+摘要算法+数字签名的机制来确保传输安全。\n### 摘要算法（hash算法）\nHash 算法的特点是单向不可逆。利用这个特性，可以通过hash对目前信息加密生成特定长度且唯一的hash值，该值也不能被逆向破译。因此hash算法进场用在不可还原的密码存储、信息完整性校验等领域。常见的hash算法：MD2，MD4，MD5，SHA等\n\n### 数字签名\n数字签名，是为了保证信息在传输过程中没有被篡改。使用hash算法生成要发送明文的摘要，然后 把明文和摘要都通过私钥加密，加密后的摘要作为`数字签名（digital signature）`跟加密后的内容一起发送给接受者。接受者收到数据信息后，使用公钥分别对内容和信息解密，得到数据和内容摘要，然后用一样的算法对内容生成摘要，比较摘要是否相同来确认信息的完整性。\n\n### 数字证书\n以上的流程还是存在一个问题就是，有人冒充通信人发放公钥。这种场景的出现，我们就需要有个公证人了，告诉我们到底有是真的注册登记过的。这个公证人就是证书中心（certificate authority）简称CA。\n所有想发放公钥的人，都需要去CA为自己的公钥做认证。证书中心会用自己私钥和公钥以及公钥人信息一起进行加密，生成的东西就叫数字证书。以后所有类似的场景，都是统一用CA的公钥解开数字证书，拿到通信用的公钥，然后证明数字签名确实是来自哪里的了。\n\n关于数字签名和数字证书，阮一峰老师的这篇文章讲的特别生动[blog](http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html)\n\n## SSH\nwiki上对SSH的定义:\n>Secure Shell（缩写为SSH），由IETF的网络工作小组（Network Working Group）所制定；SSH为一项创建在应用层和传输层基础上的安全协议，为计算机上的Shell（壳层）提供安全的传输和使用环境。\n>传统的网络服务程序，如rsh、FTP、POP和Telnet其本质上都是不安全的；因为它们在网络上用明文传送数据、用户帐号和用户口令，很容易受到中间人（man-in-the-middle）攻击方式的攻击。就是存在另一个>人或者一台机器冒充真正的服务器接收用户传给服务器的数据，然后再冒充用户把数据传给真正的服务器。\n>而SSH是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用SSH协议可以有效防止远程管理过程中的信息泄露问题。通过SSH可以对所有传输的数据进行加密，也能够防止DNS欺骗和IP欺骗。\n>SSH之另一项优点为其传输的数据可以是经过压缩的，所以可以加快传输的速度。SSH有很多功能，它既可以代替Telnet，又可以为FTP、POP、甚至为PPP提供一个安全的“通道”。\n\n看了以后显然更晕了，注意一下他是一个`SHELL`, 可以理解为 SSH 服务器之间安全通信的一个协议，既然称之为安全的，想必是通信过程使用了加密手段。\n这时候就用上了我们上一节的知识了，我们现在要在服务器之前就行安全的通信：\n1. A、B之间建立TCP连接\n2. B生成一对公私密钥\n3. B把公钥发送给A\n4. A生成一个用于加密数据的密钥K（既我们想通知给客户端的密钥，之后的数据通信都使用这个密钥加密，这个密钥不可让第三方知道）\n5. A把K用公钥加密发送给B，B解密后，从此A、B之间的通信数据都用K密钥进行加密和解密（转为了安全的对称加密方式）。\n\n这个过程还是会有一样的问题，加入中间有C、D，假冒B发放公钥给A，夹在了A和B之间，不是又不安全了吗。\n为了解决这个问题SSH协议采用由人工判断公钥的fingerprint是否可信的方式：\n```bash\nThe authenticity of host '172.20.7.211 (<no hostip for proxy command>)' can't be established.\nRSA key fingerprint is 23:42:c1:e4:3f:d2:cc:37:1d:89:cb:e7:5d:be:5d:53.\nAre you sure you want to continue connecting (yes/no)? \n```\n输入yes之后才会连接到远程服务器，同时这个信息会存储到用户的.ssh/known_hosts文件中，下次再登录的时候，会检查known_host文件，如果存在相同的公钥信息，就不在提示用户确认了.相当于中间加了一步人工验证，确定下要连接的机器，作为客户端一般也确实是知道自己要连谁的。\n当然这一步也可以手动跳过:\n```bash\nssh -o PubkeyAuthentication=yes  -o stricthostkeychecking=no\n```\n我们都用过`ssh-keygen` 命令，他就是为我们生成一对密钥（公钥+私钥），用于我们所说的非对称加密过程\n```bash\nssh-keygen -t rsa\n#.ssh/\nid_rsa.pub       //公钥   \nid_rsa           //密钥\n```\n将id_rsa.pub的内容写入authorized_keys文件中，表示该机器目前授权的使用该公钥访问\n```bash\ncat id_rsa.pub >> authorized_keys\n```\n这样就将公钥内容追加到authorized_keys中了，然后需要注意配置权限了，否则SSH不会工作：\n- 将.ssh目录的权限为700\n- 将authorized_keys目录的权限为600\n有个 `ssh-copy-id` 工具很好用,一行命令就可以复制公钥到对应服务器下的 authorized_keys。\n```bash\nssh-copy-id -i username@remote-server\n```\n\n一个完整的SSH客户端认证流程\n一般我们能接触到的的认证方式有两种：\n- 密码认证\n- 密钥认证\n\n密码认证很好理解，就是我们在登录远程linux服务器的时候提供用户名和密码。\n\n每次登录都要输入密码很麻烦，且密码如果简单的话可能还会被暴力破解，而且很多自动化场景要求我们实现免密登录服务器。密钥认证提供了一种更安全便捷的认证客户端的方式。这个技术也用到了非对称加密技术，由客户端生成公私密钥对，然后将公钥保存在服务器上。认证的过程大体如下：\n1. 客户端发起一个公钥的认证请求，并发送RSA Key的模数作为标识符。\n2. 服务端检查是否存在请求帐号的公钥（Linux中存储在~/.ssh/authorized_keys文件中），以及其拥有的访问权限。\n3. 服务端使用对应的公钥对一个随机的256位的字符串进行加密，并发送给客户端\n4. 客户端使用私钥对字符串进行解密，并将其结合session id生成一个MD5值发送给服务端。\n5. 服务端采用同样的方式生成MD5值与客户端返回的MD5值进行比较，完成对客户端的认证。\n\n疑点：这个流程确实是一个完整的非对称加密处理的认证过程，但是实际使用中我发现客户端并没有发送自己的公钥，因为我把客户端的公钥删了，或者只复制私钥到一个新的客户端上，最终还是可以登入authorized_keys中配置了对应公钥的服务器。\n- 所以我猜测客户端发送请求后，服务端这边是把authorized_keys中的锁让客户端的钥匙循环匹配的？能打开其中的一把锁就能登录，但是这样key多的话，建立连接就会有效率问题。\n- 另一个猜测，这个发送的RSA_KEY的模数是通过私钥就能产生的，就是说通过私钥有办法直接得到它对应公钥的标志，所以客户端也就用不着专门保存公钥，也不用直接发送的公钥进行认证。\n目前我也不确定为啥客户端没发送自己的公钥，最后也能登录的真正原因。\n\n## SSL\nTLS（Transport Layer Security：它相当于是SSL协议的一个后续版本，他是SSL经过IETF标准化之后的产物。\n上面wiki上也有写，SSH其实是专门为shell设计的一种通信协议，它垮了两个网络层（传输层和应用层）。通俗点讲就是只有SSH客户端，和SSH服务器端之间的通信才能使用这个协议，其他软件服务无法使用它。但是其实我们非常需要一个通用的，建立在应用层之下的一个传输层安全协议，它的目标是建立一种对上层应用协议透明的，不管是HTTP、FTP、还是电子邮件协议或其他任何应用层协议都可以依赖的底层的可安全通信的传输层协议。SSL（Secure Sockets Layer）协议就是在此背景下诞生的。\n\n对于一个通用的协议来说，类似SSH使用printfinger来防止中间人攻击不一样，互联网上所有的客户端和服务器是不可能自己判断对方是不是可信。这个时候就用到了我们所说的 `数字证书` 的概念，在SSL中引入了一个公证机关，就是我们熟知的 `CA`。有了数字证书，浏览器在建立SSL连接之前，并不只是简单获取服务器的公钥，而从服务器获取数字证书。有了信任机制之后，剩下的交互过程还是我们所熟知的非对称加密过程。\n![](http://www.ruanyifeng.com/blogimg/asset/2014/bg2014092007.png)\n[图解SSL/TLS协议-阮一峰](http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html)\n\n## HTTPS\n上面的概念清晰了以后，理解HTTPS就简单了。HTTPS的全程是 Hypertext Transfer Protocol Secure，就是 运行在 SSL/TLS 之上的 HTTP协议。\n做为网站管理员，可能会遇到申请数字证书的任务，理解了上面的概念，申请数字证书就不那么一头雾水了，首先你要为服务器生成一对公司密钥，然后把你网站的信息连同你的公钥一起发送给某个权威的CA，CA会通过某种方式认证申请人是否真的是网站的所有人，比如让你在网站的指定路径上传他指定的特殊蚊子序列。验证通过就会得到证书了。\n\n\n## 参考文献\n- http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html\n- https://zh.wikipedia.org/wiki/RSA加密演算法\n- https://www.jianshu.com/p/5e3f9dfd2cb4\n- https://www.jianshu.com/p/b078282653b3","source":"_posts/sshLogin.md","raw":"---\ntitle: SSH、SSL 和 HTTPS\ndate: 2019-09-03 10:56:46\ncategories: \n- devOps\ntags:\n- SSH\n- SSL\n- Https\n- encrypt\n---\n\n> 一直对 SSH 、SSL 以及 HTTPS 和它们互相之间的关系都云里雾里的，下面参考网上的文章和自己的理解梳理一下，晕了就再回来看一下，总会记住的。\n\n## 加密算法\n首先先说下加密算法，可以分为两大类，`对称加密` 和 `非对称加密`。\n### 对称加密\n通信双方的数据都是用同一套密钥来进行加密和解密。\n在1976年以前，所有的加密都采用对称加密，这种加密方式最大的问题就是如何管理秘钥？既要保证秘钥不泄露，同时还要保证秘钥的共享性。\n### 非对称加密\n1976年有两位数学家提出的一个新的加密概念：\n1. A生成一对两把密钥（公钥和私钥）。\n2. B获取A生成的公钥，然后用公钥对信息加密。\n3. A收到B的加密信息后，用自己的私钥解密。\n\n非对称加密引入了公钥和私钥的概念。公钥加密，私钥解密。公钥是面向所有使用者公开的。\n目前计算机领域使用最广泛的非对称加密算法是[RSA](https://zh.wikipedia.org/wiki/RSA%E5%8A%A0%E5%AF%86%E6%BC%94%E7%AE%97%E6%B3%95)。\n\n对称加密看起来很强大，但是也有缺点：\n\n- 加密更耗时：算法更复杂。\n- 容易受到中间人攻击:即如果有C冒充A利用A的公钥给B发消息，B的所有消息对C其实就是透明的了。\n  \n针对中间人攻击，一般就采用非对称加密+摘要算法+数字签名的机制来确保传输安全。\n### 摘要算法（hash算法）\nHash 算法的特点是单向不可逆。利用这个特性，可以通过hash对目前信息加密生成特定长度且唯一的hash值，该值也不能被逆向破译。因此hash算法进场用在不可还原的密码存储、信息完整性校验等领域。常见的hash算法：MD2，MD4，MD5，SHA等\n\n### 数字签名\n数字签名，是为了保证信息在传输过程中没有被篡改。使用hash算法生成要发送明文的摘要，然后 把明文和摘要都通过私钥加密，加密后的摘要作为`数字签名（digital signature）`跟加密后的内容一起发送给接受者。接受者收到数据信息后，使用公钥分别对内容和信息解密，得到数据和内容摘要，然后用一样的算法对内容生成摘要，比较摘要是否相同来确认信息的完整性。\n\n### 数字证书\n以上的流程还是存在一个问题就是，有人冒充通信人发放公钥。这种场景的出现，我们就需要有个公证人了，告诉我们到底有是真的注册登记过的。这个公证人就是证书中心（certificate authority）简称CA。\n所有想发放公钥的人，都需要去CA为自己的公钥做认证。证书中心会用自己私钥和公钥以及公钥人信息一起进行加密，生成的东西就叫数字证书。以后所有类似的场景，都是统一用CA的公钥解开数字证书，拿到通信用的公钥，然后证明数字签名确实是来自哪里的了。\n\n关于数字签名和数字证书，阮一峰老师的这篇文章讲的特别生动[blog](http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html)\n\n## SSH\nwiki上对SSH的定义:\n>Secure Shell（缩写为SSH），由IETF的网络工作小组（Network Working Group）所制定；SSH为一项创建在应用层和传输层基础上的安全协议，为计算机上的Shell（壳层）提供安全的传输和使用环境。\n>传统的网络服务程序，如rsh、FTP、POP和Telnet其本质上都是不安全的；因为它们在网络上用明文传送数据、用户帐号和用户口令，很容易受到中间人（man-in-the-middle）攻击方式的攻击。就是存在另一个>人或者一台机器冒充真正的服务器接收用户传给服务器的数据，然后再冒充用户把数据传给真正的服务器。\n>而SSH是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用SSH协议可以有效防止远程管理过程中的信息泄露问题。通过SSH可以对所有传输的数据进行加密，也能够防止DNS欺骗和IP欺骗。\n>SSH之另一项优点为其传输的数据可以是经过压缩的，所以可以加快传输的速度。SSH有很多功能，它既可以代替Telnet，又可以为FTP、POP、甚至为PPP提供一个安全的“通道”。\n\n看了以后显然更晕了，注意一下他是一个`SHELL`, 可以理解为 SSH 服务器之间安全通信的一个协议，既然称之为安全的，想必是通信过程使用了加密手段。\n这时候就用上了我们上一节的知识了，我们现在要在服务器之前就行安全的通信：\n1. A、B之间建立TCP连接\n2. B生成一对公私密钥\n3. B把公钥发送给A\n4. A生成一个用于加密数据的密钥K（既我们想通知给客户端的密钥，之后的数据通信都使用这个密钥加密，这个密钥不可让第三方知道）\n5. A把K用公钥加密发送给B，B解密后，从此A、B之间的通信数据都用K密钥进行加密和解密（转为了安全的对称加密方式）。\n\n这个过程还是会有一样的问题，加入中间有C、D，假冒B发放公钥给A，夹在了A和B之间，不是又不安全了吗。\n为了解决这个问题SSH协议采用由人工判断公钥的fingerprint是否可信的方式：\n```bash\nThe authenticity of host '172.20.7.211 (<no hostip for proxy command>)' can't be established.\nRSA key fingerprint is 23:42:c1:e4:3f:d2:cc:37:1d:89:cb:e7:5d:be:5d:53.\nAre you sure you want to continue connecting (yes/no)? \n```\n输入yes之后才会连接到远程服务器，同时这个信息会存储到用户的.ssh/known_hosts文件中，下次再登录的时候，会检查known_host文件，如果存在相同的公钥信息，就不在提示用户确认了.相当于中间加了一步人工验证，确定下要连接的机器，作为客户端一般也确实是知道自己要连谁的。\n当然这一步也可以手动跳过:\n```bash\nssh -o PubkeyAuthentication=yes  -o stricthostkeychecking=no\n```\n我们都用过`ssh-keygen` 命令，他就是为我们生成一对密钥（公钥+私钥），用于我们所说的非对称加密过程\n```bash\nssh-keygen -t rsa\n#.ssh/\nid_rsa.pub       //公钥   \nid_rsa           //密钥\n```\n将id_rsa.pub的内容写入authorized_keys文件中，表示该机器目前授权的使用该公钥访问\n```bash\ncat id_rsa.pub >> authorized_keys\n```\n这样就将公钥内容追加到authorized_keys中了，然后需要注意配置权限了，否则SSH不会工作：\n- 将.ssh目录的权限为700\n- 将authorized_keys目录的权限为600\n有个 `ssh-copy-id` 工具很好用,一行命令就可以复制公钥到对应服务器下的 authorized_keys。\n```bash\nssh-copy-id -i username@remote-server\n```\n\n一个完整的SSH客户端认证流程\n一般我们能接触到的的认证方式有两种：\n- 密码认证\n- 密钥认证\n\n密码认证很好理解，就是我们在登录远程linux服务器的时候提供用户名和密码。\n\n每次登录都要输入密码很麻烦，且密码如果简单的话可能还会被暴力破解，而且很多自动化场景要求我们实现免密登录服务器。密钥认证提供了一种更安全便捷的认证客户端的方式。这个技术也用到了非对称加密技术，由客户端生成公私密钥对，然后将公钥保存在服务器上。认证的过程大体如下：\n1. 客户端发起一个公钥的认证请求，并发送RSA Key的模数作为标识符。\n2. 服务端检查是否存在请求帐号的公钥（Linux中存储在~/.ssh/authorized_keys文件中），以及其拥有的访问权限。\n3. 服务端使用对应的公钥对一个随机的256位的字符串进行加密，并发送给客户端\n4. 客户端使用私钥对字符串进行解密，并将其结合session id生成一个MD5值发送给服务端。\n5. 服务端采用同样的方式生成MD5值与客户端返回的MD5值进行比较，完成对客户端的认证。\n\n疑点：这个流程确实是一个完整的非对称加密处理的认证过程，但是实际使用中我发现客户端并没有发送自己的公钥，因为我把客户端的公钥删了，或者只复制私钥到一个新的客户端上，最终还是可以登入authorized_keys中配置了对应公钥的服务器。\n- 所以我猜测客户端发送请求后，服务端这边是把authorized_keys中的锁让客户端的钥匙循环匹配的？能打开其中的一把锁就能登录，但是这样key多的话，建立连接就会有效率问题。\n- 另一个猜测，这个发送的RSA_KEY的模数是通过私钥就能产生的，就是说通过私钥有办法直接得到它对应公钥的标志，所以客户端也就用不着专门保存公钥，也不用直接发送的公钥进行认证。\n目前我也不确定为啥客户端没发送自己的公钥，最后也能登录的真正原因。\n\n## SSL\nTLS（Transport Layer Security：它相当于是SSL协议的一个后续版本，他是SSL经过IETF标准化之后的产物。\n上面wiki上也有写，SSH其实是专门为shell设计的一种通信协议，它垮了两个网络层（传输层和应用层）。通俗点讲就是只有SSH客户端，和SSH服务器端之间的通信才能使用这个协议，其他软件服务无法使用它。但是其实我们非常需要一个通用的，建立在应用层之下的一个传输层安全协议，它的目标是建立一种对上层应用协议透明的，不管是HTTP、FTP、还是电子邮件协议或其他任何应用层协议都可以依赖的底层的可安全通信的传输层协议。SSL（Secure Sockets Layer）协议就是在此背景下诞生的。\n\n对于一个通用的协议来说，类似SSH使用printfinger来防止中间人攻击不一样，互联网上所有的客户端和服务器是不可能自己判断对方是不是可信。这个时候就用到了我们所说的 `数字证书` 的概念，在SSL中引入了一个公证机关，就是我们熟知的 `CA`。有了数字证书，浏览器在建立SSL连接之前，并不只是简单获取服务器的公钥，而从服务器获取数字证书。有了信任机制之后，剩下的交互过程还是我们所熟知的非对称加密过程。\n![](http://www.ruanyifeng.com/blogimg/asset/2014/bg2014092007.png)\n[图解SSL/TLS协议-阮一峰](http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html)\n\n## HTTPS\n上面的概念清晰了以后，理解HTTPS就简单了。HTTPS的全程是 Hypertext Transfer Protocol Secure，就是 运行在 SSL/TLS 之上的 HTTP协议。\n做为网站管理员，可能会遇到申请数字证书的任务，理解了上面的概念，申请数字证书就不那么一头雾水了，首先你要为服务器生成一对公司密钥，然后把你网站的信息连同你的公钥一起发送给某个权威的CA，CA会通过某种方式认证申请人是否真的是网站的所有人，比如让你在网站的指定路径上传他指定的特殊蚊子序列。验证通过就会得到证书了。\n\n\n## 参考文献\n- http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html\n- https://zh.wikipedia.org/wiki/RSA加密演算法\n- https://www.jianshu.com/p/5e3f9dfd2cb4\n- https://www.jianshu.com/p/b078282653b3","slug":"sshLogin","published":1,"updated":"2019-09-08T02:27:23.466Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0wfvhr30013uhoxw2u65v7z","content":"<blockquote>\n<p>一直对 SSH 、SSL 以及 HTTPS 和它们互相之间的关系都云里雾里的，下面参考网上的文章和自己的理解梳理一下，晕了就再回来看一下，总会记住的。</p>\n</blockquote>\n<h2 id=\"加密算法\"><a href=\"#加密算法\" class=\"headerlink\" title=\"加密算法\"></a>加密算法</h2><p>首先先说下加密算法，可以分为两大类，<code>对称加密</code> 和 <code>非对称加密</code>。</p>\n<h3 id=\"对称加密\"><a href=\"#对称加密\" class=\"headerlink\" title=\"对称加密\"></a>对称加密</h3><p>通信双方的数据都是用同一套密钥来进行加密和解密。<br>在1976年以前，所有的加密都采用对称加密，这种加密方式最大的问题就是如何管理秘钥？既要保证秘钥不泄露，同时还要保证秘钥的共享性。</p>\n<h3 id=\"非对称加密\"><a href=\"#非对称加密\" class=\"headerlink\" title=\"非对称加密\"></a>非对称加密</h3><p>1976年有两位数学家提出的一个新的加密概念：</p>\n<ol>\n<li>A生成一对两把密钥（公钥和私钥）。</li>\n<li>B获取A生成的公钥，然后用公钥对信息加密。</li>\n<li>A收到B的加密信息后，用自己的私钥解密。</li>\n</ol>\n<p>非对称加密引入了公钥和私钥的概念。公钥加密，私钥解密。公钥是面向所有使用者公开的。<br>目前计算机领域使用最广泛的非对称加密算法是<a href=\"https://zh.wikipedia.org/wiki/RSA%E5%8A%A0%E5%AF%86%E6%BC%94%E7%AE%97%E6%B3%95\" target=\"_blank\" rel=\"noopener\">RSA</a>。</p>\n<p>对称加密看起来很强大，但是也有缺点：</p>\n<ul>\n<li>加密更耗时：算法更复杂。</li>\n<li>容易受到中间人攻击:即如果有C冒充A利用A的公钥给B发消息，B的所有消息对C其实就是透明的了。</li>\n</ul>\n<p>针对中间人攻击，一般就采用非对称加密+摘要算法+数字签名的机制来确保传输安全。</p>\n<h3 id=\"摘要算法（hash算法）\"><a href=\"#摘要算法（hash算法）\" class=\"headerlink\" title=\"摘要算法（hash算法）\"></a>摘要算法（hash算法）</h3><p>Hash 算法的特点是单向不可逆。利用这个特性，可以通过hash对目前信息加密生成特定长度且唯一的hash值，该值也不能被逆向破译。因此hash算法进场用在不可还原的密码存储、信息完整性校验等领域。常见的hash算法：MD2，MD4，MD5，SHA等</p>\n<h3 id=\"数字签名\"><a href=\"#数字签名\" class=\"headerlink\" title=\"数字签名\"></a>数字签名</h3><p>数字签名，是为了保证信息在传输过程中没有被篡改。使用hash算法生成要发送明文的摘要，然后 把明文和摘要都通过私钥加密，加密后的摘要作为<code>数字签名（digital signature）</code>跟加密后的内容一起发送给接受者。接受者收到数据信息后，使用公钥分别对内容和信息解密，得到数据和内容摘要，然后用一样的算法对内容生成摘要，比较摘要是否相同来确认信息的完整性。</p>\n<h3 id=\"数字证书\"><a href=\"#数字证书\" class=\"headerlink\" title=\"数字证书\"></a>数字证书</h3><p>以上的流程还是存在一个问题就是，有人冒充通信人发放公钥。这种场景的出现，我们就需要有个公证人了，告诉我们到底有是真的注册登记过的。这个公证人就是证书中心（certificate authority）简称CA。<br>所有想发放公钥的人，都需要去CA为自己的公钥做认证。证书中心会用自己私钥和公钥以及公钥人信息一起进行加密，生成的东西就叫数字证书。以后所有类似的场景，都是统一用CA的公钥解开数字证书，拿到通信用的公钥，然后证明数字签名确实是来自哪里的了。</p>\n<p>关于数字签名和数字证书，阮一峰老师的这篇文章讲的特别生动<a href=\"http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html\" target=\"_blank\" rel=\"noopener\">blog</a></p>\n<h2 id=\"SSH\"><a href=\"#SSH\" class=\"headerlink\" title=\"SSH\"></a>SSH</h2><p>wiki上对SSH的定义:</p>\n<blockquote>\n<p>Secure Shell（缩写为SSH），由IETF的网络工作小组（Network Working Group）所制定；SSH为一项创建在应用层和传输层基础上的安全协议，为计算机上的Shell（壳层）提供安全的传输和使用环境。<br>传统的网络服务程序，如rsh、FTP、POP和Telnet其本质上都是不安全的；因为它们在网络上用明文传送数据、用户帐号和用户口令，很容易受到中间人（man-in-the-middle）攻击方式的攻击。就是存在另一个&gt;人或者一台机器冒充真正的服务器接收用户传给服务器的数据，然后再冒充用户把数据传给真正的服务器。<br>而SSH是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用SSH协议可以有效防止远程管理过程中的信息泄露问题。通过SSH可以对所有传输的数据进行加密，也能够防止DNS欺骗和IP欺骗。<br>SSH之另一项优点为其传输的数据可以是经过压缩的，所以可以加快传输的速度。SSH有很多功能，它既可以代替Telnet，又可以为FTP、POP、甚至为PPP提供一个安全的“通道”。</p>\n</blockquote>\n<p>看了以后显然更晕了，注意一下他是一个<code>SHELL</code>, 可以理解为 SSH 服务器之间安全通信的一个协议，既然称之为安全的，想必是通信过程使用了加密手段。<br>这时候就用上了我们上一节的知识了，我们现在要在服务器之前就行安全的通信：</p>\n<ol>\n<li>A、B之间建立TCP连接</li>\n<li>B生成一对公私密钥</li>\n<li>B把公钥发送给A</li>\n<li>A生成一个用于加密数据的密钥K（既我们想通知给客户端的密钥，之后的数据通信都使用这个密钥加密，这个密钥不可让第三方知道）</li>\n<li>A把K用公钥加密发送给B，B解密后，从此A、B之间的通信数据都用K密钥进行加密和解密（转为了安全的对称加密方式）。</li>\n</ol>\n<p>这个过程还是会有一样的问题，加入中间有C、D，假冒B发放公钥给A，夹在了A和B之间，不是又不安全了吗。<br>为了解决这个问题SSH协议采用由人工判断公钥的fingerprint是否可信的方式：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">The authenticity of host <span class=\"string\">'172.20.7.211 (&lt;no hostip for proxy command&gt;)'</span> can<span class=\"string\">'t be established.</span></span><br><span class=\"line\"><span class=\"string\">RSA key fingerprint is 23:42:c1:e4:3f:d2:cc:37:1d:89:cb:e7:5d:be:5d:53.</span></span><br><span class=\"line\"><span class=\"string\">Are you sure you want to continue connecting (yes/no)?</span></span><br></pre></td></tr></table></figure>\n\n<p>输入yes之后才会连接到远程服务器，同时这个信息会存储到用户的.ssh/known_hosts文件中，下次再登录的时候，会检查known_host文件，如果存在相同的公钥信息，就不在提示用户确认了.相当于中间加了一步人工验证，确定下要连接的机器，作为客户端一般也确实是知道自己要连谁的。<br>当然这一步也可以手动跳过:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh -o PubkeyAuthentication=yes  -o stricthostkeychecking=no</span><br></pre></td></tr></table></figure>\n\n<p>我们都用过<code>ssh-keygen</code> 命令，他就是为我们生成一对密钥（公钥+私钥），用于我们所说的非对称加密过程</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-keygen -t rsa</span><br><span class=\"line\"><span class=\"comment\">#.ssh/</span></span><br><span class=\"line\">id_rsa.pub       //公钥   </span><br><span class=\"line\">id_rsa           //密钥</span><br></pre></td></tr></table></figure>\n\n<p>将id_rsa.pub的内容写入authorized_keys文件中，表示该机器目前授权的使用该公钥访问</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat id_rsa.pub &gt;&gt; authorized_keys</span><br></pre></td></tr></table></figure>\n\n<p>这样就将公钥内容追加到authorized_keys中了，然后需要注意配置权限了，否则SSH不会工作：</p>\n<ul>\n<li>将.ssh目录的权限为700</li>\n<li>将authorized_keys目录的权限为600<br>有个 <code>ssh-copy-id</code> 工具很好用,一行命令就可以复制公钥到对应服务器下的 authorized_keys。<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-copy-id -i username@remote-server</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p>一个完整的SSH客户端认证流程<br>一般我们能接触到的的认证方式有两种：</p>\n<ul>\n<li>密码认证</li>\n<li>密钥认证</li>\n</ul>\n<p>密码认证很好理解，就是我们在登录远程linux服务器的时候提供用户名和密码。</p>\n<p>每次登录都要输入密码很麻烦，且密码如果简单的话可能还会被暴力破解，而且很多自动化场景要求我们实现免密登录服务器。密钥认证提供了一种更安全便捷的认证客户端的方式。这个技术也用到了非对称加密技术，由客户端生成公私密钥对，然后将公钥保存在服务器上。认证的过程大体如下：</p>\n<ol>\n<li>客户端发起一个公钥的认证请求，并发送RSA Key的模数作为标识符。</li>\n<li>服务端检查是否存在请求帐号的公钥（Linux中存储在~/.ssh/authorized_keys文件中），以及其拥有的访问权限。</li>\n<li>服务端使用对应的公钥对一个随机的256位的字符串进行加密，并发送给客户端</li>\n<li>客户端使用私钥对字符串进行解密，并将其结合session id生成一个MD5值发送给服务端。</li>\n<li>服务端采用同样的方式生成MD5值与客户端返回的MD5值进行比较，完成对客户端的认证。</li>\n</ol>\n<p>疑点：这个流程确实是一个完整的非对称加密处理的认证过程，但是实际使用中我发现客户端并没有发送自己的公钥，因为我把客户端的公钥删了，或者只复制私钥到一个新的客户端上，最终还是可以登入authorized_keys中配置了对应公钥的服务器。</p>\n<ul>\n<li>所以我猜测客户端发送请求后，服务端这边是把authorized_keys中的锁让客户端的钥匙循环匹配的？能打开其中的一把锁就能登录，但是这样key多的话，建立连接就会有效率问题。</li>\n<li>另一个猜测，这个发送的RSA_KEY的模数是通过私钥就能产生的，就是说通过私钥有办法直接得到它对应公钥的标志，所以客户端也就用不着专门保存公钥，也不用直接发送的公钥进行认证。<br>目前我也不确定为啥客户端没发送自己的公钥，最后也能登录的真正原因。</li>\n</ul>\n<h2 id=\"SSL\"><a href=\"#SSL\" class=\"headerlink\" title=\"SSL\"></a>SSL</h2><p>TLS（Transport Layer Security：它相当于是SSL协议的一个后续版本，他是SSL经过IETF标准化之后的产物。<br>上面wiki上也有写，SSH其实是专门为shell设计的一种通信协议，它垮了两个网络层（传输层和应用层）。通俗点讲就是只有SSH客户端，和SSH服务器端之间的通信才能使用这个协议，其他软件服务无法使用它。但是其实我们非常需要一个通用的，建立在应用层之下的一个传输层安全协议，它的目标是建立一种对上层应用协议透明的，不管是HTTP、FTP、还是电子邮件协议或其他任何应用层协议都可以依赖的底层的可安全通信的传输层协议。SSL（Secure Sockets Layer）协议就是在此背景下诞生的。</p>\n<p>对于一个通用的协议来说，类似SSH使用printfinger来防止中间人攻击不一样，互联网上所有的客户端和服务器是不可能自己判断对方是不是可信。这个时候就用到了我们所说的 <code>数字证书</code> 的概念，在SSL中引入了一个公证机关，就是我们熟知的 <code>CA</code>。有了数字证书，浏览器在建立SSL连接之前，并不只是简单获取服务器的公钥，而从服务器获取数字证书。有了信任机制之后，剩下的交互过程还是我们所熟知的非对称加密过程。<br><img src=\"http://www.ruanyifeng.com/blogimg/asset/2014/bg2014092007.png\" alt><br><a href=\"http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html\" target=\"_blank\" rel=\"noopener\">图解SSL/TLS协议-阮一峰</a></p>\n<h2 id=\"HTTPS\"><a href=\"#HTTPS\" class=\"headerlink\" title=\"HTTPS\"></a>HTTPS</h2><p>上面的概念清晰了以后，理解HTTPS就简单了。HTTPS的全程是 Hypertext Transfer Protocol Secure，就是 运行在 SSL/TLS 之上的 HTTP协议。<br>做为网站管理员，可能会遇到申请数字证书的任务，理解了上面的概念，申请数字证书就不那么一头雾水了，首先你要为服务器生成一对公司密钥，然后把你网站的信息连同你的公钥一起发送给某个权威的CA，CA会通过某种方式认证申请人是否真的是网站的所有人，比如让你在网站的指定路径上传他指定的特殊蚊子序列。验证通过就会得到证书了。</p>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html\" target=\"_blank\" rel=\"noopener\">http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html</a></li>\n<li><a href=\"https://zh.wikipedia.org/wiki/RSA加密演算法\" target=\"_blank\" rel=\"noopener\">https://zh.wikipedia.org/wiki/RSA加密演算法</a></li>\n<li><a href=\"https://www.jianshu.com/p/5e3f9dfd2cb4\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/5e3f9dfd2cb4</a></li>\n<li><a href=\"https://www.jianshu.com/p/b078282653b3\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/b078282653b3</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>一直对 SSH 、SSL 以及 HTTPS 和它们互相之间的关系都云里雾里的，下面参考网上的文章和自己的理解梳理一下，晕了就再回来看一下，总会记住的。</p>\n</blockquote>\n<h2 id=\"加密算法\"><a href=\"#加密算法\" class=\"headerlink\" title=\"加密算法\"></a>加密算法</h2><p>首先先说下加密算法，可以分为两大类，<code>对称加密</code> 和 <code>非对称加密</code>。</p>\n<h3 id=\"对称加密\"><a href=\"#对称加密\" class=\"headerlink\" title=\"对称加密\"></a>对称加密</h3><p>通信双方的数据都是用同一套密钥来进行加密和解密。<br>在1976年以前，所有的加密都采用对称加密，这种加密方式最大的问题就是如何管理秘钥？既要保证秘钥不泄露，同时还要保证秘钥的共享性。</p>\n<h3 id=\"非对称加密\"><a href=\"#非对称加密\" class=\"headerlink\" title=\"非对称加密\"></a>非对称加密</h3><p>1976年有两位数学家提出的一个新的加密概念：</p>\n<ol>\n<li>A生成一对两把密钥（公钥和私钥）。</li>\n<li>B获取A生成的公钥，然后用公钥对信息加密。</li>\n<li>A收到B的加密信息后，用自己的私钥解密。</li>\n</ol>\n<p>非对称加密引入了公钥和私钥的概念。公钥加密，私钥解密。公钥是面向所有使用者公开的。<br>目前计算机领域使用最广泛的非对称加密算法是<a href=\"https://zh.wikipedia.org/wiki/RSA%E5%8A%A0%E5%AF%86%E6%BC%94%E7%AE%97%E6%B3%95\" target=\"_blank\" rel=\"noopener\">RSA</a>。</p>\n<p>对称加密看起来很强大，但是也有缺点：</p>\n<ul>\n<li>加密更耗时：算法更复杂。</li>\n<li>容易受到中间人攻击:即如果有C冒充A利用A的公钥给B发消息，B的所有消息对C其实就是透明的了。</li>\n</ul>\n<p>针对中间人攻击，一般就采用非对称加密+摘要算法+数字签名的机制来确保传输安全。</p>\n<h3 id=\"摘要算法（hash算法）\"><a href=\"#摘要算法（hash算法）\" class=\"headerlink\" title=\"摘要算法（hash算法）\"></a>摘要算法（hash算法）</h3><p>Hash 算法的特点是单向不可逆。利用这个特性，可以通过hash对目前信息加密生成特定长度且唯一的hash值，该值也不能被逆向破译。因此hash算法进场用在不可还原的密码存储、信息完整性校验等领域。常见的hash算法：MD2，MD4，MD5，SHA等</p>\n<h3 id=\"数字签名\"><a href=\"#数字签名\" class=\"headerlink\" title=\"数字签名\"></a>数字签名</h3><p>数字签名，是为了保证信息在传输过程中没有被篡改。使用hash算法生成要发送明文的摘要，然后 把明文和摘要都通过私钥加密，加密后的摘要作为<code>数字签名（digital signature）</code>跟加密后的内容一起发送给接受者。接受者收到数据信息后，使用公钥分别对内容和信息解密，得到数据和内容摘要，然后用一样的算法对内容生成摘要，比较摘要是否相同来确认信息的完整性。</p>\n<h3 id=\"数字证书\"><a href=\"#数字证书\" class=\"headerlink\" title=\"数字证书\"></a>数字证书</h3><p>以上的流程还是存在一个问题就是，有人冒充通信人发放公钥。这种场景的出现，我们就需要有个公证人了，告诉我们到底有是真的注册登记过的。这个公证人就是证书中心（certificate authority）简称CA。<br>所有想发放公钥的人，都需要去CA为自己的公钥做认证。证书中心会用自己私钥和公钥以及公钥人信息一起进行加密，生成的东西就叫数字证书。以后所有类似的场景，都是统一用CA的公钥解开数字证书，拿到通信用的公钥，然后证明数字签名确实是来自哪里的了。</p>\n<p>关于数字签名和数字证书，阮一峰老师的这篇文章讲的特别生动<a href=\"http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html\" target=\"_blank\" rel=\"noopener\">blog</a></p>\n<h2 id=\"SSH\"><a href=\"#SSH\" class=\"headerlink\" title=\"SSH\"></a>SSH</h2><p>wiki上对SSH的定义:</p>\n<blockquote>\n<p>Secure Shell（缩写为SSH），由IETF的网络工作小组（Network Working Group）所制定；SSH为一项创建在应用层和传输层基础上的安全协议，为计算机上的Shell（壳层）提供安全的传输和使用环境。<br>传统的网络服务程序，如rsh、FTP、POP和Telnet其本质上都是不安全的；因为它们在网络上用明文传送数据、用户帐号和用户口令，很容易受到中间人（man-in-the-middle）攻击方式的攻击。就是存在另一个&gt;人或者一台机器冒充真正的服务器接收用户传给服务器的数据，然后再冒充用户把数据传给真正的服务器。<br>而SSH是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用SSH协议可以有效防止远程管理过程中的信息泄露问题。通过SSH可以对所有传输的数据进行加密，也能够防止DNS欺骗和IP欺骗。<br>SSH之另一项优点为其传输的数据可以是经过压缩的，所以可以加快传输的速度。SSH有很多功能，它既可以代替Telnet，又可以为FTP、POP、甚至为PPP提供一个安全的“通道”。</p>\n</blockquote>\n<p>看了以后显然更晕了，注意一下他是一个<code>SHELL</code>, 可以理解为 SSH 服务器之间安全通信的一个协议，既然称之为安全的，想必是通信过程使用了加密手段。<br>这时候就用上了我们上一节的知识了，我们现在要在服务器之前就行安全的通信：</p>\n<ol>\n<li>A、B之间建立TCP连接</li>\n<li>B生成一对公私密钥</li>\n<li>B把公钥发送给A</li>\n<li>A生成一个用于加密数据的密钥K（既我们想通知给客户端的密钥，之后的数据通信都使用这个密钥加密，这个密钥不可让第三方知道）</li>\n<li>A把K用公钥加密发送给B，B解密后，从此A、B之间的通信数据都用K密钥进行加密和解密（转为了安全的对称加密方式）。</li>\n</ol>\n<p>这个过程还是会有一样的问题，加入中间有C、D，假冒B发放公钥给A，夹在了A和B之间，不是又不安全了吗。<br>为了解决这个问题SSH协议采用由人工判断公钥的fingerprint是否可信的方式：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">The authenticity of host <span class=\"string\">'172.20.7.211 (&lt;no hostip for proxy command&gt;)'</span> can<span class=\"string\">'t be established.</span></span><br><span class=\"line\"><span class=\"string\">RSA key fingerprint is 23:42:c1:e4:3f:d2:cc:37:1d:89:cb:e7:5d:be:5d:53.</span></span><br><span class=\"line\"><span class=\"string\">Are you sure you want to continue connecting (yes/no)?</span></span><br></pre></td></tr></table></figure>\n\n<p>输入yes之后才会连接到远程服务器，同时这个信息会存储到用户的.ssh/known_hosts文件中，下次再登录的时候，会检查known_host文件，如果存在相同的公钥信息，就不在提示用户确认了.相当于中间加了一步人工验证，确定下要连接的机器，作为客户端一般也确实是知道自己要连谁的。<br>当然这一步也可以手动跳过:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh -o PubkeyAuthentication=yes  -o stricthostkeychecking=no</span><br></pre></td></tr></table></figure>\n\n<p>我们都用过<code>ssh-keygen</code> 命令，他就是为我们生成一对密钥（公钥+私钥），用于我们所说的非对称加密过程</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-keygen -t rsa</span><br><span class=\"line\"><span class=\"comment\">#.ssh/</span></span><br><span class=\"line\">id_rsa.pub       //公钥   </span><br><span class=\"line\">id_rsa           //密钥</span><br></pre></td></tr></table></figure>\n\n<p>将id_rsa.pub的内容写入authorized_keys文件中，表示该机器目前授权的使用该公钥访问</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat id_rsa.pub &gt;&gt; authorized_keys</span><br></pre></td></tr></table></figure>\n\n<p>这样就将公钥内容追加到authorized_keys中了，然后需要注意配置权限了，否则SSH不会工作：</p>\n<ul>\n<li>将.ssh目录的权限为700</li>\n<li>将authorized_keys目录的权限为600<br>有个 <code>ssh-copy-id</code> 工具很好用,一行命令就可以复制公钥到对应服务器下的 authorized_keys。<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-copy-id -i username@remote-server</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p>一个完整的SSH客户端认证流程<br>一般我们能接触到的的认证方式有两种：</p>\n<ul>\n<li>密码认证</li>\n<li>密钥认证</li>\n</ul>\n<p>密码认证很好理解，就是我们在登录远程linux服务器的时候提供用户名和密码。</p>\n<p>每次登录都要输入密码很麻烦，且密码如果简单的话可能还会被暴力破解，而且很多自动化场景要求我们实现免密登录服务器。密钥认证提供了一种更安全便捷的认证客户端的方式。这个技术也用到了非对称加密技术，由客户端生成公私密钥对，然后将公钥保存在服务器上。认证的过程大体如下：</p>\n<ol>\n<li>客户端发起一个公钥的认证请求，并发送RSA Key的模数作为标识符。</li>\n<li>服务端检查是否存在请求帐号的公钥（Linux中存储在~/.ssh/authorized_keys文件中），以及其拥有的访问权限。</li>\n<li>服务端使用对应的公钥对一个随机的256位的字符串进行加密，并发送给客户端</li>\n<li>客户端使用私钥对字符串进行解密，并将其结合session id生成一个MD5值发送给服务端。</li>\n<li>服务端采用同样的方式生成MD5值与客户端返回的MD5值进行比较，完成对客户端的认证。</li>\n</ol>\n<p>疑点：这个流程确实是一个完整的非对称加密处理的认证过程，但是实际使用中我发现客户端并没有发送自己的公钥，因为我把客户端的公钥删了，或者只复制私钥到一个新的客户端上，最终还是可以登入authorized_keys中配置了对应公钥的服务器。</p>\n<ul>\n<li>所以我猜测客户端发送请求后，服务端这边是把authorized_keys中的锁让客户端的钥匙循环匹配的？能打开其中的一把锁就能登录，但是这样key多的话，建立连接就会有效率问题。</li>\n<li>另一个猜测，这个发送的RSA_KEY的模数是通过私钥就能产生的，就是说通过私钥有办法直接得到它对应公钥的标志，所以客户端也就用不着专门保存公钥，也不用直接发送的公钥进行认证。<br>目前我也不确定为啥客户端没发送自己的公钥，最后也能登录的真正原因。</li>\n</ul>\n<h2 id=\"SSL\"><a href=\"#SSL\" class=\"headerlink\" title=\"SSL\"></a>SSL</h2><p>TLS（Transport Layer Security：它相当于是SSL协议的一个后续版本，他是SSL经过IETF标准化之后的产物。<br>上面wiki上也有写，SSH其实是专门为shell设计的一种通信协议，它垮了两个网络层（传输层和应用层）。通俗点讲就是只有SSH客户端，和SSH服务器端之间的通信才能使用这个协议，其他软件服务无法使用它。但是其实我们非常需要一个通用的，建立在应用层之下的一个传输层安全协议，它的目标是建立一种对上层应用协议透明的，不管是HTTP、FTP、还是电子邮件协议或其他任何应用层协议都可以依赖的底层的可安全通信的传输层协议。SSL（Secure Sockets Layer）协议就是在此背景下诞生的。</p>\n<p>对于一个通用的协议来说，类似SSH使用printfinger来防止中间人攻击不一样，互联网上所有的客户端和服务器是不可能自己判断对方是不是可信。这个时候就用到了我们所说的 <code>数字证书</code> 的概念，在SSL中引入了一个公证机关，就是我们熟知的 <code>CA</code>。有了数字证书，浏览器在建立SSL连接之前，并不只是简单获取服务器的公钥，而从服务器获取数字证书。有了信任机制之后，剩下的交互过程还是我们所熟知的非对称加密过程。<br><img src=\"http://www.ruanyifeng.com/blogimg/asset/2014/bg2014092007.png\" alt><br><a href=\"http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html\" target=\"_blank\" rel=\"noopener\">图解SSL/TLS协议-阮一峰</a></p>\n<h2 id=\"HTTPS\"><a href=\"#HTTPS\" class=\"headerlink\" title=\"HTTPS\"></a>HTTPS</h2><p>上面的概念清晰了以后，理解HTTPS就简单了。HTTPS的全程是 Hypertext Transfer Protocol Secure，就是 运行在 SSL/TLS 之上的 HTTP协议。<br>做为网站管理员，可能会遇到申请数字证书的任务，理解了上面的概念，申请数字证书就不那么一头雾水了，首先你要为服务器生成一对公司密钥，然后把你网站的信息连同你的公钥一起发送给某个权威的CA，CA会通过某种方式认证申请人是否真的是网站的所有人，比如让你在网站的指定路径上传他指定的特殊蚊子序列。验证通过就会得到证书了。</p>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html\" target=\"_blank\" rel=\"noopener\">http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html</a></li>\n<li><a href=\"https://zh.wikipedia.org/wiki/RSA加密演算法\" target=\"_blank\" rel=\"noopener\">https://zh.wikipedia.org/wiki/RSA加密演算法</a></li>\n<li><a href=\"https://www.jianshu.com/p/5e3f9dfd2cb4\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/5e3f9dfd2cb4</a></li>\n<li><a href=\"https://www.jianshu.com/p/b078282653b3\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/b078282653b3</a></li>\n</ul>\n"},{"title":"Nginx 配置 SSL","date":"2019-08-31T02:35:31.000Z","_content":"\n> 域名貌似备案成功了，解析到腾讯云服务器ip后，发现直接访问 http协议 是可以的 换成 https 不行了。应该是没有配置SSL导致的。\n\n## 什么是HTTPS\nhttps 全称：Hyper Text Transfer Protocol over Secure Socket Layer，是http的安全版。即http下加入SSL协议层，因此https的安全基础就是SSL，所以加密内容需要SSL。\n\n## SSL原理\n- 浏览器发送一个https的请求给服务器；\n- 服务器要有一套数字证书，可以自己制作，也可以向组织申请，区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面，这套证书其实就是一对公钥和私钥；\n- 服务器会把公钥传输给客户端；\n- 客户端（浏览器）收到公钥后，会验证其是否合法有效，无效会有警告提醒，有效则会生成一串随机数，并用收到的公钥加密；\n- 客户端把加密后的随机字符串传输给服务器；\n- 服务器收到加密随机字符串后，先用私钥解密（公钥加密，私钥解密），获取到这一串随机数后，再用这串随机字符串加密传输的数据（该加密为对称加密，所谓对称加密，就是将数据和私钥也就是这个随机字符串>通过某种算法混合在一起，这样除非知道私钥，否则无法获取数据内容）；\n- 服务器把加密后的数据传输给客户端；\n- 客户端收到数据后，再用自己的私钥也就是那个随机字符串解密；\n\n## 配置 with-http_ssl_module 模块\n首先需要申请一个证书，可以申请一个免费的。\n参考下面的 `其他方式` 部分可以直接在云服务厂商可视化界面申请并下载~\n然后会得到nginx版本证书，一个公钥（证书），一个私钥，将其上传到服务器。\n\n先确认`nginx`安装时已编译`http_ssl`模块，也就是执行`nginx -V`命令查看是否存在 `--with-http_ssl_module`。如果没有，则需要重新编译nginx将该模块加入。\n若有的话此步骤跳过\n若ssl模块没有先编译一下\n\n```bash\ncd /usr/local/src/nginx-1.12.1/  #nginx版本号可能不同哟\n\n./configure --help | grep -i ssl\n  --with-http_ssl_module \n  \n./configure --prefix=/usr/local/nginx --with-http_ssl_module\n\n```\n\n## 生成 ssl 秘钥对\n```bash\ncd /usr/local/nginx/conf\n\nyum install -y openssl\n```\n\n### 使用RSA算法生产key\n```bash\nopenssl genrsa -des3 -out tmp.key 2048\n# 生成一个rsa类型的密钥，且长度为2048，但是我们有发现，让我们设置密码，如果每次有人访问我们的站点，都需要输入密码，太麻烦了\n```\n所以我们要转换私钥，取消密码（其实tmp.key与zhdy.key密钥内容是一样的，只不过一个有密码一个没有）：\n```bash\nopenssl rsa -in tmp.key -out zhdy.key \n\nrm -f tmp.key\n```\n### 创建证书申请\n```\nopenssl req -new -key zhdy.key -out zhdy.csr\n```\n\n### 创建自签名的证书\n```bash\nopenssl x509 -req -days 365 -in zhdy.csr -signkey zhdy.key -out zhdy.crt\n```\n\n## Nginx 配置 ssl\n```bash\nserver\n{\n    listen 443;\n    server_name huguobo.site; # 换成你自己的域名服务哟\n    index index.html index.php;\n    root /path/to/your/file \n    ssl on;\n    ssl_certificate zhdy.crt;\n    ssl_certificate_key zhdy.key;\n    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;\n}\n\n# ssl on; 代表着打开ssl\n#ssl_certificate zhdy.crt; 公钥\n# ssl_certificate_key zhdy.key; 私钥\n# ssl_protocols TLSv1 TLSv1.1 TLSv1.2; 三种不同的协议\n```\n\n## 测试\n```bash\nnginx -t\nnginx restart\n```\n\n由于已经设置了443，所以我们使用curl -x 是不生效的。\n我们修改下/etc/hosts为: `yourip www.aaa.com`\n\n```bash\ncurl https://haha.com\n```\n报错显示为“此证书非安全证书”，但是ssl是已经成功配置了\n\n## 其他方式（更快捷）\n后来发现各个厂商也提供申请证书的入口，也提供 DNS 和 文件验证两种配置,大家也可以自行参考配置\n[腾讯云ssl控制台](https://console.cloud.tencent.com/ssl)\n[nginx配置文档](https://cloud.tencent.com/document/product/400/35244)\n\n这种从供应商处可以直接下载到证书，然后nginx的配置秘钥和证书都在 nginx 文件夹下\n\n从客户端传送文件到云主机（MAC）\n```bash\nscp  ./2_huguobo.site.key ./1_huguobo.site_bundle.crt  root@118.24.215.220:/usr/local/nginx/conf\n```\n登录云主机 nginx 配置\n```bash\n# Settings for a TLS enabled server.\n\n    server {\n        listen       443 ssl http2 default_server;\n        listen       [::]:443 ssl http2 default_server;\n        server_name  huguobo.site;\n\n        ssl on;\n        ssl_certificate \"/usr/local/nginx/conf/1_huguobo.site_bundle.crt\";\n        ssl_certificate_key \"/usr/local/nginx/conf/2_huguobo.site.key\";\n        ssl_session_cache shared:SSL:1m;\n        ssl_session_timeout  10m;\n        ssl_protocols TLSv1 TLSv1.1 TLSv1.2;\n        ssl_prefer_server_ciphers on;\n        ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE; #请按照这个套件配置，配置加密套件，写法遵循 openssl 标准。\n\n        # Load configuration files for the default server block.\n        include /etc/nginx/default.d/*.conf;\n\n        location / {\n           root /home/hexoBlog; # your path\n           index index.html;\n        }\n\n        error_page 404 /404.html;\n            location = /40x.html {\n        }\n        error_page 500 502 503 504 /50x.html;\n            location = /50x.html {\n        }\n   }\n\n```\n## 强制HTTPS\n我没有做强制https。但是需要的话，改下 nginx 配置文件即可\nhttp 默认是`80`端口 ，https 是`443`端口\n```bash\nserver{\n      listen 80;    #表示监听80端口\n      server_name huguobo.site\n      location / {    #将80端口强制转为https\n          rewrite (.*) https://huguobo.site$1 permanent;\n      }\n}\n```\n","source":"_posts/nginx配置ssl.md","raw":"---\ntitle: Nginx 配置 SSL\ndate: 2019-08-31 10:35:31\ncategories: \n- devOps\ntags:\n- nginx\n- ssl\n- Https\n---\n\n> 域名貌似备案成功了，解析到腾讯云服务器ip后，发现直接访问 http协议 是可以的 换成 https 不行了。应该是没有配置SSL导致的。\n\n## 什么是HTTPS\nhttps 全称：Hyper Text Transfer Protocol over Secure Socket Layer，是http的安全版。即http下加入SSL协议层，因此https的安全基础就是SSL，所以加密内容需要SSL。\n\n## SSL原理\n- 浏览器发送一个https的请求给服务器；\n- 服务器要有一套数字证书，可以自己制作，也可以向组织申请，区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面，这套证书其实就是一对公钥和私钥；\n- 服务器会把公钥传输给客户端；\n- 客户端（浏览器）收到公钥后，会验证其是否合法有效，无效会有警告提醒，有效则会生成一串随机数，并用收到的公钥加密；\n- 客户端把加密后的随机字符串传输给服务器；\n- 服务器收到加密随机字符串后，先用私钥解密（公钥加密，私钥解密），获取到这一串随机数后，再用这串随机字符串加密传输的数据（该加密为对称加密，所谓对称加密，就是将数据和私钥也就是这个随机字符串>通过某种算法混合在一起，这样除非知道私钥，否则无法获取数据内容）；\n- 服务器把加密后的数据传输给客户端；\n- 客户端收到数据后，再用自己的私钥也就是那个随机字符串解密；\n\n## 配置 with-http_ssl_module 模块\n首先需要申请一个证书，可以申请一个免费的。\n参考下面的 `其他方式` 部分可以直接在云服务厂商可视化界面申请并下载~\n然后会得到nginx版本证书，一个公钥（证书），一个私钥，将其上传到服务器。\n\n先确认`nginx`安装时已编译`http_ssl`模块，也就是执行`nginx -V`命令查看是否存在 `--with-http_ssl_module`。如果没有，则需要重新编译nginx将该模块加入。\n若有的话此步骤跳过\n若ssl模块没有先编译一下\n\n```bash\ncd /usr/local/src/nginx-1.12.1/  #nginx版本号可能不同哟\n\n./configure --help | grep -i ssl\n  --with-http_ssl_module \n  \n./configure --prefix=/usr/local/nginx --with-http_ssl_module\n\n```\n\n## 生成 ssl 秘钥对\n```bash\ncd /usr/local/nginx/conf\n\nyum install -y openssl\n```\n\n### 使用RSA算法生产key\n```bash\nopenssl genrsa -des3 -out tmp.key 2048\n# 生成一个rsa类型的密钥，且长度为2048，但是我们有发现，让我们设置密码，如果每次有人访问我们的站点，都需要输入密码，太麻烦了\n```\n所以我们要转换私钥，取消密码（其实tmp.key与zhdy.key密钥内容是一样的，只不过一个有密码一个没有）：\n```bash\nopenssl rsa -in tmp.key -out zhdy.key \n\nrm -f tmp.key\n```\n### 创建证书申请\n```\nopenssl req -new -key zhdy.key -out zhdy.csr\n```\n\n### 创建自签名的证书\n```bash\nopenssl x509 -req -days 365 -in zhdy.csr -signkey zhdy.key -out zhdy.crt\n```\n\n## Nginx 配置 ssl\n```bash\nserver\n{\n    listen 443;\n    server_name huguobo.site; # 换成你自己的域名服务哟\n    index index.html index.php;\n    root /path/to/your/file \n    ssl on;\n    ssl_certificate zhdy.crt;\n    ssl_certificate_key zhdy.key;\n    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;\n}\n\n# ssl on; 代表着打开ssl\n#ssl_certificate zhdy.crt; 公钥\n# ssl_certificate_key zhdy.key; 私钥\n# ssl_protocols TLSv1 TLSv1.1 TLSv1.2; 三种不同的协议\n```\n\n## 测试\n```bash\nnginx -t\nnginx restart\n```\n\n由于已经设置了443，所以我们使用curl -x 是不生效的。\n我们修改下/etc/hosts为: `yourip www.aaa.com`\n\n```bash\ncurl https://haha.com\n```\n报错显示为“此证书非安全证书”，但是ssl是已经成功配置了\n\n## 其他方式（更快捷）\n后来发现各个厂商也提供申请证书的入口，也提供 DNS 和 文件验证两种配置,大家也可以自行参考配置\n[腾讯云ssl控制台](https://console.cloud.tencent.com/ssl)\n[nginx配置文档](https://cloud.tencent.com/document/product/400/35244)\n\n这种从供应商处可以直接下载到证书，然后nginx的配置秘钥和证书都在 nginx 文件夹下\n\n从客户端传送文件到云主机（MAC）\n```bash\nscp  ./2_huguobo.site.key ./1_huguobo.site_bundle.crt  root@118.24.215.220:/usr/local/nginx/conf\n```\n登录云主机 nginx 配置\n```bash\n# Settings for a TLS enabled server.\n\n    server {\n        listen       443 ssl http2 default_server;\n        listen       [::]:443 ssl http2 default_server;\n        server_name  huguobo.site;\n\n        ssl on;\n        ssl_certificate \"/usr/local/nginx/conf/1_huguobo.site_bundle.crt\";\n        ssl_certificate_key \"/usr/local/nginx/conf/2_huguobo.site.key\";\n        ssl_session_cache shared:SSL:1m;\n        ssl_session_timeout  10m;\n        ssl_protocols TLSv1 TLSv1.1 TLSv1.2;\n        ssl_prefer_server_ciphers on;\n        ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE; #请按照这个套件配置，配置加密套件，写法遵循 openssl 标准。\n\n        # Load configuration files for the default server block.\n        include /etc/nginx/default.d/*.conf;\n\n        location / {\n           root /home/hexoBlog; # your path\n           index index.html;\n        }\n\n        error_page 404 /404.html;\n            location = /40x.html {\n        }\n        error_page 500 502 503 504 /50x.html;\n            location = /50x.html {\n        }\n   }\n\n```\n## 强制HTTPS\n我没有做强制https。但是需要的话，改下 nginx 配置文件即可\nhttp 默认是`80`端口 ，https 是`443`端口\n```bash\nserver{\n      listen 80;    #表示监听80端口\n      server_name huguobo.site\n      location / {    #将80端口强制转为https\n          rewrite (.*) https://huguobo.site$1 permanent;\n      }\n}\n```\n","slug":"nginx配置ssl","published":1,"updated":"2019-09-08T02:26:35.860Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0wfvhr50016uhoxshn903qm","content":"<blockquote>\n<p>域名貌似备案成功了，解析到腾讯云服务器ip后，发现直接访问 http协议 是可以的 换成 https 不行了。应该是没有配置SSL导致的。</p>\n</blockquote>\n<h2 id=\"什么是HTTPS\"><a href=\"#什么是HTTPS\" class=\"headerlink\" title=\"什么是HTTPS\"></a>什么是HTTPS</h2><p>https 全称：Hyper Text Transfer Protocol over Secure Socket Layer，是http的安全版。即http下加入SSL协议层，因此https的安全基础就是SSL，所以加密内容需要SSL。</p>\n<h2 id=\"SSL原理\"><a href=\"#SSL原理\" class=\"headerlink\" title=\"SSL原理\"></a>SSL原理</h2><ul>\n<li>浏览器发送一个https的请求给服务器；</li>\n<li>服务器要有一套数字证书，可以自己制作，也可以向组织申请，区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面，这套证书其实就是一对公钥和私钥；</li>\n<li>服务器会把公钥传输给客户端；</li>\n<li>客户端（浏览器）收到公钥后，会验证其是否合法有效，无效会有警告提醒，有效则会生成一串随机数，并用收到的公钥加密；</li>\n<li>客户端把加密后的随机字符串传输给服务器；</li>\n<li>服务器收到加密随机字符串后，先用私钥解密（公钥加密，私钥解密），获取到这一串随机数后，再用这串随机字符串加密传输的数据（该加密为对称加密，所谓对称加密，就是将数据和私钥也就是这个随机字符串&gt;通过某种算法混合在一起，这样除非知道私钥，否则无法获取数据内容）；</li>\n<li>服务器把加密后的数据传输给客户端；</li>\n<li>客户端收到数据后，再用自己的私钥也就是那个随机字符串解密；</li>\n</ul>\n<h2 id=\"配置-with-http-ssl-module-模块\"><a href=\"#配置-with-http-ssl-module-模块\" class=\"headerlink\" title=\"配置 with-http_ssl_module 模块\"></a>配置 with-http_ssl_module 模块</h2><p>首先需要申请一个证书，可以申请一个免费的。<br>参考下面的 <code>其他方式</code> 部分可以直接在云服务厂商可视化界面申请并下载~<br>然后会得到nginx版本证书，一个公钥（证书），一个私钥，将其上传到服务器。</p>\n<p>先确认<code>nginx</code>安装时已编译<code>http_ssl</code>模块，也就是执行<code>nginx -V</code>命令查看是否存在 <code>--with-http_ssl_module</code>。如果没有，则需要重新编译nginx将该模块加入。<br>若有的话此步骤跳过<br>若ssl模块没有先编译一下</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> /usr/<span class=\"built_in\">local</span>/src/nginx-1.12.1/  <span class=\"comment\">#nginx版本号可能不同哟</span></span><br><span class=\"line\"></span><br><span class=\"line\">./configure --<span class=\"built_in\">help</span> | grep -i ssl</span><br><span class=\"line\">  --with-http_ssl_module </span><br><span class=\"line\">  </span><br><span class=\"line\">./configure --prefix=/usr/<span class=\"built_in\">local</span>/nginx --with-http_ssl_module</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"生成-ssl-秘钥对\"><a href=\"#生成-ssl-秘钥对\" class=\"headerlink\" title=\"生成 ssl 秘钥对\"></a>生成 ssl 秘钥对</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> /usr/<span class=\"built_in\">local</span>/nginx/conf</span><br><span class=\"line\"></span><br><span class=\"line\">yum install -y openssl</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用RSA算法生产key\"><a href=\"#使用RSA算法生产key\" class=\"headerlink\" title=\"使用RSA算法生产key\"></a>使用RSA算法生产key</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">openssl genrsa -des3 -out tmp.key 2048</span><br><span class=\"line\"><span class=\"comment\"># 生成一个rsa类型的密钥，且长度为2048，但是我们有发现，让我们设置密码，如果每次有人访问我们的站点，都需要输入密码，太麻烦了</span></span><br></pre></td></tr></table></figure>\n\n<p>所以我们要转换私钥，取消密码（其实tmp.key与zhdy.key密钥内容是一样的，只不过一个有密码一个没有）：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">openssl rsa -<span class=\"keyword\">in</span> tmp.key -out zhdy.key </span><br><span class=\"line\"></span><br><span class=\"line\">rm -f tmp.key</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"创建证书申请\"><a href=\"#创建证书申请\" class=\"headerlink\" title=\"创建证书申请\"></a>创建证书申请</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">openssl req -new -key zhdy.key -out zhdy.csr</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"创建自签名的证书\"><a href=\"#创建自签名的证书\" class=\"headerlink\" title=\"创建自签名的证书\"></a>创建自签名的证书</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">openssl x509 -req -days 365 -<span class=\"keyword\">in</span> zhdy.csr -signkey zhdy.key -out zhdy.crt</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Nginx-配置-ssl\"><a href=\"#Nginx-配置-ssl\" class=\"headerlink\" title=\"Nginx 配置 ssl\"></a>Nginx 配置 ssl</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    listen 443;</span><br><span class=\"line\">    server_name huguobo.site; <span class=\"comment\"># 换成你自己的域名服务哟</span></span><br><span class=\"line\">    index index.html index.php;</span><br><span class=\"line\">    root /path/to/your/file </span><br><span class=\"line\">    ssl on;</span><br><span class=\"line\">    ssl_certificate zhdy.crt;</span><br><span class=\"line\">    ssl_certificate_key zhdy.key;</span><br><span class=\"line\">    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># ssl on; 代表着打开ssl</span></span><br><span class=\"line\"><span class=\"comment\">#ssl_certificate zhdy.crt; 公钥</span></span><br><span class=\"line\"><span class=\"comment\"># ssl_certificate_key zhdy.key; 私钥</span></span><br><span class=\"line\"><span class=\"comment\"># ssl_protocols TLSv1 TLSv1.1 TLSv1.2; 三种不同的协议</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nginx -t</span><br><span class=\"line\">nginx restart</span><br></pre></td></tr></table></figure>\n\n<p>由于已经设置了443，所以我们使用curl -x 是不生效的。<br>我们修改下/etc/hosts为: <code>yourip www.aaa.com</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl https://haha.com</span><br></pre></td></tr></table></figure>\n\n<p>报错显示为“此证书非安全证书”，但是ssl是已经成功配置了</p>\n<h2 id=\"其他方式（更快捷）\"><a href=\"#其他方式（更快捷）\" class=\"headerlink\" title=\"其他方式（更快捷）\"></a>其他方式（更快捷）</h2><p>后来发现各个厂商也提供申请证书的入口，也提供 DNS 和 文件验证两种配置,大家也可以自行参考配置<br><a href=\"https://console.cloud.tencent.com/ssl\" target=\"_blank\" rel=\"noopener\">腾讯云ssl控制台</a><br><a href=\"https://cloud.tencent.com/document/product/400/35244\" target=\"_blank\" rel=\"noopener\">nginx配置文档</a></p>\n<p>这种从供应商处可以直接下载到证书，然后nginx的配置秘钥和证书都在 nginx 文件夹下</p>\n<p>从客户端传送文件到云主机（MAC）</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scp  ./2_huguobo.site.key ./1_huguobo.site_bundle.crt  root@118.24.215.220:/usr/<span class=\"built_in\">local</span>/nginx/conf</span><br></pre></td></tr></table></figure>\n\n<p>登录云主机 nginx 配置</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Settings for a TLS enabled server.</span></span><br><span class=\"line\"></span><br><span class=\"line\">    server &#123;</span><br><span class=\"line\">        listen       443 ssl http2 default_server;</span><br><span class=\"line\">        listen       [::]:443 ssl http2 default_server;</span><br><span class=\"line\">        server_name  huguobo.site;</span><br><span class=\"line\"></span><br><span class=\"line\">        ssl on;</span><br><span class=\"line\">        ssl_certificate <span class=\"string\">\"/usr/local/nginx/conf/1_huguobo.site_bundle.crt\"</span>;</span><br><span class=\"line\">        ssl_certificate_key <span class=\"string\">\"/usr/local/nginx/conf/2_huguobo.site.key\"</span>;</span><br><span class=\"line\">        ssl_session_cache shared:SSL:1m;</span><br><span class=\"line\">        ssl_session_timeout  10m;</span><br><span class=\"line\">        ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class=\"line\">        ssl_prefer_server_ciphers on;</span><br><span class=\"line\">        ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE; <span class=\"comment\">#请按照这个套件配置，配置加密套件，写法遵循 openssl 标准。</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># Load configuration files for the default server block.</span></span><br><span class=\"line\">        include /etc/nginx/default.d/*.conf;</span><br><span class=\"line\"></span><br><span class=\"line\">        location / &#123;</span><br><span class=\"line\">           root /home/hexoBlog; <span class=\"comment\"># your path</span></span><br><span class=\"line\">           index index.html;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        error_page 404 /404.html;</span><br><span class=\"line\">            location = /40x.html &#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        error_page 500 502 503 504 /50x.html;</span><br><span class=\"line\">            location = /50x.html &#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"强制HTTPS\"><a href=\"#强制HTTPS\" class=\"headerlink\" title=\"强制HTTPS\"></a>强制HTTPS</h2><p>我没有做强制https。但是需要的话，改下 nginx 配置文件即可<br>http 默认是<code>80</code>端口 ，https 是<code>443</code>端口</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server&#123;</span><br><span class=\"line\">      listen 80;    <span class=\"comment\">#表示监听80端口</span></span><br><span class=\"line\">      server_name huguobo.site</span><br><span class=\"line\">      location / &#123;    <span class=\"comment\">#将80端口强制转为https</span></span><br><span class=\"line\">          rewrite (.*) https://huguobo.site<span class=\"variable\">$1</span> permanent;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>域名貌似备案成功了，解析到腾讯云服务器ip后，发现直接访问 http协议 是可以的 换成 https 不行了。应该是没有配置SSL导致的。</p>\n</blockquote>\n<h2 id=\"什么是HTTPS\"><a href=\"#什么是HTTPS\" class=\"headerlink\" title=\"什么是HTTPS\"></a>什么是HTTPS</h2><p>https 全称：Hyper Text Transfer Protocol over Secure Socket Layer，是http的安全版。即http下加入SSL协议层，因此https的安全基础就是SSL，所以加密内容需要SSL。</p>\n<h2 id=\"SSL原理\"><a href=\"#SSL原理\" class=\"headerlink\" title=\"SSL原理\"></a>SSL原理</h2><ul>\n<li>浏览器发送一个https的请求给服务器；</li>\n<li>服务器要有一套数字证书，可以自己制作，也可以向组织申请，区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面，这套证书其实就是一对公钥和私钥；</li>\n<li>服务器会把公钥传输给客户端；</li>\n<li>客户端（浏览器）收到公钥后，会验证其是否合法有效，无效会有警告提醒，有效则会生成一串随机数，并用收到的公钥加密；</li>\n<li>客户端把加密后的随机字符串传输给服务器；</li>\n<li>服务器收到加密随机字符串后，先用私钥解密（公钥加密，私钥解密），获取到这一串随机数后，再用这串随机字符串加密传输的数据（该加密为对称加密，所谓对称加密，就是将数据和私钥也就是这个随机字符串&gt;通过某种算法混合在一起，这样除非知道私钥，否则无法获取数据内容）；</li>\n<li>服务器把加密后的数据传输给客户端；</li>\n<li>客户端收到数据后，再用自己的私钥也就是那个随机字符串解密；</li>\n</ul>\n<h2 id=\"配置-with-http-ssl-module-模块\"><a href=\"#配置-with-http-ssl-module-模块\" class=\"headerlink\" title=\"配置 with-http_ssl_module 模块\"></a>配置 with-http_ssl_module 模块</h2><p>首先需要申请一个证书，可以申请一个免费的。<br>参考下面的 <code>其他方式</code> 部分可以直接在云服务厂商可视化界面申请并下载~<br>然后会得到nginx版本证书，一个公钥（证书），一个私钥，将其上传到服务器。</p>\n<p>先确认<code>nginx</code>安装时已编译<code>http_ssl</code>模块，也就是执行<code>nginx -V</code>命令查看是否存在 <code>--with-http_ssl_module</code>。如果没有，则需要重新编译nginx将该模块加入。<br>若有的话此步骤跳过<br>若ssl模块没有先编译一下</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> /usr/<span class=\"built_in\">local</span>/src/nginx-1.12.1/  <span class=\"comment\">#nginx版本号可能不同哟</span></span><br><span class=\"line\"></span><br><span class=\"line\">./configure --<span class=\"built_in\">help</span> | grep -i ssl</span><br><span class=\"line\">  --with-http_ssl_module </span><br><span class=\"line\">  </span><br><span class=\"line\">./configure --prefix=/usr/<span class=\"built_in\">local</span>/nginx --with-http_ssl_module</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"生成-ssl-秘钥对\"><a href=\"#生成-ssl-秘钥对\" class=\"headerlink\" title=\"生成 ssl 秘钥对\"></a>生成 ssl 秘钥对</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> /usr/<span class=\"built_in\">local</span>/nginx/conf</span><br><span class=\"line\"></span><br><span class=\"line\">yum install -y openssl</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用RSA算法生产key\"><a href=\"#使用RSA算法生产key\" class=\"headerlink\" title=\"使用RSA算法生产key\"></a>使用RSA算法生产key</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">openssl genrsa -des3 -out tmp.key 2048</span><br><span class=\"line\"><span class=\"comment\"># 生成一个rsa类型的密钥，且长度为2048，但是我们有发现，让我们设置密码，如果每次有人访问我们的站点，都需要输入密码，太麻烦了</span></span><br></pre></td></tr></table></figure>\n\n<p>所以我们要转换私钥，取消密码（其实tmp.key与zhdy.key密钥内容是一样的，只不过一个有密码一个没有）：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">openssl rsa -<span class=\"keyword\">in</span> tmp.key -out zhdy.key </span><br><span class=\"line\"></span><br><span class=\"line\">rm -f tmp.key</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"创建证书申请\"><a href=\"#创建证书申请\" class=\"headerlink\" title=\"创建证书申请\"></a>创建证书申请</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">openssl req -new -key zhdy.key -out zhdy.csr</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"创建自签名的证书\"><a href=\"#创建自签名的证书\" class=\"headerlink\" title=\"创建自签名的证书\"></a>创建自签名的证书</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">openssl x509 -req -days 365 -<span class=\"keyword\">in</span> zhdy.csr -signkey zhdy.key -out zhdy.crt</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Nginx-配置-ssl\"><a href=\"#Nginx-配置-ssl\" class=\"headerlink\" title=\"Nginx 配置 ssl\"></a>Nginx 配置 ssl</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    listen 443;</span><br><span class=\"line\">    server_name huguobo.site; <span class=\"comment\"># 换成你自己的域名服务哟</span></span><br><span class=\"line\">    index index.html index.php;</span><br><span class=\"line\">    root /path/to/your/file </span><br><span class=\"line\">    ssl on;</span><br><span class=\"line\">    ssl_certificate zhdy.crt;</span><br><span class=\"line\">    ssl_certificate_key zhdy.key;</span><br><span class=\"line\">    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># ssl on; 代表着打开ssl</span></span><br><span class=\"line\"><span class=\"comment\">#ssl_certificate zhdy.crt; 公钥</span></span><br><span class=\"line\"><span class=\"comment\"># ssl_certificate_key zhdy.key; 私钥</span></span><br><span class=\"line\"><span class=\"comment\"># ssl_protocols TLSv1 TLSv1.1 TLSv1.2; 三种不同的协议</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nginx -t</span><br><span class=\"line\">nginx restart</span><br></pre></td></tr></table></figure>\n\n<p>由于已经设置了443，所以我们使用curl -x 是不生效的。<br>我们修改下/etc/hosts为: <code>yourip www.aaa.com</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl https://haha.com</span><br></pre></td></tr></table></figure>\n\n<p>报错显示为“此证书非安全证书”，但是ssl是已经成功配置了</p>\n<h2 id=\"其他方式（更快捷）\"><a href=\"#其他方式（更快捷）\" class=\"headerlink\" title=\"其他方式（更快捷）\"></a>其他方式（更快捷）</h2><p>后来发现各个厂商也提供申请证书的入口，也提供 DNS 和 文件验证两种配置,大家也可以自行参考配置<br><a href=\"https://console.cloud.tencent.com/ssl\" target=\"_blank\" rel=\"noopener\">腾讯云ssl控制台</a><br><a href=\"https://cloud.tencent.com/document/product/400/35244\" target=\"_blank\" rel=\"noopener\">nginx配置文档</a></p>\n<p>这种从供应商处可以直接下载到证书，然后nginx的配置秘钥和证书都在 nginx 文件夹下</p>\n<p>从客户端传送文件到云主机（MAC）</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scp  ./2_huguobo.site.key ./1_huguobo.site_bundle.crt  root@118.24.215.220:/usr/<span class=\"built_in\">local</span>/nginx/conf</span><br></pre></td></tr></table></figure>\n\n<p>登录云主机 nginx 配置</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Settings for a TLS enabled server.</span></span><br><span class=\"line\"></span><br><span class=\"line\">    server &#123;</span><br><span class=\"line\">        listen       443 ssl http2 default_server;</span><br><span class=\"line\">        listen       [::]:443 ssl http2 default_server;</span><br><span class=\"line\">        server_name  huguobo.site;</span><br><span class=\"line\"></span><br><span class=\"line\">        ssl on;</span><br><span class=\"line\">        ssl_certificate <span class=\"string\">\"/usr/local/nginx/conf/1_huguobo.site_bundle.crt\"</span>;</span><br><span class=\"line\">        ssl_certificate_key <span class=\"string\">\"/usr/local/nginx/conf/2_huguobo.site.key\"</span>;</span><br><span class=\"line\">        ssl_session_cache shared:SSL:1m;</span><br><span class=\"line\">        ssl_session_timeout  10m;</span><br><span class=\"line\">        ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class=\"line\">        ssl_prefer_server_ciphers on;</span><br><span class=\"line\">        ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE; <span class=\"comment\">#请按照这个套件配置，配置加密套件，写法遵循 openssl 标准。</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># Load configuration files for the default server block.</span></span><br><span class=\"line\">        include /etc/nginx/default.d/*.conf;</span><br><span class=\"line\"></span><br><span class=\"line\">        location / &#123;</span><br><span class=\"line\">           root /home/hexoBlog; <span class=\"comment\"># your path</span></span><br><span class=\"line\">           index index.html;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        error_page 404 /404.html;</span><br><span class=\"line\">            location = /40x.html &#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        error_page 500 502 503 504 /50x.html;</span><br><span class=\"line\">            location = /50x.html &#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"强制HTTPS\"><a href=\"#强制HTTPS\" class=\"headerlink\" title=\"强制HTTPS\"></a>强制HTTPS</h2><p>我没有做强制https。但是需要的话，改下 nginx 配置文件即可<br>http 默认是<code>80</code>端口 ，https 是<code>443</code>端口</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server&#123;</span><br><span class=\"line\">      listen 80;    <span class=\"comment\">#表示监听80端口</span></span><br><span class=\"line\">      server_name huguobo.site</span><br><span class=\"line\">      location / &#123;    <span class=\"comment\">#将80端口强制转为https</span></span><br><span class=\"line\">          rewrite (.*) https://huguobo.site<span class=\"variable\">$1</span> permanent;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n"}],"PostAsset":[],"PostCategory":[{"post_id":"ck0wfvhpz0005uhoxl2oa99tu","category_id":"ck0wfvhpx0002uhox59huamsw","_id":"ck0wfvhq20009uhox1dond0fn"},{"post_id":"ck0wfvhps0000uhoxm4zeu14s","category_id":"ck0wfvhpx0002uhox59huamsw","_id":"ck0wfvhq3000cuhoxf00g2bih"},{"post_id":"ck0wfvhq00006uhoxjhr6uleb","category_id":"ck0wfvhpx0002uhox59huamsw","_id":"ck0wfvhq3000euhoxt456t75i"},{"post_id":"ck0wfvhpv0001uhoxds59cq9t","category_id":"ck0wfvhq10007uhox4jnzsuk8","_id":"ck0wfvhq3000huhox4vfci91s"},{"post_id":"ck0wfvhpy0004uhoxve5se6ml","category_id":"ck0wfvhq2000auhoxx391gi8r","_id":"ck0wfvhq4000iuhox1aim0144"},{"post_id":"ck0wfvhqz000yuhoxayzruv6f","category_id":"ck0wfvhpx0002uhox59huamsw","_id":"ck0wfvhr50017uhoxlfzca2m2"},{"post_id":"ck0wfvhr30013uhoxw2u65v7z","category_id":"ck0wfvhq10007uhox4jnzsuk8","_id":"ck0wfvhr70018uhox7wckdv0u"},{"post_id":"ck0wfvhr50016uhoxshn903qm","category_id":"ck0wfvhq10007uhox4jnzsuk8","_id":"ck0wfvhr7001auhox2geoi5pm"},{"post_id":"ck0wfvhr10010uhoxr0jffggo","category_id":"ck0wfvhr40014uhox3l59jkwb","_id":"ck0wfvhr7001buhox5vo2rmin"}],"PostTag":[{"post_id":"ck0wfvhps0000uhoxm4zeu14s","tag_id":"ck0wfvhpy0003uhoxbo81kvea","_id":"ck0wfvhq3000duhox1vmxy9a0"},{"post_id":"ck0wfvhps0000uhoxm4zeu14s","tag_id":"ck0wfvhq10008uhox11zbwdg9","_id":"ck0wfvhq3000fuhoxomsmy7pp"},{"post_id":"ck0wfvhpv0001uhoxds59cq9t","tag_id":"ck0wfvhq2000buhoxhzw2ufr3","_id":"ck0wfvhq5000muhox2okwc4h3"},{"post_id":"ck0wfvhpv0001uhoxds59cq9t","tag_id":"ck0wfvhq3000guhox9n40z4ry","_id":"ck0wfvhq5000nuhoxhjcabfjo"},{"post_id":"ck0wfvhpv0001uhoxds59cq9t","tag_id":"ck0wfvhq5000juhoxv8dquf40","_id":"ck0wfvhq6000puhox03q7hf7t"},{"post_id":"ck0wfvhpv0001uhoxds59cq9t","tag_id":"ck0wfvhq5000kuhox91dn832f","_id":"ck0wfvhq6000quhoxuiutm7n9"},{"post_id":"ck0wfvhpy0004uhoxve5se6ml","tag_id":"ck0wfvhq5000luhoxkg1r6so6","_id":"ck0wfvhq6000suhoxly0bgdc6"},{"post_id":"ck0wfvhpz0005uhoxl2oa99tu","tag_id":"ck0wfvhq5000ouhox1wa8v6ko","_id":"ck0wfvhq6000uuhoxjvfufawe"},{"post_id":"ck0wfvhpz0005uhoxl2oa99tu","tag_id":"ck0wfvhq6000ruhox1qnwhe4v","_id":"ck0wfvhq6000vuhoxbattrdxe"},{"post_id":"ck0wfvhq00006uhoxjhr6uleb","tag_id":"ck0wfvhpy0003uhoxbo81kvea","_id":"ck0wfvhq7000wuhox994mbnsg"},{"post_id":"ck0wfvhq00006uhoxjhr6uleb","tag_id":"ck0wfvhq6000tuhoxmv1b13lp","_id":"ck0wfvhq7000xuhoxbx8j10xb"},{"post_id":"ck0wfvhqz000yuhoxayzruv6f","tag_id":"ck0wfvhq6000tuhoxmv1b13lp","_id":"ck0wfvhr30012uhox1tdhhk0m"},{"post_id":"ck0wfvhr10010uhoxr0jffggo","tag_id":"ck0wfvhr40015uhoxbaweosa3","_id":"ck0wfvhr8001euhox9tf6518o"},{"post_id":"ck0wfvhr10010uhoxr0jffggo","tag_id":"ck0wfvhr70019uhoxe5c9hp8t","_id":"ck0wfvhra001fuhoxzzw7g9ht"},{"post_id":"ck0wfvhr10010uhoxr0jffggo","tag_id":"ck0wfvhr7001cuhoxlvj0j8j8","_id":"ck0wfvhra001huhoxuv020klg"},{"post_id":"ck0wfvhr30013uhoxw2u65v7z","tag_id":"ck0wfvhr8001duhoxp1wyqkr0","_id":"ck0wfvhrc001luhoxmmf16qqw"},{"post_id":"ck0wfvhr30013uhoxw2u65v7z","tag_id":"ck0wfvhra001guhox9ia2q3l8","_id":"ck0wfvhrc001muhoxjstjscjx"},{"post_id":"ck0wfvhr30013uhoxw2u65v7z","tag_id":"ck0wfvhrb001iuhoxcb10u40q","_id":"ck0wfvhrc001ouhoxowrmaqxj"},{"post_id":"ck0wfvhr30013uhoxw2u65v7z","tag_id":"ck0wfvhrb001juhoxxmaab1fw","_id":"ck0wfvhrc001puhoxqkw2ofiy"},{"post_id":"ck0wfvhr50016uhoxshn903qm","tag_id":"ck0wfvhrb001kuhoxs316o87u","_id":"ck0wfvhre001ruhoxgxagoxq1"},{"post_id":"ck0wfvhr50016uhoxshn903qm","tag_id":"ck0wfvhrc001nuhox9yu9f1kd","_id":"ck0wfvhre001suhox7ydtsbdr"},{"post_id":"ck0wfvhr50016uhoxshn903qm","tag_id":"ck0wfvhrb001iuhoxcb10u40q","_id":"ck0wfvhre001tuhoxm46d2cdl"}],"Tag":[{"name":"日常","_id":"ck0wfvhpy0003uhoxbo81kvea"},{"name":"思考","_id":"ck0wfvhq10008uhox11zbwdg9"},{"name":"travis","_id":"ck0wfvhq2000buhoxhzw2ufr3"},{"name":"CI","_id":"ck0wfvhq3000guhox9n40z4ry"},{"name":"hexo","_id":"ck0wfvhq5000juhoxv8dquf40"},{"name":"gem","_id":"ck0wfvhq5000kuhox91dn832f"},{"name":"NODE","_id":"ck0wfvhq5000luhoxkg1r6so6"},{"name":"HHKB","_id":"ck0wfvhq5000ouhox1wa8v6ko"},{"name":"keyboard","_id":"ck0wfvhq6000ruhox1qnwhe4v"},{"name":"白话","_id":"ck0wfvhq6000tuhoxmv1b13lp"},{"name":"scorllTop","_id":"ck0wfvhr40015uhoxbaweosa3"},{"name":"height","_id":"ck0wfvhr70019uhoxe5c9hp8t"},{"name":"width","_id":"ck0wfvhr7001cuhoxlvj0j8j8"},{"name":"SSH","_id":"ck0wfvhr8001duhoxp1wyqkr0"},{"name":"SSL","_id":"ck0wfvhra001guhox9ia2q3l8"},{"name":"Https","_id":"ck0wfvhrb001iuhoxcb10u40q"},{"name":"encrypt","_id":"ck0wfvhrb001juhoxxmaab1fw"},{"name":"nginx","_id":"ck0wfvhrb001kuhoxs316o87u"},{"name":"ssl","_id":"ck0wfvhrc001nuhox9yu9f1kd"}]}}