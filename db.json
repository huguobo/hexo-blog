{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/images/iv.png","path":"images/iv.png","modified":0,"renderable":0},{"_id":"source/images/encrypt.png","path":"images/encrypt.png","modified":0,"renderable":0},{"_id":"source/images/login.png","path":"images/login.png","modified":0,"renderable":0},{"_id":"source/images/success.png","path":"images/success.png","modified":0,"renderable":0},{"_id":"source/images/weekend.jpeg","path":"images/weekend.jpeg","modified":0,"renderable":0},{"_id":"themes/archer/source/assets/favicon.ico","path":"assets/favicon.ico","modified":0,"renderable":1},{"_id":"themes/archer/source/assets/algolia_logo.svg","path":"assets/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/archer/source/assets/loading.svg","path":"assets/loading.svg","modified":0,"renderable":1},{"_id":"themes/archer/source/avatar/logo.jpg","path":"avatar/logo.jpg","modified":0,"renderable":1},{"_id":"themes/archer/source/css/mobile.css","path":"css/mobile.css","modified":0,"renderable":1},{"_id":"themes/archer/source/assets/qr.png","path":"assets/qr.png","modified":0,"renderable":1},{"_id":"themes/archer/source/css/style.css","path":"css/style.css","modified":0,"renderable":1},{"_id":"themes/archer/source/font/Source Sans Pro.woff","path":"font/Source Sans Pro.woff","modified":0,"renderable":1},{"_id":"themes/archer/source/font/Source Sans Pro.woff2","path":"font/Source Sans Pro.woff2","modified":0,"renderable":1},{"_id":"themes/archer/source/lib/webfontloader.min.js","path":"lib/webfontloader.min.js","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/main.js","path":"scripts/main.js","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/search.js","path":"scripts/search.js","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/share.js","path":"scripts/share.js","modified":0,"renderable":1},{"_id":"source/images/travis.png","path":"images/travis.png","modified":0,"renderable":0},{"_id":"themes/archer/source/font/Oswald-Regular.ttf","path":"font/Oswald-Regular.ttf","modified":0,"renderable":1},{"_id":"themes/archer/source/font/SourceCodePro-Regular.ttf.woff","path":"font/SourceCodePro-Regular.ttf.woff","modified":0,"renderable":1},{"_id":"themes/archer/source/font/SourceCodePro-Regular.ttf.woff2","path":"font/SourceCodePro-Regular.ttf.woff2","modified":0,"renderable":1},{"_id":"themes/archer/source/intro/404-bg.jpg","path":"intro/404-bg.jpg","modified":0,"renderable":1},{"_id":"themes/archer/source/lib/jquery.min.js","path":"lib/jquery.min.js","modified":0,"renderable":1},{"_id":"themes/archer/source/avatar/avtar.jpg","path":"avatar/avtar.jpg","modified":0,"renderable":1},{"_id":"themes/archer/source/intro/about-bg.jpg","path":"intro/about-bg.jpg","modified":0,"renderable":1},{"_id":"themes/archer/source/intro/bg.jpg","path":"intro/bg.jpg","modified":0,"renderable":1},{"_id":"themes/archer/source/intro/post-bg.jpg","path":"intro/post-bg.jpg","modified":0,"renderable":1},{"_id":"themes/archer/source/intro/index-bg.jpg","path":"intro/index-bg.jpg","modified":0,"renderable":1}],"Cache":[{"_id":"themes/archer/.gitignore","hash":"e2d7fa953bade3b94ed1cab25ffcf442c7540433","modified":1566989305196},{"_id":"themes/archer/.gitattributes","hash":"82c1a621642d5b620275ae1ed59845c3f7015a64","modified":1566989305195},{"_id":"themes/archer/.eslintrc.json","hash":"35eeca97fa5a2d0c6d78ef1257c58f03c42d43df","modified":1566989305195},{"_id":"themes/archer/.prettierrc.js","hash":"875b0b95f6eb24a23e4ea83a75709b97897135e0","modified":1566989305196},{"_id":"themes/archer/.prettierignore","hash":"58caf761f07e5df9cdc21f7f19f0670fde41089b","modified":1566989305196},{"_id":"themes/archer/LICENSE","hash":"0da0c361bf299375739c6b668a44af0f5faf37bb","modified":1566989305196},{"_id":"themes/archer/README.md","hash":"97edb54cb7aecff714f132110ed4ba8215da7136","modified":1566989305197},{"_id":"themes/archer/_config.yml","hash":"bdb870dbbc5c90e9e01f502e2428cbc81da111fb","modified":1567240624770},{"_id":"themes/archer/gulpfile.js","hash":"46dfe693b00ac4dea4d1b1af56f5ced4ee095c10","modified":1566989305199},{"_id":"themes/archer/package.json","hash":"531fe40833ca63493f62adfa249b6434310a2d0a","modified":1566989305207},{"_id":"themes/archer/webpack.config.js","hash":"d20b6350c50e2981484cb9356a3e21a2124bcd72","modified":1566989305236},{"_id":"themes/archer/webpack.prod.js","hash":"48de76cfa6274895801d3afc89ecbf04ee182a1c","modified":1566989305236},{"_id":"source/_posts/sshLogin.md","hash":"1359e0ccc7a97442ca1dc767c0bbba041d1edb84","modified":1567491814101},{"_id":"source/_posts/nginx配置ssl.md","hash":"04e5b3e237d2e8a413ad5cfde9d9f94a4e1f042c","modified":1567422521495},{"_id":"source/_posts/weekend.md","hash":"ad4142aaf7a06ed2cee60af4e6131de225f8f9aa","modified":1567388247401},{"_id":"source/_posts/新网站.md","hash":"f23ae2c0f14c6ef9d9dc224f01d9e486bc0fe0f6","modified":1567388250425},{"_id":"source/about/index.md","hash":"31da4ed509e6c46b81eeb4b109a5ec6cb16deb3d","modified":1567159452263},{"_id":"source/_posts/Travis-CI持续集成Hexo到云服务器.md","hash":"7f4eb632843aa8a3b2d0ff9d8c4f66126364b595","modified":1567388221948},{"_id":"source/images/iv.png","hash":"06614226fd14f6f18c96133bfff6d3a4663c6f5f","modified":1567341098856},{"_id":"source/tags/index.md","hash":"594f738b83fedfa653d5c96da20510c8ea8b0de4","modified":1566911678021},{"_id":"themes/archer/dev/archer.sh","hash":"4065c4e55462d5ecf016464adea0d1db967ef4b4","modified":1566989305197},{"_id":"themes/archer/docs/README-en.md","hash":"f325565c0bb94501fd046268659c7752709895d1","modified":1566989305197},{"_id":"themes/archer/docs/develop-guide-en.md","hash":"0bb09c3c9d5f56820cb84e3316f60352b731d70c","modified":1566989305197},{"_id":"themes/archer/docs/develop-guide-zh.md","hash":"effc2bc9e0cecfd228b19283337ff29649ea5985","modified":1566989305197},{"_id":"themes/archer/languages/default.yml","hash":"d56b6923c70efdef09cd1f0270d7adc9cc338f6b","modified":1566989305199},{"_id":"themes/archer/languages/en.yml","hash":"ad75d3e5f7f5f0463d3077e1b5a26f40938a1faa","modified":1566989305199},{"_id":"themes/archer/layout/about.ejs","hash":"06019d835c0a51fed8aa086d1dfcf368f9921b42","modified":1566989305204},{"_id":"themes/archer/layout/layout.ejs","hash":"08ebd10c1b2bfc11be8f5115a836a98e6c6ba13c","modified":1566989305204},{"_id":"themes/archer/layout/404.ejs","hash":"879641b1b5e49c43f2e096cad281f7d74df05127","modified":1566989305200},{"_id":"themes/archer/layout/index.ejs","hash":"716ba4a30860e36077dfdfffa02c1cd60301d8a3","modified":1566989305204},{"_id":"themes/archer/layout/post.ejs","hash":"b61156aff41641a14d5e4e45d9fd776309f2801a","modified":1566989305204},{"_id":"themes/archer/layout/site-meta.ejs","hash":"d866aa1a892d4bfe3368f6dbd0f1baa8c5831947","modified":1566989305205},{"_id":"themes/archer/source/.DS_Store","hash":"930c6508268f48a80018d8abc30d3bec638b3a99","modified":1566994101548},{"_id":"source/images/encrypt.png","hash":"fd22fcba73ccc1eadade3e1323e4a240beea8913","modified":1567340650980},{"_id":"source/images/login.png","hash":"c2813d57bd6a01800858baf8ee561f5b366f3837","modified":1567340645957},{"_id":"themes/archer/.github/ISSUE_TEMPLATE/-----------bug--help-wanted-or-bug-report-.md","hash":"012bd3afea5565204f75d8c89048ad33b9c2f948","modified":1566989305195},{"_id":"themes/archer/.github/ISSUE_TEMPLATE/-----feature-request-.md","hash":"886fb1252702d46c89536b579d35ce49e53ec54d","modified":1566989305196},{"_id":"themes/archer/.github/ISSUE_TEMPLATE/-----other-issue-.md","hash":"4bf3c8ebef14a81bb55e8e0468d816e83c4133ac","modified":1566989305196},{"_id":"source/images/success.png","hash":"926c35dbd53f5354611b28eaf84b605f682d1698","modified":1567353433317},{"_id":"themes/archer/layout/_partial/algolia.ejs","hash":"2f5f9073378f628a9124792b5301c1540bc5a264","modified":1566989305200},{"_id":"themes/archer/layout/_partial/base-background-image.ejs","hash":"82203d9a1c6e16ef2d37b8b587f56bf6d16edaf2","modified":1566989305200},{"_id":"source/images/weekend.jpeg","hash":"e27bd6ad7cabf0957104cc143c209e8fdef5c428","modified":1567306494349},{"_id":"themes/archer/layout/_partial/base-footer.ejs","hash":"7bfb8af21f7d30780d1a3af5484760b07b4fbb1d","modified":1566989305200},{"_id":"themes/archer/layout/_partial/base-preload-polyfill.ejs","hash":"2aea84cb43f4479131620b3c3dfd7cebe9be36ba","modified":1566989305200},{"_id":"themes/archer/layout/_partial/base-head.ejs","hash":"f2e8d4dfd11d879491a4b10f74f8c886cd392240","modified":1566989305200},{"_id":"themes/archer/layout/_partial/base-header.ejs","hash":"12e28693dc53cab5f6fd389f15ea0f811c9c37e9","modified":1566989305200},{"_id":"themes/archer/layout/_partial/base-social.ejs","hash":"2d068432031b3bebf9438c775370a2d1b4492d6b","modified":1566989305201},{"_id":"themes/archer/layout/_partial/base-title-tags.ejs","hash":"418559ab11726f69621c3a58cd21903adff1e48e","modified":1566989305201},{"_id":"themes/archer/layout/_partial/base-profile.ejs","hash":"c5b34e7edd135f0c3970cd746263ed1679f41af4","modified":1567059592519},{"_id":"themes/archer/layout/_partial/intro-height.ejs","hash":"cd0d34a811dc4666980d57c00d70dd82bd5450eb","modified":1566989305202},{"_id":"themes/archer/source/assets/favicon.ico","hash":"f46fc2c74d1eca053022ce404ea79ee7b0ffb7af","modified":1567155394087},{"_id":"themes/archer/source/assets/algolia_logo.svg","hash":"90035272fa31a3f65b3c0e2cb8a633876ef457dc","modified":1566989305208},{"_id":"themes/archer/source/assets/loading.svg","hash":"45be17d07697d604d8981890eb21e308530c7a38","modified":1566989305208},{"_id":"themes/archer/source/avatar/logo.jpg","hash":"38450b286f7ec1a526fec5e557f58106e127eec9","modified":1567155568021},{"_id":"themes/archer/source/css/mobile.css","hash":"51d7b5cf26c8f82a3daad4bc55518673fdf281f5","modified":1566989305209},{"_id":"themes/archer/source/assets/qr.png","hash":"cfe2c27eeee47b5b25072167b19b56dd5f0134f3","modified":1566991188244},{"_id":"themes/archer/source/css/style.css","hash":"5d5e869db0c62957d59c6865baaecd1428c51804","modified":1566989305209},{"_id":"themes/archer/source/font/Source Sans Pro.woff","hash":"a6722c9b6439b7a020a9be3d3178970757a9265c","modified":1566989305211},{"_id":"themes/archer/source/font/Source Sans Pro.woff2","hash":"da65f527a8da65d5eb6721626d28cfdb46ab104a","modified":1566989305211},{"_id":"themes/archer/source/lib/webfontloader.min.js","hash":"bc6ffe9c0d8b3285564619a445c6ca575eb9d0f5","modified":1566989305221},{"_id":"themes/archer/source/scripts/main.js","hash":"e89a9651131684204118fa74bd19cb781d76a372","modified":1566989305221},{"_id":"themes/archer/source/scripts/search.js","hash":"d5f739e261e8ce74f993c6157b248663bda122bf","modified":1566989305222},{"_id":"themes/archer/src/js/browser.js","hash":"ce061db99db5b880db0ddb768246352ca885b13c","modified":1566989305224},{"_id":"themes/archer/src/js/fancybox.js","hash":"0daf0e83deca055102268e3bd95cb1962acc2264","modified":1566989305225},{"_id":"themes/archer/source/scripts/share.js","hash":"bb5bb37ce7f47f8c084b232df3e5fe2378d7ca01","modified":1566989305223},{"_id":"themes/archer/src/js/init.js","hash":"346c6ef75ae85e4350c1b0811985172fdaa0d3a5","modified":1566989305225},{"_id":"themes/archer/src/js/initSidebar.js","hash":"b25615ff254913db83e2a20263d445f35083843b","modified":1566989305225},{"_id":"themes/archer/src/js/main.js","hash":"e1a48d5822326792e38d44efee86e01473549eba","modified":1566989305226},{"_id":"themes/archer/src/js/mobile.js","hash":"228a68d851517b5e47d2132f1d499cb812a64171","modified":1566989305226},{"_id":"themes/archer/src/js/scroll.js","hash":"aa2315a80daaa183a7e462c7e879ff9d2f050933","modified":1566989305226},{"_id":"themes/archer/src/js/search.js","hash":"2e59ac745da7c22801d9029cf9904a4fc3c384f1","modified":1566989305227},{"_id":"themes/archer/src/js/share.js","hash":"1314b19a852e291e35d6809f7f58652d3e7c524c","modified":1566989305227},{"_id":"themes/archer/src/js/sidebar.js","hash":"68d5fe0ee5e86df810d304e5efe11e5e1fddc46d","modified":1566989305227},{"_id":"themes/archer/src/js/toc.js","hash":"b3482031e4c8728535d480bfaec76229469e3aba","modified":1566989305228},{"_id":"themes/archer/src/js/tag.js","hash":"e0f0a914c02922e42977d78dc4993b3855167cd8","modified":1566989305228},{"_id":"themes/archer/src/js/util.js","hash":"27de6446892bcf399430dd5776df0b8759ca0eea","modified":1566989305228},{"_id":"themes/archer/source/intro/.DS_Store","hash":"f2e2b1d02471a3df83adf04897c9afdb9b1d49b5","modified":1566994101546},{"_id":"themes/archer/src/scss/_common.scss","hash":"dedc313b082e0a16daf87213badd21b13be11af8","modified":1566989305228},{"_id":"themes/archer/src/scss/_mixin.scss","hash":"e7deb20a16868ae9d3e35ba3c5693de71fdf6999","modified":1566989305229},{"_id":"themes/archer/src/scss/_normalize.scss","hash":"a2dbeb38ad08bb8975856d75954cc697bf8e5ff7","modified":1566989305229},{"_id":"themes/archer/src/scss/_variables.scss","hash":"136e5d990c4f8eadf6cabdfa5a053941e90bcd20","modified":1566989305235},{"_id":"themes/archer/src/scss/mobile.scss","hash":"aadc2fbf37fefc2ad391d8172d5b61817f9db0c5","modified":1566989305235},{"_id":"themes/archer/src/scss/style.scss","hash":"78e31370d45089b97fa91929345f1a29f2e6a0a2","modified":1566989305235},{"_id":"source/images/travis.png","hash":"52333b84a76abf24152585bf0045b279ef3e0f35","modified":1567337141690},{"_id":"themes/archer/layout/_partial/comment/custom.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1566989305201},{"_id":"themes/archer/source/font/Oswald-Regular.ttf","hash":"965d729546a43a8490ad4cf33c25ac475682100c","modified":1566989305211},{"_id":"themes/archer/source/font/SourceCodePro-Regular.ttf.woff","hash":"12eef75e1ad3eca9dae42b65505010ce4464a315","modified":1566989305212},{"_id":"themes/archer/source/font/SourceCodePro-Regular.ttf.woff2","hash":"f5991289ec17884cb641da0646d278d36702a190","modified":1566989305213},{"_id":"themes/archer/source/intro/404-bg.jpg","hash":"3afb5bb26f4ff0bd0e0a28df955c8aa7d746d3c5","modified":1566989305214},{"_id":"themes/archer/source/lib/jquery.min.js","hash":"0dc32db4aa9c5f03f3b38c47d883dbd4fed13aae","modified":1566989305220},{"_id":"themes/archer/package-lock.json","hash":"89a3b67d32f6916cdc21d590d87e43d8a44be8c3","modified":1566989305207},{"_id":"themes/archer/layout/_partial/comment/changyan.ejs","hash":"7691642fb9375607e0ac988a7420999e242cb2c9","modified":1566989305201},{"_id":"themes/archer/layout/_partial/comment/disqus.ejs","hash":"cadd97820a23d01d8b7e2f19a86e5290cef5a8a6","modified":1566989305201},{"_id":"themes/archer/layout/_partial/comment/gitment.ejs","hash":"794647a8a4ac9e1d01d74c07717175a141b1e01c","modified":1566989305201},{"_id":"themes/archer/layout/_partial/comment/livere.ejs","hash":"b27469f19f35ec2037c7bce736a12e9dfb5e360b","modified":1566989305202},{"_id":"themes/archer/layout/_partial/comment/valine.ejs","hash":"2154360e330dab94540e168e9d301c7b7091968e","modified":1566989305202},{"_id":"themes/archer/layout/_partial/comment/youyan.ejs","hash":"790d76f2667377db78a7d04bad8d629e47e7aab0","modified":1566989305202},{"_id":"themes/archer/layout/_partial/script/font-loader.ejs","hash":"291cc0a4a444a93b93c32e2c39383c70e36e46de","modified":1566989305202},{"_id":"themes/archer/layout/_partial/sidebar/base-sidebar.ejs","hash":"2d38af7cb5aabc0af99de239bd180c516ec4c56c","modified":1566989305203},{"_id":"themes/archer/layout/_partial/sidebar/sidebar-archives.ejs","hash":"daa78b17a773bca569f1c8ca2c916495ca138da6","modified":1566989305203},{"_id":"themes/archer/layout/_partial/sidebar/sidebar-categories.ejs","hash":"147214469c4909eb94943599883f9fa0f3cc090d","modified":1566989305203},{"_id":"themes/archer/layout/_partial/critical-css/critical-style.ejs","hash":"bbad4bf73858f50e99eb678d966cd6ee1d534408","modified":1566992802836},{"_id":"themes/archer/layout/_partial/sidebar/sidebar-tags.ejs","hash":"d6e1a192cac5dcf365ce1a52df4f23feafeeb849","modified":1566989305203},{"_id":"themes/archer/source/avatar/avtar.jpg","hash":"8d693792ba6e95b9eeefcfd62cb30e4ad91af519","modified":1566993846251},{"_id":"themes/archer/src/scss/_partial/_404.scss","hash":"a2b56f441a9a44d7f5b9b41eaa8136321328d7e9","modified":1566989305229},{"_id":"themes/archer/src/scss/_partial/_index-page.scss","hash":"fa993cf0bbe0086cd8ec3d9a639b2d5b28ccfa8e","modified":1566989305230},{"_id":"themes/archer/src/scss/_partial/_algolia.scss","hash":"c679578d2feb0bd7d3f80c2f693ba58cbca4428b","modified":1566989305230},{"_id":"themes/archer/src/scss/_partial/_post-page.scss","hash":"7c557844850d53cc4fc36aaf6d59847d8f238947","modified":1566989305232},{"_id":"themes/archer/docs/snap.png","hash":"0b2a8bf016f6eed576abfdcdb7dcf8de51c12562","modified":1566989305199},{"_id":"themes/archer/source/intro/about-bg.jpg","hash":"ab388276822417cc4e703312c14e20280ec783b3","modified":1566989305216},{"_id":"themes/archer/source/intro/bg.jpg","hash":"f028bd23507f9ef5d3aa2aec1913fccfa4e674d9","modified":1566993760559},{"_id":"themes/archer/source/intro/post-bg.jpg","hash":"525fafb2238c27754d8fa751f143ff1de9b8482d","modified":1566989305220},{"_id":"themes/archer/src/scss/_partial/_partial/_footer.scss","hash":"726c543ee066e0b3222b236d9b4ef0109c0bdddf","modified":1566989305230},{"_id":"themes/archer/src/scss/_partial/_partial/_paginator.scss","hash":"67c2e697a5fbb3b8006cf358ea45eb7f75b496f8","modified":1566989305231},{"_id":"themes/archer/src/scss/_partial/_partial/_header.scss","hash":"77003ff22b1a10fae2d2768938277959b3f93a72","modified":1566989305230},{"_id":"themes/archer/src/scss/_partial/_partial/_intro.scss","hash":"a1569f39eccd64a12425d81b794c53df126a4d87","modified":1566989305231},{"_id":"themes/archer/src/scss/_partial/_partial/_scrollbar.scss","hash":"f2514031f9d7e4ed4a126694e78618ce6ff3a574","modified":1566989305232},{"_id":"themes/archer/src/scss/_partial/_partial/_profile.scss","hash":"0c986b52ce9083f08c37c5c9b5de045ac5e1d2fa","modified":1566989305231},{"_id":"themes/archer/src/scss/_partial/_post/_code.scss","hash":"9c9a4e470da8732c9a3be3d5ce0d2f80f53714fe","modified":1566989305233},{"_id":"themes/archer/src/scss/_partial/_sidebar/_sidebar.scss","hash":"981a94978535769cb51c29e12b627f83c6fcedc5","modified":1566989305234},{"_id":"themes/archer/src/scss/_partial/_sidebar/_sidebar-archive.scss","hash":"14bc42292873880c61b5fa9f47ee9d2e08d46871","modified":1566989305233},{"_id":"themes/archer/src/scss/_partial/_sidebar/_sidebar-tags.scss","hash":"9ab6f96d0df0c4ad4c72e2515fa2599d487d8f1a","modified":1566989305234},{"_id":"themes/archer/source/intro/index-bg.jpg","hash":"96b52e177b8bc53e64ec6ee1e10b2b6a4e13083b","modified":1566989305218}],"Category":[{"name":"HTTPS","_id":"ck03fz4ah0004oloxj3nwuoan"},{"name":"Nginx","_id":"ck03fz4al0009olox14vi2qbo"},{"name":"daily","_id":"ck03fz4am000bolox6vd3vdcm"},{"name":"encrypt","parent":"ck03fz4ah0004oloxj3nwuoan","_id":"ck03fz4ap000ioloxaoa3ruhi"},{"name":"CI","_id":"ck03fz4aq000nolox0vj39cq6"}],"Data":[],"Page":[{"title":"I'm Cooper","date":"2019-08-29T06:58:14.000Z","layout":"about","_content":"\n> 在我一生的黄金时代，我有好多奢望。\n> 我想爱，想吃，还想在一瞬间变成天上半明半暗的云。\n> 后来我才知道，生活就是个缓慢受锤的过程。\n> 人一天天老下去，奢望也一天天消失，最后变得像挨了锤的牛一样。\n> 我希望自己会永远生猛下去，什么也锤不了我。 \n\n## 靓仔\n<img src=\"https://github.com/huguobo/public/blob/master/avtar.jpg?raw=true\" width=\"25%\" style=\"margin: 0\">\n\n## 基本信息\n- 男\n- 性格开朗\n- 1992 年生人\n\n## 学习生涯\n- 吉林大学\n- 软件工程\n- 硕士\n\n## 职业信息\n- 前端工程师(全干工程师)\n\n### 工作经历\n- 2017.7 ~ 2019.7 [美团点评](https://about.meituan.com/home) \n- 2019.8 ~ 至今 [腾讯科技](https://www.tencent.com/zh-cn/index.html)\n\n### 技能（别问，问就是‘熟悉’）\n- Javascript、Css 和 HTML 基础3件套\n- 基于 React、Vue 等的流行前端框架\n- webpack、gulp 等前端工程化工具\n- 前端 CI/CD 流程，基础 devOps\n- Node\n- Koa、Express 等 node 前端框架\n- Mysql curd\n- git、shell、nginx 等基础工具\n\n## 状态\n- 在职\n- 身体还算健康\n- 心理非常健康\n- 价值观很正\n\n## 爱好\n- 主机游戏\n- 旅行\n- 🏀\n- 发呆\n\n## 其他\n- 小语种学习中\n\n","source":"about/index.md","raw":"---\ntitle: I'm Cooper\ndate: 2019-08-29 14:58:14\nlayout: about\n---\n\n> 在我一生的黄金时代，我有好多奢望。\n> 我想爱，想吃，还想在一瞬间变成天上半明半暗的云。\n> 后来我才知道，生活就是个缓慢受锤的过程。\n> 人一天天老下去，奢望也一天天消失，最后变得像挨了锤的牛一样。\n> 我希望自己会永远生猛下去，什么也锤不了我。 \n\n## 靓仔\n<img src=\"https://github.com/huguobo/public/blob/master/avtar.jpg?raw=true\" width=\"25%\" style=\"margin: 0\">\n\n## 基本信息\n- 男\n- 性格开朗\n- 1992 年生人\n\n## 学习生涯\n- 吉林大学\n- 软件工程\n- 硕士\n\n## 职业信息\n- 前端工程师(全干工程师)\n\n### 工作经历\n- 2017.7 ~ 2019.7 [美团点评](https://about.meituan.com/home) \n- 2019.8 ~ 至今 [腾讯科技](https://www.tencent.com/zh-cn/index.html)\n\n### 技能（别问，问就是‘熟悉’）\n- Javascript、Css 和 HTML 基础3件套\n- 基于 React、Vue 等的流行前端框架\n- webpack、gulp 等前端工程化工具\n- 前端 CI/CD 流程，基础 devOps\n- Node\n- Koa、Express 等 node 前端框架\n- Mysql curd\n- git、shell、nginx 等基础工具\n\n## 状态\n- 在职\n- 身体还算健康\n- 心理非常健康\n- 价值观很正\n\n## 爱好\n- 主机游戏\n- 旅行\n- 🏀\n- 发呆\n\n## 其他\n- 小语种学习中\n\n","updated":"2019-08-30T10:04:12.263Z","path":"about/index.html","comments":1,"_id":"ck03fz4af0001oloxzu3x7hl2","content":"<blockquote>\n<p>在我一生的黄金时代，我有好多奢望。<br>我想爱，想吃，还想在一瞬间变成天上半明半暗的云。<br>后来我才知道，生活就是个缓慢受锤的过程。<br>人一天天老下去，奢望也一天天消失，最后变得像挨了锤的牛一样。<br>我希望自己会永远生猛下去，什么也锤不了我。 </p>\n</blockquote>\n<h2 id=\"靓仔\"><a href=\"#靓仔\" class=\"headerlink\" title=\"靓仔\"></a>靓仔</h2><img src=\"https://github.com/huguobo/public/blob/master/avtar.jpg?raw=true\" width=\"25%\" style=\"margin: 0\">\n\n<h2 id=\"基本信息\"><a href=\"#基本信息\" class=\"headerlink\" title=\"基本信息\"></a>基本信息</h2><ul>\n<li>男</li>\n<li>性格开朗</li>\n<li>1992 年生人</li>\n</ul>\n<h2 id=\"学习生涯\"><a href=\"#学习生涯\" class=\"headerlink\" title=\"学习生涯\"></a>学习生涯</h2><ul>\n<li>吉林大学</li>\n<li>软件工程</li>\n<li>硕士</li>\n</ul>\n<h2 id=\"职业信息\"><a href=\"#职业信息\" class=\"headerlink\" title=\"职业信息\"></a>职业信息</h2><ul>\n<li>前端工程师(全干工程师)</li>\n</ul>\n<h3 id=\"工作经历\"><a href=\"#工作经历\" class=\"headerlink\" title=\"工作经历\"></a>工作经历</h3><ul>\n<li>2017.7 ~ 2019.7 <a href=\"https://about.meituan.com/home\" target=\"_blank\" rel=\"noopener\">美团点评</a> </li>\n<li>2019.8 ~ 至今 <a href=\"https://www.tencent.com/zh-cn/index.html\" target=\"_blank\" rel=\"noopener\">腾讯科技</a></li>\n</ul>\n<h3 id=\"技能（别问，问就是‘熟悉’）\"><a href=\"#技能（别问，问就是‘熟悉’）\" class=\"headerlink\" title=\"技能（别问，问就是‘熟悉’）\"></a>技能（别问，问就是‘熟悉’）</h3><ul>\n<li>Javascript、Css 和 HTML 基础3件套</li>\n<li>基于 React、Vue 等的流行前端框架</li>\n<li>webpack、gulp 等前端工程化工具</li>\n<li>前端 CI/CD 流程，基础 devOps</li>\n<li>Node</li>\n<li>Koa、Express 等 node 前端框架</li>\n<li>Mysql curd</li>\n<li>git、shell、nginx 等基础工具</li>\n</ul>\n<h2 id=\"状态\"><a href=\"#状态\" class=\"headerlink\" title=\"状态\"></a>状态</h2><ul>\n<li>在职</li>\n<li>身体还算健康</li>\n<li>心理非常健康</li>\n<li>价值观很正</li>\n</ul>\n<h2 id=\"爱好\"><a href=\"#爱好\" class=\"headerlink\" title=\"爱好\"></a>爱好</h2><ul>\n<li>主机游戏</li>\n<li>旅行</li>\n<li>🏀</li>\n<li>发呆</li>\n</ul>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><ul>\n<li>小语种学习中</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>在我一生的黄金时代，我有好多奢望。<br>我想爱，想吃，还想在一瞬间变成天上半明半暗的云。<br>后来我才知道，生活就是个缓慢受锤的过程。<br>人一天天老下去，奢望也一天天消失，最后变得像挨了锤的牛一样。<br>我希望自己会永远生猛下去，什么也锤不了我。 </p>\n</blockquote>\n<h2 id=\"靓仔\"><a href=\"#靓仔\" class=\"headerlink\" title=\"靓仔\"></a>靓仔</h2><img src=\"https://github.com/huguobo/public/blob/master/avtar.jpg?raw=true\" width=\"25%\" style=\"margin: 0\">\n\n<h2 id=\"基本信息\"><a href=\"#基本信息\" class=\"headerlink\" title=\"基本信息\"></a>基本信息</h2><ul>\n<li>男</li>\n<li>性格开朗</li>\n<li>1992 年生人</li>\n</ul>\n<h2 id=\"学习生涯\"><a href=\"#学习生涯\" class=\"headerlink\" title=\"学习生涯\"></a>学习生涯</h2><ul>\n<li>吉林大学</li>\n<li>软件工程</li>\n<li>硕士</li>\n</ul>\n<h2 id=\"职业信息\"><a href=\"#职业信息\" class=\"headerlink\" title=\"职业信息\"></a>职业信息</h2><ul>\n<li>前端工程师(全干工程师)</li>\n</ul>\n<h3 id=\"工作经历\"><a href=\"#工作经历\" class=\"headerlink\" title=\"工作经历\"></a>工作经历</h3><ul>\n<li>2017.7 ~ 2019.7 <a href=\"https://about.meituan.com/home\" target=\"_blank\" rel=\"noopener\">美团点评</a> </li>\n<li>2019.8 ~ 至今 <a href=\"https://www.tencent.com/zh-cn/index.html\" target=\"_blank\" rel=\"noopener\">腾讯科技</a></li>\n</ul>\n<h3 id=\"技能（别问，问就是‘熟悉’）\"><a href=\"#技能（别问，问就是‘熟悉’）\" class=\"headerlink\" title=\"技能（别问，问就是‘熟悉’）\"></a>技能（别问，问就是‘熟悉’）</h3><ul>\n<li>Javascript、Css 和 HTML 基础3件套</li>\n<li>基于 React、Vue 等的流行前端框架</li>\n<li>webpack、gulp 等前端工程化工具</li>\n<li>前端 CI/CD 流程，基础 devOps</li>\n<li>Node</li>\n<li>Koa、Express 等 node 前端框架</li>\n<li>Mysql curd</li>\n<li>git、shell、nginx 等基础工具</li>\n</ul>\n<h2 id=\"状态\"><a href=\"#状态\" class=\"headerlink\" title=\"状态\"></a>状态</h2><ul>\n<li>在职</li>\n<li>身体还算健康</li>\n<li>心理非常健康</li>\n<li>价值观很正</li>\n</ul>\n<h2 id=\"爱好\"><a href=\"#爱好\" class=\"headerlink\" title=\"爱好\"></a>爱好</h2><ul>\n<li>主机游戏</li>\n<li>旅行</li>\n<li>🏀</li>\n<li>发呆</li>\n</ul>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><ul>\n<li>小语种学习中</li>\n</ul>\n"},{"title":"tags","date":"2019-08-27T13:13:30.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2019-08-27 21:13:30\ntype: \"tags\"\n---\n","updated":"2019-08-27T13:14:38.021Z","path":"tags/index.html","comments":1,"layout":"page","_id":"ck03fz4ag0003olox68kc21j9","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"SSH、SSL 和 HTTPS","date":"2019-09-03T02:56:46.000Z","_content":"\n> 一直对 SSH 、SSL 以及 HTTPS 跟它们的关系都云里雾里的，下面参考网上的文章和自己的理解梳理一下，晕了就再回来看一下，总会记住的。\n\n## 加密算法\n首先先说下加密算法，可以分为两大类，`对称加密` 和 `非对称加密`。\n### 对称加密\n通信双方的数据都是用同一套秘钥来进行加密和解密。\n在1976年以前，所有的加密都采用对称加密，这种加密方式最大的问题就是如何管理秘钥？既要保证秘钥不泄露，同时还要在保证秘钥的共享性。\n### 非对称加密\n1976年有两位数学家提出的一个新的加密概念：\n1. A生成一对两把密钥（公钥和私钥）。\n2. B获取A生成的公钥，然后用公钥对信息加密。\n3. A收到B的加密信息后，用自己的私钥解密。\n\n非对称加密引入了公钥和私钥的概念。公钥加密，私钥解密（公钥加密，私钥解密）。公钥是面向所有使用者公开的。\n目前计算机领域使用最广泛的非对称加密算法是[RSA](https://zh.wikipedia.org/wiki/RSA%E5%8A%A0%E5%AF%86%E6%BC%94%E7%AE%97%E6%B3%95)。\n\n对称加密看起来很强大，但是也有缺点：\n\n- 加密更耗时：算法更复杂。\n- 容易受到中间人攻击:即如果有C冒充A利用A的公钥给B发消息，B的所有消息对C其实就是透明的了。\n  \n针对中间人攻击，一般就采用非对称加密+摘要算法+数字签名的机制来确保传输安全。\n### 摘要算法（hash算法）\nHash 算法的特点是单向不可逆。利用这个特性，可以通过hash对目前信息加密生成特定长度且唯一的hash值，该值也不能被逆向破译。因此hash算法进场用在不可还原的密码存储、信息完整性校验等领域。\n常见的hash算法：MD2，MD4，MD5，SHA等\n\n### 数字签名\n数字签名，是为了保证信息在传输过程中没有被篡改。\n使用hash算法生成要发送明文的摘要，然后 把明文和摘要都通过私钥加密，加密后的摘要作为`数字签名（digital signature）`跟加密后的内容一起发送给接受者。\n接受者收到数据信息后，使用公钥分别对内容和信息解密，得到数据和内容摘要，然后用一样的算法对内容生成摘要，比较摘要是否相同来确认信息的完整性。\n\n### 数字证书\n以上的流程还是存在一个问题就是，有人冒充通信人发放公钥。这种场景的出现，我们就需要有个公证人了，告诉我们到底有是真的注册登记过的。\n这个公证人就是证书中心（certificate authority）简称CA。\n所有想发放公钥的人，都需要去CA为自己的公钥做认证。证书中心会用自己私钥和公钥以及公钥人信息一起进行加密，生成的东西就叫数字证书。\n以后所有类似的场景，都是统一用CA的公钥解开数字证书，拿到通信用的公钥，然后证明数字签名确实是来自哪里的了。\n\n\n关于数字签名和数字证书，阮一峰老师的这篇文章讲的特别生动[blog](http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html)\n\n## SSH\nwiki上对SSH的定义:\n>Secure Shell（缩写为SSH），由IETF的网络工作小组（Network Working Group）所制定；SSH为一项创建在应用层和传输层基础上的安全协议，为计算机上的Shell（壳层）提供安全的传输和使用环境。\n>传统的网络服务程序，如rsh、FTP、POP和Telnet其本质上都是不安全的；因为它们在网络上用明文传送数据、用户帐号和用户口令，很容易受到中间人（man-in-the-middle）攻击方式的攻击。就是存在另一个>人或者一台机器冒充真正的服务器接收用户传给服务器的数据，然后再冒充用户把数据传给真正的服务器。\n>而SSH是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用SSH协议可以有效防止远程管理过程中的信息泄露问题。通过SSH可以对所有传输的数据进行加密，也能够防止DNS欺骗和IP欺骗。\n>SSH之另一项优点为其传输的数据可以是经过压缩的，所以可以加快传输的速度。SSH有很多功能，它既可以代替Telnet，又可以为FTP、POP、甚至为PPP提供一个安全的“通道”。\n\n看了以后显然更晕了，注意一下他是一个`SHELL`, 可以理解为 SSH 服务器之间安全通信的一个协议，既然称之为安全的，想必是通信过程使用了加密手段。\n这时候就用上了我们上一节的知识了，我们现在要在服务器之前就行安全的通信：\n1. A、B之间建立TCP连接\n2. B生成一对公私密钥\n3. B把公钥发送给A\n4. A生成一个用于加密数据的密钥K（既我们想通知给客户端的密钥，之后的数据通信都使用这个密钥加密，这个密钥不可让第三方知道）\n5. A把K用公钥加密发送给B，B解密后，从此A、B之间的通信数据都用K密钥进行加密和解密（转为了安全的对称加密方式）。\n\n这个过程还是会有一样的问题，加入中间有C、D，假冒B发放公钥给A，夹在了A和B之间，不是又不安全了吗。\n为了解决这个问题SSH协议采用由人工判断公钥的fingerprint是否可信的方式：\n```bash\nThe authenticity of host '172.20.7.211 (<no hostip for proxy command>)' can't be established.\nRSA key fingerprint is 23:42:c1:e4:3f:d2:cc:37:1d:89:cb:e7:5d:be:5d:53.\nAre you sure you want to continue connecting (yes/no)? \n```\n输入yes之后才会连接到远程服务器，同时这个信息会存储到用户的.ssh/known_hosts文件中，下次再登录的时候，会检查known_host文件，如果存在相同的公钥信息，就不在提示用户确认了.\n相当于中间加了一步人工验证，确定下要连接的机器，作为客户端一般也确实是知道自己要连谁的。\n当然这一步也可以手动跳过:\n```bash\nssh -o PubkeyAuthentication=yes  -o stricthostkeychecking=no\n```\n我们都用过`ssh-keygen` 命令，他就是为我们生成一对密钥（公钥+私钥），用于我们所说的非对称加密过程\n```bash\nssh-keygen -t rsa\n#.ssh/\nid_rsa.pub       //公钥   \nid_rsa           //密钥\n```\n将id_rsa.pub的内容写入authorized_keys文件中，表示该机器目前授权的使用该公钥访问\n```bash\ncat id_rsa.pub >> authorized_keys\n```\n\n一个完整的SSH客户端认证流程\n\n对于使用linux远程登录功能的系统管理员来说能有直观感觉的也就是是这个环节了。一般我们能接触到的的认证方式有两种：\n\n密码认证\nPublic Key认证\n密码认证很好理解，就是我们在登录远程linux服务器的时候提供用户名和密码？这里面稍微提示一下，在你的用户名和密码通过网络传输给服务器之前，已经经过了服务器认证协商阶段，这是一个安全的加密信道已经建立，所以你的用户名和密码都是加密后传输给服务器的，保证不会被第三方截获。\n\n每次登录都要输入密码很麻烦，且密码如果简单的话可能还会被暴力破解，而且很多自动化场景要求我们实现免密登录服务器。Public Key认证提供了一种更安全便捷的认证客户端的方式。这个技术也用到了非对称加密技术，由客户端生成公私密钥对，然后将公钥保存在服务器上。认证的过程大体如下：\n1. 客户端发起一个Public Key的认证请求，并发送RSA Key的模数作为标识符。（如果想深入了解RSA Key详细 -->维基百科）\n2. 服务端检查是否存在请求帐号的公钥（Linux中存储在~/.ssh/authorized_keys文件中），以及其拥有的访问权限。如果没有则断开连接\n3. 服务端使用对应的公钥对一个随机的256位的字符串进行加密，并发送给客户端\n4. 客户端使用私钥对字符串进行解密，并将其结合session id生成一个MD5值发送给服务端。*结合session id的目的是为了避免攻击者采用重放攻击（replay attack）。\n5. 服务端采用同样的方式生成MD5值与客户端返回的MD5值进行比较，完成对客户端的认证。\n\n## SSL\nTLS（Transport Layer Security：它相当于是SSL协议的一个后续版本，他是SSL经过IETF标准化之后的产物。\n上面wiki上也有写，SSH其实是专门为shell设计的一种通信协议，它垮了两个网络层（传输层和应用层）。通俗点讲就是只有SSH客户端，和SSH服务器端之间的通信才能使用这个协议，其他软件服务无法使用它。但是其实我们非常需要一个通用的，建立在应用层之下的一个传输层安全协议，它的目标是建立一种对上层应用协议透明的，不管是HTTP、FTP、还是电子邮件协议或其他任何应用层协议都可以依赖的底层的可安全通信的传输层协议。\nSSL（Secure Sockets Layer）协议就是在此背景下诞生的。\n对于一个通用的协议来说，类似SSH使用printfinger来防止中间人攻击不一样，互联网上所有的客户端和服务器是不可能自己判断对方是不是可信。\n这个时候就用到了我们所说的 `数字证书` 的概念，在SSL中引入了一个公证机关，就是我们熟知的 `CA`。\n有了数字证书，浏览器在建立SSL连接之前，并不只是简单获取服务器的公钥，而从服务器获取数字证书。\n有了信任机制之后，剩下的交互过程还是我们所熟知的非对称加密过程。\n![](http://www.ruanyifeng.com/blogimg/asset/2014/bg2014092007.png)\n[图解SSL/TLS协议-阮一峰](http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html)\n\n## HTTPS\n上面的概念清晰了以后，理解HTTPS就简单了。HTTPS的全程是 Hypertext Transfer Protocol Secure，就是 运行在 SSL/TLS 之上的 HTTP协议。\n做为网站管理员，可能会遇到申请数字证书的任务，理解了上面的概念，申请数字证书就不那么一头雾水了，首先你要为服务器生成一对公司密钥，然后把你网站的信息连同你的公钥一起发送给某个权威的CA，CA会通过某种方式认证申请人是否真的是网站的所有人，比如让你在网站的指定路径上传他指定的特殊蚊子序列。验证通过就会得到证书了。\n\n\n## 参考文献\n- http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html\n- https://zh.wikipedia.org/wiki/RSA加密演算法\n- https://www.jianshu.com/p/5e3f9dfd2cb4\n- https://www.jianshu.com/p/b078282653b3","source":"_posts/sshLogin.md","raw":"---\ntitle: SSH、SSL 和 HTTPS\ndate: 2019-09-03 10:56:46\ncategories: \n- HTTPS\n- encrypt\ntags:\n- SSH\n- SSL\n- HTTPS\n- 加密算法\n---\n\n> 一直对 SSH 、SSL 以及 HTTPS 跟它们的关系都云里雾里的，下面参考网上的文章和自己的理解梳理一下，晕了就再回来看一下，总会记住的。\n\n## 加密算法\n首先先说下加密算法，可以分为两大类，`对称加密` 和 `非对称加密`。\n### 对称加密\n通信双方的数据都是用同一套秘钥来进行加密和解密。\n在1976年以前，所有的加密都采用对称加密，这种加密方式最大的问题就是如何管理秘钥？既要保证秘钥不泄露，同时还要在保证秘钥的共享性。\n### 非对称加密\n1976年有两位数学家提出的一个新的加密概念：\n1. A生成一对两把密钥（公钥和私钥）。\n2. B获取A生成的公钥，然后用公钥对信息加密。\n3. A收到B的加密信息后，用自己的私钥解密。\n\n非对称加密引入了公钥和私钥的概念。公钥加密，私钥解密（公钥加密，私钥解密）。公钥是面向所有使用者公开的。\n目前计算机领域使用最广泛的非对称加密算法是[RSA](https://zh.wikipedia.org/wiki/RSA%E5%8A%A0%E5%AF%86%E6%BC%94%E7%AE%97%E6%B3%95)。\n\n对称加密看起来很强大，但是也有缺点：\n\n- 加密更耗时：算法更复杂。\n- 容易受到中间人攻击:即如果有C冒充A利用A的公钥给B发消息，B的所有消息对C其实就是透明的了。\n  \n针对中间人攻击，一般就采用非对称加密+摘要算法+数字签名的机制来确保传输安全。\n### 摘要算法（hash算法）\nHash 算法的特点是单向不可逆。利用这个特性，可以通过hash对目前信息加密生成特定长度且唯一的hash值，该值也不能被逆向破译。因此hash算法进场用在不可还原的密码存储、信息完整性校验等领域。\n常见的hash算法：MD2，MD4，MD5，SHA等\n\n### 数字签名\n数字签名，是为了保证信息在传输过程中没有被篡改。\n使用hash算法生成要发送明文的摘要，然后 把明文和摘要都通过私钥加密，加密后的摘要作为`数字签名（digital signature）`跟加密后的内容一起发送给接受者。\n接受者收到数据信息后，使用公钥分别对内容和信息解密，得到数据和内容摘要，然后用一样的算法对内容生成摘要，比较摘要是否相同来确认信息的完整性。\n\n### 数字证书\n以上的流程还是存在一个问题就是，有人冒充通信人发放公钥。这种场景的出现，我们就需要有个公证人了，告诉我们到底有是真的注册登记过的。\n这个公证人就是证书中心（certificate authority）简称CA。\n所有想发放公钥的人，都需要去CA为自己的公钥做认证。证书中心会用自己私钥和公钥以及公钥人信息一起进行加密，生成的东西就叫数字证书。\n以后所有类似的场景，都是统一用CA的公钥解开数字证书，拿到通信用的公钥，然后证明数字签名确实是来自哪里的了。\n\n\n关于数字签名和数字证书，阮一峰老师的这篇文章讲的特别生动[blog](http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html)\n\n## SSH\nwiki上对SSH的定义:\n>Secure Shell（缩写为SSH），由IETF的网络工作小组（Network Working Group）所制定；SSH为一项创建在应用层和传输层基础上的安全协议，为计算机上的Shell（壳层）提供安全的传输和使用环境。\n>传统的网络服务程序，如rsh、FTP、POP和Telnet其本质上都是不安全的；因为它们在网络上用明文传送数据、用户帐号和用户口令，很容易受到中间人（man-in-the-middle）攻击方式的攻击。就是存在另一个>人或者一台机器冒充真正的服务器接收用户传给服务器的数据，然后再冒充用户把数据传给真正的服务器。\n>而SSH是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用SSH协议可以有效防止远程管理过程中的信息泄露问题。通过SSH可以对所有传输的数据进行加密，也能够防止DNS欺骗和IP欺骗。\n>SSH之另一项优点为其传输的数据可以是经过压缩的，所以可以加快传输的速度。SSH有很多功能，它既可以代替Telnet，又可以为FTP、POP、甚至为PPP提供一个安全的“通道”。\n\n看了以后显然更晕了，注意一下他是一个`SHELL`, 可以理解为 SSH 服务器之间安全通信的一个协议，既然称之为安全的，想必是通信过程使用了加密手段。\n这时候就用上了我们上一节的知识了，我们现在要在服务器之前就行安全的通信：\n1. A、B之间建立TCP连接\n2. B生成一对公私密钥\n3. B把公钥发送给A\n4. A生成一个用于加密数据的密钥K（既我们想通知给客户端的密钥，之后的数据通信都使用这个密钥加密，这个密钥不可让第三方知道）\n5. A把K用公钥加密发送给B，B解密后，从此A、B之间的通信数据都用K密钥进行加密和解密（转为了安全的对称加密方式）。\n\n这个过程还是会有一样的问题，加入中间有C、D，假冒B发放公钥给A，夹在了A和B之间，不是又不安全了吗。\n为了解决这个问题SSH协议采用由人工判断公钥的fingerprint是否可信的方式：\n```bash\nThe authenticity of host '172.20.7.211 (<no hostip for proxy command>)' can't be established.\nRSA key fingerprint is 23:42:c1:e4:3f:d2:cc:37:1d:89:cb:e7:5d:be:5d:53.\nAre you sure you want to continue connecting (yes/no)? \n```\n输入yes之后才会连接到远程服务器，同时这个信息会存储到用户的.ssh/known_hosts文件中，下次再登录的时候，会检查known_host文件，如果存在相同的公钥信息，就不在提示用户确认了.\n相当于中间加了一步人工验证，确定下要连接的机器，作为客户端一般也确实是知道自己要连谁的。\n当然这一步也可以手动跳过:\n```bash\nssh -o PubkeyAuthentication=yes  -o stricthostkeychecking=no\n```\n我们都用过`ssh-keygen` 命令，他就是为我们生成一对密钥（公钥+私钥），用于我们所说的非对称加密过程\n```bash\nssh-keygen -t rsa\n#.ssh/\nid_rsa.pub       //公钥   \nid_rsa           //密钥\n```\n将id_rsa.pub的内容写入authorized_keys文件中，表示该机器目前授权的使用该公钥访问\n```bash\ncat id_rsa.pub >> authorized_keys\n```\n\n一个完整的SSH客户端认证流程\n\n对于使用linux远程登录功能的系统管理员来说能有直观感觉的也就是是这个环节了。一般我们能接触到的的认证方式有两种：\n\n密码认证\nPublic Key认证\n密码认证很好理解，就是我们在登录远程linux服务器的时候提供用户名和密码？这里面稍微提示一下，在你的用户名和密码通过网络传输给服务器之前，已经经过了服务器认证协商阶段，这是一个安全的加密信道已经建立，所以你的用户名和密码都是加密后传输给服务器的，保证不会被第三方截获。\n\n每次登录都要输入密码很麻烦，且密码如果简单的话可能还会被暴力破解，而且很多自动化场景要求我们实现免密登录服务器。Public Key认证提供了一种更安全便捷的认证客户端的方式。这个技术也用到了非对称加密技术，由客户端生成公私密钥对，然后将公钥保存在服务器上。认证的过程大体如下：\n1. 客户端发起一个Public Key的认证请求，并发送RSA Key的模数作为标识符。（如果想深入了解RSA Key详细 -->维基百科）\n2. 服务端检查是否存在请求帐号的公钥（Linux中存储在~/.ssh/authorized_keys文件中），以及其拥有的访问权限。如果没有则断开连接\n3. 服务端使用对应的公钥对一个随机的256位的字符串进行加密，并发送给客户端\n4. 客户端使用私钥对字符串进行解密，并将其结合session id生成一个MD5值发送给服务端。*结合session id的目的是为了避免攻击者采用重放攻击（replay attack）。\n5. 服务端采用同样的方式生成MD5值与客户端返回的MD5值进行比较，完成对客户端的认证。\n\n## SSL\nTLS（Transport Layer Security：它相当于是SSL协议的一个后续版本，他是SSL经过IETF标准化之后的产物。\n上面wiki上也有写，SSH其实是专门为shell设计的一种通信协议，它垮了两个网络层（传输层和应用层）。通俗点讲就是只有SSH客户端，和SSH服务器端之间的通信才能使用这个协议，其他软件服务无法使用它。但是其实我们非常需要一个通用的，建立在应用层之下的一个传输层安全协议，它的目标是建立一种对上层应用协议透明的，不管是HTTP、FTP、还是电子邮件协议或其他任何应用层协议都可以依赖的底层的可安全通信的传输层协议。\nSSL（Secure Sockets Layer）协议就是在此背景下诞生的。\n对于一个通用的协议来说，类似SSH使用printfinger来防止中间人攻击不一样，互联网上所有的客户端和服务器是不可能自己判断对方是不是可信。\n这个时候就用到了我们所说的 `数字证书` 的概念，在SSL中引入了一个公证机关，就是我们熟知的 `CA`。\n有了数字证书，浏览器在建立SSL连接之前，并不只是简单获取服务器的公钥，而从服务器获取数字证书。\n有了信任机制之后，剩下的交互过程还是我们所熟知的非对称加密过程。\n![](http://www.ruanyifeng.com/blogimg/asset/2014/bg2014092007.png)\n[图解SSL/TLS协议-阮一峰](http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html)\n\n## HTTPS\n上面的概念清晰了以后，理解HTTPS就简单了。HTTPS的全程是 Hypertext Transfer Protocol Secure，就是 运行在 SSL/TLS 之上的 HTTP协议。\n做为网站管理员，可能会遇到申请数字证书的任务，理解了上面的概念，申请数字证书就不那么一头雾水了，首先你要为服务器生成一对公司密钥，然后把你网站的信息连同你的公钥一起发送给某个权威的CA，CA会通过某种方式认证申请人是否真的是网站的所有人，比如让你在网站的指定路径上传他指定的特殊蚊子序列。验证通过就会得到证书了。\n\n\n## 参考文献\n- http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html\n- https://zh.wikipedia.org/wiki/RSA加密演算法\n- https://www.jianshu.com/p/5e3f9dfd2cb4\n- https://www.jianshu.com/p/b078282653b3","slug":"sshLogin","published":1,"updated":"2019-09-03T06:24:03.971Z","_id":"ck03fz4ac0000olox0agk6jws","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p>一直对 SSH 、SSL 以及 HTTPS 跟它们的关系都云里雾里的，下面参考网上的文章和自己的理解梳理一下，晕了就再回来看一下，总会记住的。</p>\n</blockquote>\n<h2 id=\"加密算法\"><a href=\"#加密算法\" class=\"headerlink\" title=\"加密算法\"></a>加密算法</h2><p>首先先说下加密算法，可以分为两大类，<code>对称加密</code> 和 <code>非对称加密</code>。</p>\n<h3 id=\"对称加密\"><a href=\"#对称加密\" class=\"headerlink\" title=\"对称加密\"></a>对称加密</h3><p>通信双方的数据都是用同一套秘钥来进行加密和解密。<br>在1976年以前，所有的加密都采用对称加密，这种加密方式最大的问题就是如何管理秘钥？既要保证秘钥不泄露，同时还要在保证秘钥的共享性。</p>\n<h3 id=\"非对称加密\"><a href=\"#非对称加密\" class=\"headerlink\" title=\"非对称加密\"></a>非对称加密</h3><p>1976年有两位数学家提出的一个新的加密概念：</p>\n<ol>\n<li>A生成一对两把密钥（公钥和私钥）。</li>\n<li>B获取A生成的公钥，然后用公钥对信息加密。</li>\n<li>A收到B的加密信息后，用自己的私钥解密。</li>\n</ol>\n<p>非对称加密引入了公钥和私钥的概念。公钥加密，私钥解密（公钥加密，私钥解密）。公钥是面向所有使用者公开的。<br>目前计算机领域使用最广泛的非对称加密算法是<a href=\"https://zh.wikipedia.org/wiki/RSA%E5%8A%A0%E5%AF%86%E6%BC%94%E7%AE%97%E6%B3%95\" target=\"_blank\" rel=\"noopener\">RSA</a>。</p>\n<p>对称加密看起来很强大，但是也有缺点：</p>\n<ul>\n<li>加密更耗时：算法更复杂。</li>\n<li>容易受到中间人攻击:即如果有C冒充A利用A的公钥给B发消息，B的所有消息对C其实就是透明的了。</li>\n</ul>\n<p>针对中间人攻击，一般就采用非对称加密+摘要算法+数字签名的机制来确保传输安全。</p>\n<h3 id=\"摘要算法（hash算法）\"><a href=\"#摘要算法（hash算法）\" class=\"headerlink\" title=\"摘要算法（hash算法）\"></a>摘要算法（hash算法）</h3><p>Hash 算法的特点是单向不可逆。利用这个特性，可以通过hash对目前信息加密生成特定长度且唯一的hash值，该值也不能被逆向破译。因此hash算法进场用在不可还原的密码存储、信息完整性校验等领域。<br>常见的hash算法：MD2，MD4，MD5，SHA等</p>\n<h3 id=\"数字签名\"><a href=\"#数字签名\" class=\"headerlink\" title=\"数字签名\"></a>数字签名</h3><p>数字签名，是为了保证信息在传输过程中没有被篡改。<br>使用hash算法生成要发送明文的摘要，然后 把明文和摘要都通过私钥加密，加密后的摘要作为<code>数字签名（digital signature）</code>跟加密后的内容一起发送给接受者。<br>接受者收到数据信息后，使用公钥分别对内容和信息解密，得到数据和内容摘要，然后用一样的算法对内容生成摘要，比较摘要是否相同来确认信息的完整性。</p>\n<h3 id=\"数字证书\"><a href=\"#数字证书\" class=\"headerlink\" title=\"数字证书\"></a>数字证书</h3><p>以上的流程还是存在一个问题就是，有人冒充通信人发放公钥。这种场景的出现，我们就需要有个公证人了，告诉我们到底有是真的注册登记过的。<br>这个公证人就是证书中心（certificate authority）简称CA。<br>所有想发放公钥的人，都需要去CA为自己的公钥做认证。证书中心会用自己私钥和公钥以及公钥人信息一起进行加密，生成的东西就叫数字证书。<br>以后所有类似的场景，都是统一用CA的公钥解开数字证书，拿到通信用的公钥，然后证明数字签名确实是来自哪里的了。</p>\n<p>关于数字签名和数字证书，阮一峰老师的这篇文章讲的特别生动<a href=\"http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html\" target=\"_blank\" rel=\"noopener\">blog</a></p>\n<h2 id=\"SSH\"><a href=\"#SSH\" class=\"headerlink\" title=\"SSH\"></a>SSH</h2><p>wiki上对SSH的定义:</p>\n<blockquote>\n<p>Secure Shell（缩写为SSH），由IETF的网络工作小组（Network Working Group）所制定；SSH为一项创建在应用层和传输层基础上的安全协议，为计算机上的Shell（壳层）提供安全的传输和使用环境。<br>传统的网络服务程序，如rsh、FTP、POP和Telnet其本质上都是不安全的；因为它们在网络上用明文传送数据、用户帐号和用户口令，很容易受到中间人（man-in-the-middle）攻击方式的攻击。就是存在另一个&gt;人或者一台机器冒充真正的服务器接收用户传给服务器的数据，然后再冒充用户把数据传给真正的服务器。<br>而SSH是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用SSH协议可以有效防止远程管理过程中的信息泄露问题。通过SSH可以对所有传输的数据进行加密，也能够防止DNS欺骗和IP欺骗。<br>SSH之另一项优点为其传输的数据可以是经过压缩的，所以可以加快传输的速度。SSH有很多功能，它既可以代替Telnet，又可以为FTP、POP、甚至为PPP提供一个安全的“通道”。</p>\n</blockquote>\n<p>看了以后显然更晕了，注意一下他是一个<code>SHELL</code>, 可以理解为 SSH 服务器之间安全通信的一个协议，既然称之为安全的，想必是通信过程使用了加密手段。<br>这时候就用上了我们上一节的知识了，我们现在要在服务器之前就行安全的通信：</p>\n<ol>\n<li>A、B之间建立TCP连接</li>\n<li>B生成一对公私密钥</li>\n<li>B把公钥发送给A</li>\n<li>A生成一个用于加密数据的密钥K（既我们想通知给客户端的密钥，之后的数据通信都使用这个密钥加密，这个密钥不可让第三方知道）</li>\n<li>A把K用公钥加密发送给B，B解密后，从此A、B之间的通信数据都用K密钥进行加密和解密（转为了安全的对称加密方式）。</li>\n</ol>\n<p>这个过程还是会有一样的问题，加入中间有C、D，假冒B发放公钥给A，夹在了A和B之间，不是又不安全了吗。<br>为了解决这个问题SSH协议采用由人工判断公钥的fingerprint是否可信的方式：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">The authenticity of host <span class=\"string\">'172.20.7.211 (&lt;no hostip for proxy command&gt;)'</span> can<span class=\"string\">'t be established.</span></span><br><span class=\"line\"><span class=\"string\">RSA key fingerprint is 23:42:c1:e4:3f:d2:cc:37:1d:89:cb:e7:5d:be:5d:53.</span></span><br><span class=\"line\"><span class=\"string\">Are you sure you want to continue connecting (yes/no)?</span></span><br></pre></td></tr></table></figure>\n\n<p>输入yes之后才会连接到远程服务器，同时这个信息会存储到用户的.ssh/known_hosts文件中，下次再登录的时候，会检查known_host文件，如果存在相同的公钥信息，就不在提示用户确认了.<br>相当于中间加了一步人工验证，确定下要连接的机器，作为客户端一般也确实是知道自己要连谁的。<br>当然这一步也可以手动跳过:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh -o PubkeyAuthentication=yes  -o stricthostkeychecking=no</span><br></pre></td></tr></table></figure>\n\n<p>我们都用过<code>ssh-keygen</code> 命令，他就是为我们生成一对密钥（公钥+私钥），用于我们所说的非对称加密过程</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-keygen -t rsa</span><br><span class=\"line\"><span class=\"comment\">#.ssh/</span></span><br><span class=\"line\">id_rsa.pub       //公钥   </span><br><span class=\"line\">id_rsa           //密钥</span><br></pre></td></tr></table></figure>\n\n<p>将id_rsa.pub的内容写入authorized_keys文件中，表示该机器目前授权的使用该公钥访问</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat id_rsa.pub &gt;&gt; authorized_keys</span><br></pre></td></tr></table></figure>\n\n<p>一个完整的SSH客户端认证流程</p>\n<p>对于使用linux远程登录功能的系统管理员来说能有直观感觉的也就是是这个环节了。一般我们能接触到的的认证方式有两种：</p>\n<p>密码认证<br>Public Key认证<br>密码认证很好理解，就是我们在登录远程linux服务器的时候提供用户名和密码？这里面稍微提示一下，在你的用户名和密码通过网络传输给服务器之前，已经经过了服务器认证协商阶段，这是一个安全的加密信道已经建立，所以你的用户名和密码都是加密后传输给服务器的，保证不会被第三方截获。</p>\n<p>每次登录都要输入密码很麻烦，且密码如果简单的话可能还会被暴力破解，而且很多自动化场景要求我们实现免密登录服务器。Public Key认证提供了一种更安全便捷的认证客户端的方式。这个技术也用到了非对称加密技术，由客户端生成公私密钥对，然后将公钥保存在服务器上。认证的过程大体如下：</p>\n<ol>\n<li>客户端发起一个Public Key的认证请求，并发送RSA Key的模数作为标识符。（如果想深入了解RSA Key详细 –&gt;维基百科）</li>\n<li>服务端检查是否存在请求帐号的公钥（Linux中存储在~/.ssh/authorized_keys文件中），以及其拥有的访问权限。如果没有则断开连接</li>\n<li>服务端使用对应的公钥对一个随机的256位的字符串进行加密，并发送给客户端</li>\n<li>客户端使用私钥对字符串进行解密，并将其结合session id生成一个MD5值发送给服务端。*结合session id的目的是为了避免攻击者采用重放攻击（replay attack）。</li>\n<li>服务端采用同样的方式生成MD5值与客户端返回的MD5值进行比较，完成对客户端的认证。</li>\n</ol>\n<h2 id=\"SSL\"><a href=\"#SSL\" class=\"headerlink\" title=\"SSL\"></a>SSL</h2><p>TLS（Transport Layer Security：它相当于是SSL协议的一个后续版本，他是SSL经过IETF标准化之后的产物。<br>上面wiki上也有写，SSH其实是专门为shell设计的一种通信协议，它垮了两个网络层（传输层和应用层）。通俗点讲就是只有SSH客户端，和SSH服务器端之间的通信才能使用这个协议，其他软件服务无法使用它。但是其实我们非常需要一个通用的，建立在应用层之下的一个传输层安全协议，它的目标是建立一种对上层应用协议透明的，不管是HTTP、FTP、还是电子邮件协议或其他任何应用层协议都可以依赖的底层的可安全通信的传输层协议。<br>SSL（Secure Sockets Layer）协议就是在此背景下诞生的。<br>对于一个通用的协议来说，类似SSH使用printfinger来防止中间人攻击不一样，互联网上所有的客户端和服务器是不可能自己判断对方是不是可信。<br>这个时候就用到了我们所说的 <code>数字证书</code> 的概念，在SSL中引入了一个公证机关，就是我们熟知的 <code>CA</code>。<br>有了数字证书，浏览器在建立SSL连接之前，并不只是简单获取服务器的公钥，而从服务器获取数字证书。<br>有了信任机制之后，剩下的交互过程还是我们所熟知的非对称加密过程。<br><img src=\"http://www.ruanyifeng.com/blogimg/asset/2014/bg2014092007.png\" alt><br><a href=\"http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html\" target=\"_blank\" rel=\"noopener\">图解SSL/TLS协议-阮一峰</a></p>\n<h2 id=\"HTTPS\"><a href=\"#HTTPS\" class=\"headerlink\" title=\"HTTPS\"></a>HTTPS</h2><p>上面的概念清晰了以后，理解HTTPS就简单了。HTTPS的全程是 Hypertext Transfer Protocol Secure，就是 运行在 SSL/TLS 之上的 HTTP协议。<br>做为网站管理员，可能会遇到申请数字证书的任务，理解了上面的概念，申请数字证书就不那么一头雾水了，首先你要为服务器生成一对公司密钥，然后把你网站的信息连同你的公钥一起发送给某个权威的CA，CA会通过某种方式认证申请人是否真的是网站的所有人，比如让你在网站的指定路径上传他指定的特殊蚊子序列。验证通过就会得到证书了。</p>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html\" target=\"_blank\" rel=\"noopener\">http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html</a></li>\n<li><a href=\"https://zh.wikipedia.org/wiki/RSA加密演算法\" target=\"_blank\" rel=\"noopener\">https://zh.wikipedia.org/wiki/RSA加密演算法</a></li>\n<li><a href=\"https://www.jianshu.com/p/5e3f9dfd2cb4\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/5e3f9dfd2cb4</a></li>\n<li><a href=\"https://www.jianshu.com/p/b078282653b3\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/b078282653b3</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>一直对 SSH 、SSL 以及 HTTPS 跟它们的关系都云里雾里的，下面参考网上的文章和自己的理解梳理一下，晕了就再回来看一下，总会记住的。</p>\n</blockquote>\n<h2 id=\"加密算法\"><a href=\"#加密算法\" class=\"headerlink\" title=\"加密算法\"></a>加密算法</h2><p>首先先说下加密算法，可以分为两大类，<code>对称加密</code> 和 <code>非对称加密</code>。</p>\n<h3 id=\"对称加密\"><a href=\"#对称加密\" class=\"headerlink\" title=\"对称加密\"></a>对称加密</h3><p>通信双方的数据都是用同一套秘钥来进行加密和解密。<br>在1976年以前，所有的加密都采用对称加密，这种加密方式最大的问题就是如何管理秘钥？既要保证秘钥不泄露，同时还要在保证秘钥的共享性。</p>\n<h3 id=\"非对称加密\"><a href=\"#非对称加密\" class=\"headerlink\" title=\"非对称加密\"></a>非对称加密</h3><p>1976年有两位数学家提出的一个新的加密概念：</p>\n<ol>\n<li>A生成一对两把密钥（公钥和私钥）。</li>\n<li>B获取A生成的公钥，然后用公钥对信息加密。</li>\n<li>A收到B的加密信息后，用自己的私钥解密。</li>\n</ol>\n<p>非对称加密引入了公钥和私钥的概念。公钥加密，私钥解密（公钥加密，私钥解密）。公钥是面向所有使用者公开的。<br>目前计算机领域使用最广泛的非对称加密算法是<a href=\"https://zh.wikipedia.org/wiki/RSA%E5%8A%A0%E5%AF%86%E6%BC%94%E7%AE%97%E6%B3%95\" target=\"_blank\" rel=\"noopener\">RSA</a>。</p>\n<p>对称加密看起来很强大，但是也有缺点：</p>\n<ul>\n<li>加密更耗时：算法更复杂。</li>\n<li>容易受到中间人攻击:即如果有C冒充A利用A的公钥给B发消息，B的所有消息对C其实就是透明的了。</li>\n</ul>\n<p>针对中间人攻击，一般就采用非对称加密+摘要算法+数字签名的机制来确保传输安全。</p>\n<h3 id=\"摘要算法（hash算法）\"><a href=\"#摘要算法（hash算法）\" class=\"headerlink\" title=\"摘要算法（hash算法）\"></a>摘要算法（hash算法）</h3><p>Hash 算法的特点是单向不可逆。利用这个特性，可以通过hash对目前信息加密生成特定长度且唯一的hash值，该值也不能被逆向破译。因此hash算法进场用在不可还原的密码存储、信息完整性校验等领域。<br>常见的hash算法：MD2，MD4，MD5，SHA等</p>\n<h3 id=\"数字签名\"><a href=\"#数字签名\" class=\"headerlink\" title=\"数字签名\"></a>数字签名</h3><p>数字签名，是为了保证信息在传输过程中没有被篡改。<br>使用hash算法生成要发送明文的摘要，然后 把明文和摘要都通过私钥加密，加密后的摘要作为<code>数字签名（digital signature）</code>跟加密后的内容一起发送给接受者。<br>接受者收到数据信息后，使用公钥分别对内容和信息解密，得到数据和内容摘要，然后用一样的算法对内容生成摘要，比较摘要是否相同来确认信息的完整性。</p>\n<h3 id=\"数字证书\"><a href=\"#数字证书\" class=\"headerlink\" title=\"数字证书\"></a>数字证书</h3><p>以上的流程还是存在一个问题就是，有人冒充通信人发放公钥。这种场景的出现，我们就需要有个公证人了，告诉我们到底有是真的注册登记过的。<br>这个公证人就是证书中心（certificate authority）简称CA。<br>所有想发放公钥的人，都需要去CA为自己的公钥做认证。证书中心会用自己私钥和公钥以及公钥人信息一起进行加密，生成的东西就叫数字证书。<br>以后所有类似的场景，都是统一用CA的公钥解开数字证书，拿到通信用的公钥，然后证明数字签名确实是来自哪里的了。</p>\n<p>关于数字签名和数字证书，阮一峰老师的这篇文章讲的特别生动<a href=\"http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html\" target=\"_blank\" rel=\"noopener\">blog</a></p>\n<h2 id=\"SSH\"><a href=\"#SSH\" class=\"headerlink\" title=\"SSH\"></a>SSH</h2><p>wiki上对SSH的定义:</p>\n<blockquote>\n<p>Secure Shell（缩写为SSH），由IETF的网络工作小组（Network Working Group）所制定；SSH为一项创建在应用层和传输层基础上的安全协议，为计算机上的Shell（壳层）提供安全的传输和使用环境。<br>传统的网络服务程序，如rsh、FTP、POP和Telnet其本质上都是不安全的；因为它们在网络上用明文传送数据、用户帐号和用户口令，很容易受到中间人（man-in-the-middle）攻击方式的攻击。就是存在另一个&gt;人或者一台机器冒充真正的服务器接收用户传给服务器的数据，然后再冒充用户把数据传给真正的服务器。<br>而SSH是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用SSH协议可以有效防止远程管理过程中的信息泄露问题。通过SSH可以对所有传输的数据进行加密，也能够防止DNS欺骗和IP欺骗。<br>SSH之另一项优点为其传输的数据可以是经过压缩的，所以可以加快传输的速度。SSH有很多功能，它既可以代替Telnet，又可以为FTP、POP、甚至为PPP提供一个安全的“通道”。</p>\n</blockquote>\n<p>看了以后显然更晕了，注意一下他是一个<code>SHELL</code>, 可以理解为 SSH 服务器之间安全通信的一个协议，既然称之为安全的，想必是通信过程使用了加密手段。<br>这时候就用上了我们上一节的知识了，我们现在要在服务器之前就行安全的通信：</p>\n<ol>\n<li>A、B之间建立TCP连接</li>\n<li>B生成一对公私密钥</li>\n<li>B把公钥发送给A</li>\n<li>A生成一个用于加密数据的密钥K（既我们想通知给客户端的密钥，之后的数据通信都使用这个密钥加密，这个密钥不可让第三方知道）</li>\n<li>A把K用公钥加密发送给B，B解密后，从此A、B之间的通信数据都用K密钥进行加密和解密（转为了安全的对称加密方式）。</li>\n</ol>\n<p>这个过程还是会有一样的问题，加入中间有C、D，假冒B发放公钥给A，夹在了A和B之间，不是又不安全了吗。<br>为了解决这个问题SSH协议采用由人工判断公钥的fingerprint是否可信的方式：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">The authenticity of host <span class=\"string\">'172.20.7.211 (&lt;no hostip for proxy command&gt;)'</span> can<span class=\"string\">'t be established.</span></span><br><span class=\"line\"><span class=\"string\">RSA key fingerprint is 23:42:c1:e4:3f:d2:cc:37:1d:89:cb:e7:5d:be:5d:53.</span></span><br><span class=\"line\"><span class=\"string\">Are you sure you want to continue connecting (yes/no)?</span></span><br></pre></td></tr></table></figure>\n\n<p>输入yes之后才会连接到远程服务器，同时这个信息会存储到用户的.ssh/known_hosts文件中，下次再登录的时候，会检查known_host文件，如果存在相同的公钥信息，就不在提示用户确认了.<br>相当于中间加了一步人工验证，确定下要连接的机器，作为客户端一般也确实是知道自己要连谁的。<br>当然这一步也可以手动跳过:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh -o PubkeyAuthentication=yes  -o stricthostkeychecking=no</span><br></pre></td></tr></table></figure>\n\n<p>我们都用过<code>ssh-keygen</code> 命令，他就是为我们生成一对密钥（公钥+私钥），用于我们所说的非对称加密过程</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-keygen -t rsa</span><br><span class=\"line\"><span class=\"comment\">#.ssh/</span></span><br><span class=\"line\">id_rsa.pub       //公钥   </span><br><span class=\"line\">id_rsa           //密钥</span><br></pre></td></tr></table></figure>\n\n<p>将id_rsa.pub的内容写入authorized_keys文件中，表示该机器目前授权的使用该公钥访问</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat id_rsa.pub &gt;&gt; authorized_keys</span><br></pre></td></tr></table></figure>\n\n<p>一个完整的SSH客户端认证流程</p>\n<p>对于使用linux远程登录功能的系统管理员来说能有直观感觉的也就是是这个环节了。一般我们能接触到的的认证方式有两种：</p>\n<p>密码认证<br>Public Key认证<br>密码认证很好理解，就是我们在登录远程linux服务器的时候提供用户名和密码？这里面稍微提示一下，在你的用户名和密码通过网络传输给服务器之前，已经经过了服务器认证协商阶段，这是一个安全的加密信道已经建立，所以你的用户名和密码都是加密后传输给服务器的，保证不会被第三方截获。</p>\n<p>每次登录都要输入密码很麻烦，且密码如果简单的话可能还会被暴力破解，而且很多自动化场景要求我们实现免密登录服务器。Public Key认证提供了一种更安全便捷的认证客户端的方式。这个技术也用到了非对称加密技术，由客户端生成公私密钥对，然后将公钥保存在服务器上。认证的过程大体如下：</p>\n<ol>\n<li>客户端发起一个Public Key的认证请求，并发送RSA Key的模数作为标识符。（如果想深入了解RSA Key详细 –&gt;维基百科）</li>\n<li>服务端检查是否存在请求帐号的公钥（Linux中存储在~/.ssh/authorized_keys文件中），以及其拥有的访问权限。如果没有则断开连接</li>\n<li>服务端使用对应的公钥对一个随机的256位的字符串进行加密，并发送给客户端</li>\n<li>客户端使用私钥对字符串进行解密，并将其结合session id生成一个MD5值发送给服务端。*结合session id的目的是为了避免攻击者采用重放攻击（replay attack）。</li>\n<li>服务端采用同样的方式生成MD5值与客户端返回的MD5值进行比较，完成对客户端的认证。</li>\n</ol>\n<h2 id=\"SSL\"><a href=\"#SSL\" class=\"headerlink\" title=\"SSL\"></a>SSL</h2><p>TLS（Transport Layer Security：它相当于是SSL协议的一个后续版本，他是SSL经过IETF标准化之后的产物。<br>上面wiki上也有写，SSH其实是专门为shell设计的一种通信协议，它垮了两个网络层（传输层和应用层）。通俗点讲就是只有SSH客户端，和SSH服务器端之间的通信才能使用这个协议，其他软件服务无法使用它。但是其实我们非常需要一个通用的，建立在应用层之下的一个传输层安全协议，它的目标是建立一种对上层应用协议透明的，不管是HTTP、FTP、还是电子邮件协议或其他任何应用层协议都可以依赖的底层的可安全通信的传输层协议。<br>SSL（Secure Sockets Layer）协议就是在此背景下诞生的。<br>对于一个通用的协议来说，类似SSH使用printfinger来防止中间人攻击不一样，互联网上所有的客户端和服务器是不可能自己判断对方是不是可信。<br>这个时候就用到了我们所说的 <code>数字证书</code> 的概念，在SSL中引入了一个公证机关，就是我们熟知的 <code>CA</code>。<br>有了数字证书，浏览器在建立SSL连接之前，并不只是简单获取服务器的公钥，而从服务器获取数字证书。<br>有了信任机制之后，剩下的交互过程还是我们所熟知的非对称加密过程。<br><img src=\"http://www.ruanyifeng.com/blogimg/asset/2014/bg2014092007.png\" alt><br><a href=\"http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html\" target=\"_blank\" rel=\"noopener\">图解SSL/TLS协议-阮一峰</a></p>\n<h2 id=\"HTTPS\"><a href=\"#HTTPS\" class=\"headerlink\" title=\"HTTPS\"></a>HTTPS</h2><p>上面的概念清晰了以后，理解HTTPS就简单了。HTTPS的全程是 Hypertext Transfer Protocol Secure，就是 运行在 SSL/TLS 之上的 HTTP协议。<br>做为网站管理员，可能会遇到申请数字证书的任务，理解了上面的概念，申请数字证书就不那么一头雾水了，首先你要为服务器生成一对公司密钥，然后把你网站的信息连同你的公钥一起发送给某个权威的CA，CA会通过某种方式认证申请人是否真的是网站的所有人，比如让你在网站的指定路径上传他指定的特殊蚊子序列。验证通过就会得到证书了。</p>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html\" target=\"_blank\" rel=\"noopener\">http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html</a></li>\n<li><a href=\"https://zh.wikipedia.org/wiki/RSA加密演算法\" target=\"_blank\" rel=\"noopener\">https://zh.wikipedia.org/wiki/RSA加密演算法</a></li>\n<li><a href=\"https://www.jianshu.com/p/5e3f9dfd2cb4\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/5e3f9dfd2cb4</a></li>\n<li><a href=\"https://www.jianshu.com/p/b078282653b3\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/b078282653b3</a></li>\n</ul>\n"},{"title":"Nginx 配置 SSL","date":"2019-08-31T02:35:31.000Z","_content":"\n> 域名貌似备案成功了，解析到腾讯云服务器ip后，发现直接访问 http协议 是可以的 换成 https 不行了。应该是没有配置SSL导致的。\n\n## 什么是HTTPS\nhttps 全称：Hyper Text Transfer Protocol over Secure Socket Layer，是http的安全版。即http下加入SSL协议层，因此https的安全基础就是SSL，所以加密内容需要SSL。\n\n## SSL原理\n- 浏览器发送一个https的请求给服务器；\n- 服务器要有一套数字证书，可以自己制作，也可以向组织申请，区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面，这套证书其实就是一对公钥和私钥；\n- 服务器会把公钥传输给客户端；\n- 客户端（浏览器）收到公钥后，会验证其是否合法有效，无效会有警告提醒，有效则会生成一串随机数，并用收到的公钥加密；\n- 客户端把加密后的随机字符串传输给服务器；\n- 服务器收到加密随机字符串后，先用私钥解密（公钥加密，私钥解密），获取到这一串随机数后，再用这串随机字符串加密传输的数据（该加密为对称加密，所谓对称加密，就是将数据和私钥也就是这个随机字符串>通过某种算法混合在一起，这样除非知道私钥，否则无法获取数据内容）；\n- 服务器把加密后的数据传输给客户端；\n- 客户端收到数据后，再用自己的私钥也就是那个随机字符串解密；\n\n## 配置 with-http_ssl_module 模块\n首先需要申请一个证书，可以申请一个免费的。\n参考下面的 `其他方式` 部分可以直接在云服务厂商可视化界面申请并下载~\n然后会得到nginx版本证书，一个公钥（证书），一个私钥，将其上传到服务器。\n\n先确认`nginx`安装时已编译`http_ssl`模块，也就是执行`nginx -V`命令查看是否存在 `--with-http_ssl_module`。如果没有，则需要重新编译nginx将该模块加入。\n若有的话此步骤跳过\n若ssl模块没有先编译一下\n\n```bash\ncd /usr/local/src/nginx-1.12.1/  #nginx版本号可能不同哟\n\n./configure --help | grep -i ssl\n  --with-http_ssl_module \n  \n./configure --prefix=/usr/local/nginx --with-http_ssl_module\n\n```\n\n## 生成 ssl 秘钥对\n```bash\ncd /usr/local/nginx/conf\n\nyum install -y openssl\n```\n\n### 使用RSA算法生产key\n```bash\nopenssl genrsa -des3 -out tmp.key 2048\n# 生成一个rsa类型的密钥，且长度为2048，但是我们有发现，让我们设置密码，如果每次有人访问我们的站点，都需要输入密码，太麻烦了\n```\n所以我们要转换私钥，取消密码（其实tmp.key与zhdy.key密钥内容是一样的，只不过一个有密码一个没有）：\n```bash\nopenssl rsa -in tmp.key -out zhdy.key \n\nrm -f tmp.key\n```\n### 创建证书申请\n```\nopenssl req -new -key zhdy.key -out zhdy.csr\n```\n\n### 创建自签名的证书\n```bash\nopenssl x509 -req -days 365 -in zhdy.csr -signkey zhdy.key -out zhdy.crt\n```\n\n## Nginx 配置 ssl\n```bash\nserver\n{\n    listen 443;\n    server_name huguobo.site; # 换成你自己的域名服务哟\n    index index.html index.php;\n    root /path/to/your/file \n    ssl on;\n    ssl_certificate zhdy.crt;\n    ssl_certificate_key zhdy.key;\n    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;\n}\n\n# ssl on; 代表着打开ssl\n#ssl_certificate zhdy.crt; 公钥\n# ssl_certificate_key zhdy.key; 私钥\n# ssl_protocols TLSv1 TLSv1.1 TLSv1.2; 三种不同的协议\n```\n\n## 测试\n```bash\nnginx -t\nnginx restart\n```\n\n由于已经设置了443，所以我们使用curl -x 是不生效的。\n我们修改下/etc/hosts为: `yourip www.aaa.com`\n\n```bash\ncurl https://haha.com\n```\n报错显示为“此证书非安全证书”，但是ssl是已经成功配置了\n\n## 其他方式（更快捷）\n后来发现各个厂商也提供申请证书的入口，也提供 DNS 和 文件验证两种配置,大家也可以自行参考配置\n[腾讯云ssl控制台](https://console.cloud.tencent.com/ssl)\n[nginx配置文档](https://cloud.tencent.com/document/product/400/35244)\n\n这种从供应商处可以直接下载到证书，然后nginx的配置秘钥和证书都在 nginx 文件夹下\n\n从客户端传送文件到云主机（MAC）\n```bash\nscp  ./2_huguobo.site.key ./1_huguobo.site_bundle.crt  root@118.24.215.220:/usr/local/nginx/conf\n```\n登录云主机 nginx 配置\n```bash\n# Settings for a TLS enabled server.\n\n    server {\n        listen       443 ssl http2 default_server;\n        listen       [::]:443 ssl http2 default_server;\n        server_name  huguobo.site;\n\n        ssl on;\n        ssl_certificate \"/usr/local/nginx/conf/1_huguobo.site_bundle.crt\";\n        ssl_certificate_key \"/usr/local/nginx/conf/2_huguobo.site.key\";\n        ssl_session_cache shared:SSL:1m;\n        ssl_session_timeout  10m;\n        ssl_protocols TLSv1 TLSv1.1 TLSv1.2;\n        ssl_prefer_server_ciphers on;\n        ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE; #请按照这个套件配置，配置加密套件，写法遵循 openssl 标准。\n\n        # Load configuration files for the default server block.\n        include /etc/nginx/default.d/*.conf;\n\n        location / {\n           root /home/hexoBlog; # your path\n           index index.html;\n        }\n\n        error_page 404 /404.html;\n            location = /40x.html {\n        }\n        error_page 500 502 503 504 /50x.html;\n            location = /50x.html {\n        }\n   }\n\n```\n## 强制HTTPS\n我没有做强制https。但是需要的话，改下 nginx 配置文件即可\nhttp 默认是`80`端口 ，https 是`443`端口\n```bash\nserver{\n      listen 80;    #表示监听80端口\n      server_name huguobo.site\n      location / {    #将80端口强制转为https\n          rewrite (.*) https://huguobo.site$1 permanent;\n      }\n}\n```\n","source":"_posts/nginx配置ssl.md","raw":"---\ntitle: Nginx 配置 SSL\ndate: 2019-08-31 10:35:31\ncategories: \n- Nginx\ntags:\n- nginx\n- devOps\n---\n\n> 域名貌似备案成功了，解析到腾讯云服务器ip后，发现直接访问 http协议 是可以的 换成 https 不行了。应该是没有配置SSL导致的。\n\n## 什么是HTTPS\nhttps 全称：Hyper Text Transfer Protocol over Secure Socket Layer，是http的安全版。即http下加入SSL协议层，因此https的安全基础就是SSL，所以加密内容需要SSL。\n\n## SSL原理\n- 浏览器发送一个https的请求给服务器；\n- 服务器要有一套数字证书，可以自己制作，也可以向组织申请，区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面，这套证书其实就是一对公钥和私钥；\n- 服务器会把公钥传输给客户端；\n- 客户端（浏览器）收到公钥后，会验证其是否合法有效，无效会有警告提醒，有效则会生成一串随机数，并用收到的公钥加密；\n- 客户端把加密后的随机字符串传输给服务器；\n- 服务器收到加密随机字符串后，先用私钥解密（公钥加密，私钥解密），获取到这一串随机数后，再用这串随机字符串加密传输的数据（该加密为对称加密，所谓对称加密，就是将数据和私钥也就是这个随机字符串>通过某种算法混合在一起，这样除非知道私钥，否则无法获取数据内容）；\n- 服务器把加密后的数据传输给客户端；\n- 客户端收到数据后，再用自己的私钥也就是那个随机字符串解密；\n\n## 配置 with-http_ssl_module 模块\n首先需要申请一个证书，可以申请一个免费的。\n参考下面的 `其他方式` 部分可以直接在云服务厂商可视化界面申请并下载~\n然后会得到nginx版本证书，一个公钥（证书），一个私钥，将其上传到服务器。\n\n先确认`nginx`安装时已编译`http_ssl`模块，也就是执行`nginx -V`命令查看是否存在 `--with-http_ssl_module`。如果没有，则需要重新编译nginx将该模块加入。\n若有的话此步骤跳过\n若ssl模块没有先编译一下\n\n```bash\ncd /usr/local/src/nginx-1.12.1/  #nginx版本号可能不同哟\n\n./configure --help | grep -i ssl\n  --with-http_ssl_module \n  \n./configure --prefix=/usr/local/nginx --with-http_ssl_module\n\n```\n\n## 生成 ssl 秘钥对\n```bash\ncd /usr/local/nginx/conf\n\nyum install -y openssl\n```\n\n### 使用RSA算法生产key\n```bash\nopenssl genrsa -des3 -out tmp.key 2048\n# 生成一个rsa类型的密钥，且长度为2048，但是我们有发现，让我们设置密码，如果每次有人访问我们的站点，都需要输入密码，太麻烦了\n```\n所以我们要转换私钥，取消密码（其实tmp.key与zhdy.key密钥内容是一样的，只不过一个有密码一个没有）：\n```bash\nopenssl rsa -in tmp.key -out zhdy.key \n\nrm -f tmp.key\n```\n### 创建证书申请\n```\nopenssl req -new -key zhdy.key -out zhdy.csr\n```\n\n### 创建自签名的证书\n```bash\nopenssl x509 -req -days 365 -in zhdy.csr -signkey zhdy.key -out zhdy.crt\n```\n\n## Nginx 配置 ssl\n```bash\nserver\n{\n    listen 443;\n    server_name huguobo.site; # 换成你自己的域名服务哟\n    index index.html index.php;\n    root /path/to/your/file \n    ssl on;\n    ssl_certificate zhdy.crt;\n    ssl_certificate_key zhdy.key;\n    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;\n}\n\n# ssl on; 代表着打开ssl\n#ssl_certificate zhdy.crt; 公钥\n# ssl_certificate_key zhdy.key; 私钥\n# ssl_protocols TLSv1 TLSv1.1 TLSv1.2; 三种不同的协议\n```\n\n## 测试\n```bash\nnginx -t\nnginx restart\n```\n\n由于已经设置了443，所以我们使用curl -x 是不生效的。\n我们修改下/etc/hosts为: `yourip www.aaa.com`\n\n```bash\ncurl https://haha.com\n```\n报错显示为“此证书非安全证书”，但是ssl是已经成功配置了\n\n## 其他方式（更快捷）\n后来发现各个厂商也提供申请证书的入口，也提供 DNS 和 文件验证两种配置,大家也可以自行参考配置\n[腾讯云ssl控制台](https://console.cloud.tencent.com/ssl)\n[nginx配置文档](https://cloud.tencent.com/document/product/400/35244)\n\n这种从供应商处可以直接下载到证书，然后nginx的配置秘钥和证书都在 nginx 文件夹下\n\n从客户端传送文件到云主机（MAC）\n```bash\nscp  ./2_huguobo.site.key ./1_huguobo.site_bundle.crt  root@118.24.215.220:/usr/local/nginx/conf\n```\n登录云主机 nginx 配置\n```bash\n# Settings for a TLS enabled server.\n\n    server {\n        listen       443 ssl http2 default_server;\n        listen       [::]:443 ssl http2 default_server;\n        server_name  huguobo.site;\n\n        ssl on;\n        ssl_certificate \"/usr/local/nginx/conf/1_huguobo.site_bundle.crt\";\n        ssl_certificate_key \"/usr/local/nginx/conf/2_huguobo.site.key\";\n        ssl_session_cache shared:SSL:1m;\n        ssl_session_timeout  10m;\n        ssl_protocols TLSv1 TLSv1.1 TLSv1.2;\n        ssl_prefer_server_ciphers on;\n        ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE; #请按照这个套件配置，配置加密套件，写法遵循 openssl 标准。\n\n        # Load configuration files for the default server block.\n        include /etc/nginx/default.d/*.conf;\n\n        location / {\n           root /home/hexoBlog; # your path\n           index index.html;\n        }\n\n        error_page 404 /404.html;\n            location = /40x.html {\n        }\n        error_page 500 502 503 504 /50x.html;\n            location = /50x.html {\n        }\n   }\n\n```\n## 强制HTTPS\n我没有做强制https。但是需要的话，改下 nginx 配置文件即可\nhttp 默认是`80`端口 ，https 是`443`端口\n```bash\nserver{\n      listen 80;    #表示监听80端口\n      server_name huguobo.site\n      location / {    #将80端口强制转为https\n          rewrite (.*) https://huguobo.site$1 permanent;\n      }\n}\n```\n","slug":"nginx配置ssl","published":1,"updated":"2019-09-02T11:08:41.495Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck03fz4af0002oloxrg21ox0i","content":"<blockquote>\n<p>域名貌似备案成功了，解析到腾讯云服务器ip后，发现直接访问 http协议 是可以的 换成 https 不行了。应该是没有配置SSL导致的。</p>\n</blockquote>\n<h2 id=\"什么是HTTPS\"><a href=\"#什么是HTTPS\" class=\"headerlink\" title=\"什么是HTTPS\"></a>什么是HTTPS</h2><p>https 全称：Hyper Text Transfer Protocol over Secure Socket Layer，是http的安全版。即http下加入SSL协议层，因此https的安全基础就是SSL，所以加密内容需要SSL。</p>\n<h2 id=\"SSL原理\"><a href=\"#SSL原理\" class=\"headerlink\" title=\"SSL原理\"></a>SSL原理</h2><ul>\n<li>浏览器发送一个https的请求给服务器；</li>\n<li>服务器要有一套数字证书，可以自己制作，也可以向组织申请，区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面，这套证书其实就是一对公钥和私钥；</li>\n<li>服务器会把公钥传输给客户端；</li>\n<li>客户端（浏览器）收到公钥后，会验证其是否合法有效，无效会有警告提醒，有效则会生成一串随机数，并用收到的公钥加密；</li>\n<li>客户端把加密后的随机字符串传输给服务器；</li>\n<li>服务器收到加密随机字符串后，先用私钥解密（公钥加密，私钥解密），获取到这一串随机数后，再用这串随机字符串加密传输的数据（该加密为对称加密，所谓对称加密，就是将数据和私钥也就是这个随机字符串&gt;通过某种算法混合在一起，这样除非知道私钥，否则无法获取数据内容）；</li>\n<li>服务器把加密后的数据传输给客户端；</li>\n<li>客户端收到数据后，再用自己的私钥也就是那个随机字符串解密；</li>\n</ul>\n<h2 id=\"配置-with-http-ssl-module-模块\"><a href=\"#配置-with-http-ssl-module-模块\" class=\"headerlink\" title=\"配置 with-http_ssl_module 模块\"></a>配置 with-http_ssl_module 模块</h2><p>首先需要申请一个证书，可以申请一个免费的。<br>参考下面的 <code>其他方式</code> 部分可以直接在云服务厂商可视化界面申请并下载~<br>然后会得到nginx版本证书，一个公钥（证书），一个私钥，将其上传到服务器。</p>\n<p>先确认<code>nginx</code>安装时已编译<code>http_ssl</code>模块，也就是执行<code>nginx -V</code>命令查看是否存在 <code>--with-http_ssl_module</code>。如果没有，则需要重新编译nginx将该模块加入。<br>若有的话此步骤跳过<br>若ssl模块没有先编译一下</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> /usr/<span class=\"built_in\">local</span>/src/nginx-1.12.1/  <span class=\"comment\">#nginx版本号可能不同哟</span></span><br><span class=\"line\"></span><br><span class=\"line\">./configure --<span class=\"built_in\">help</span> | grep -i ssl</span><br><span class=\"line\">  --with-http_ssl_module </span><br><span class=\"line\">  </span><br><span class=\"line\">./configure --prefix=/usr/<span class=\"built_in\">local</span>/nginx --with-http_ssl_module</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"生成-ssl-秘钥对\"><a href=\"#生成-ssl-秘钥对\" class=\"headerlink\" title=\"生成 ssl 秘钥对\"></a>生成 ssl 秘钥对</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> /usr/<span class=\"built_in\">local</span>/nginx/conf</span><br><span class=\"line\"></span><br><span class=\"line\">yum install -y openssl</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用RSA算法生产key\"><a href=\"#使用RSA算法生产key\" class=\"headerlink\" title=\"使用RSA算法生产key\"></a>使用RSA算法生产key</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">openssl genrsa -des3 -out tmp.key 2048</span><br><span class=\"line\"><span class=\"comment\"># 生成一个rsa类型的密钥，且长度为2048，但是我们有发现，让我们设置密码，如果每次有人访问我们的站点，都需要输入密码，太麻烦了</span></span><br></pre></td></tr></table></figure>\n\n<p>所以我们要转换私钥，取消密码（其实tmp.key与zhdy.key密钥内容是一样的，只不过一个有密码一个没有）：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">openssl rsa -<span class=\"keyword\">in</span> tmp.key -out zhdy.key </span><br><span class=\"line\"></span><br><span class=\"line\">rm -f tmp.key</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"创建证书申请\"><a href=\"#创建证书申请\" class=\"headerlink\" title=\"创建证书申请\"></a>创建证书申请</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">openssl req -new -key zhdy.key -out zhdy.csr</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"创建自签名的证书\"><a href=\"#创建自签名的证书\" class=\"headerlink\" title=\"创建自签名的证书\"></a>创建自签名的证书</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">openssl x509 -req -days 365 -<span class=\"keyword\">in</span> zhdy.csr -signkey zhdy.key -out zhdy.crt</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Nginx-配置-ssl\"><a href=\"#Nginx-配置-ssl\" class=\"headerlink\" title=\"Nginx 配置 ssl\"></a>Nginx 配置 ssl</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    listen 443;</span><br><span class=\"line\">    server_name huguobo.site; <span class=\"comment\"># 换成你自己的域名服务哟</span></span><br><span class=\"line\">    index index.html index.php;</span><br><span class=\"line\">    root /path/to/your/file </span><br><span class=\"line\">    ssl on;</span><br><span class=\"line\">    ssl_certificate zhdy.crt;</span><br><span class=\"line\">    ssl_certificate_key zhdy.key;</span><br><span class=\"line\">    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># ssl on; 代表着打开ssl</span></span><br><span class=\"line\"><span class=\"comment\">#ssl_certificate zhdy.crt; 公钥</span></span><br><span class=\"line\"><span class=\"comment\"># ssl_certificate_key zhdy.key; 私钥</span></span><br><span class=\"line\"><span class=\"comment\"># ssl_protocols TLSv1 TLSv1.1 TLSv1.2; 三种不同的协议</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nginx -t</span><br><span class=\"line\">nginx restart</span><br></pre></td></tr></table></figure>\n\n<p>由于已经设置了443，所以我们使用curl -x 是不生效的。<br>我们修改下/etc/hosts为: <code>yourip www.aaa.com</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl https://haha.com</span><br></pre></td></tr></table></figure>\n\n<p>报错显示为“此证书非安全证书”，但是ssl是已经成功配置了</p>\n<h2 id=\"其他方式（更快捷）\"><a href=\"#其他方式（更快捷）\" class=\"headerlink\" title=\"其他方式（更快捷）\"></a>其他方式（更快捷）</h2><p>后来发现各个厂商也提供申请证书的入口，也提供 DNS 和 文件验证两种配置,大家也可以自行参考配置<br><a href=\"https://console.cloud.tencent.com/ssl\" target=\"_blank\" rel=\"noopener\">腾讯云ssl控制台</a><br><a href=\"https://cloud.tencent.com/document/product/400/35244\" target=\"_blank\" rel=\"noopener\">nginx配置文档</a></p>\n<p>这种从供应商处可以直接下载到证书，然后nginx的配置秘钥和证书都在 nginx 文件夹下</p>\n<p>从客户端传送文件到云主机（MAC）</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scp  ./2_huguobo.site.key ./1_huguobo.site_bundle.crt  root@118.24.215.220:/usr/<span class=\"built_in\">local</span>/nginx/conf</span><br></pre></td></tr></table></figure>\n\n<p>登录云主机 nginx 配置</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Settings for a TLS enabled server.</span></span><br><span class=\"line\"></span><br><span class=\"line\">    server &#123;</span><br><span class=\"line\">        listen       443 ssl http2 default_server;</span><br><span class=\"line\">        listen       [::]:443 ssl http2 default_server;</span><br><span class=\"line\">        server_name  huguobo.site;</span><br><span class=\"line\"></span><br><span class=\"line\">        ssl on;</span><br><span class=\"line\">        ssl_certificate <span class=\"string\">\"/usr/local/nginx/conf/1_huguobo.site_bundle.crt\"</span>;</span><br><span class=\"line\">        ssl_certificate_key <span class=\"string\">\"/usr/local/nginx/conf/2_huguobo.site.key\"</span>;</span><br><span class=\"line\">        ssl_session_cache shared:SSL:1m;</span><br><span class=\"line\">        ssl_session_timeout  10m;</span><br><span class=\"line\">        ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class=\"line\">        ssl_prefer_server_ciphers on;</span><br><span class=\"line\">        ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE; <span class=\"comment\">#请按照这个套件配置，配置加密套件，写法遵循 openssl 标准。</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># Load configuration files for the default server block.</span></span><br><span class=\"line\">        include /etc/nginx/default.d/*.conf;</span><br><span class=\"line\"></span><br><span class=\"line\">        location / &#123;</span><br><span class=\"line\">           root /home/hexoBlog; <span class=\"comment\"># your path</span></span><br><span class=\"line\">           index index.html;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        error_page 404 /404.html;</span><br><span class=\"line\">            location = /40x.html &#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        error_page 500 502 503 504 /50x.html;</span><br><span class=\"line\">            location = /50x.html &#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"强制HTTPS\"><a href=\"#强制HTTPS\" class=\"headerlink\" title=\"强制HTTPS\"></a>强制HTTPS</h2><p>我没有做强制https。但是需要的话，改下 nginx 配置文件即可<br>http 默认是<code>80</code>端口 ，https 是<code>443</code>端口</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server&#123;</span><br><span class=\"line\">      listen 80;    <span class=\"comment\">#表示监听80端口</span></span><br><span class=\"line\">      server_name huguobo.site</span><br><span class=\"line\">      location / &#123;    <span class=\"comment\">#将80端口强制转为https</span></span><br><span class=\"line\">          rewrite (.*) https://huguobo.site<span class=\"variable\">$1</span> permanent;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>域名貌似备案成功了，解析到腾讯云服务器ip后，发现直接访问 http协议 是可以的 换成 https 不行了。应该是没有配置SSL导致的。</p>\n</blockquote>\n<h2 id=\"什么是HTTPS\"><a href=\"#什么是HTTPS\" class=\"headerlink\" title=\"什么是HTTPS\"></a>什么是HTTPS</h2><p>https 全称：Hyper Text Transfer Protocol over Secure Socket Layer，是http的安全版。即http下加入SSL协议层，因此https的安全基础就是SSL，所以加密内容需要SSL。</p>\n<h2 id=\"SSL原理\"><a href=\"#SSL原理\" class=\"headerlink\" title=\"SSL原理\"></a>SSL原理</h2><ul>\n<li>浏览器发送一个https的请求给服务器；</li>\n<li>服务器要有一套数字证书，可以自己制作，也可以向组织申请，区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面，这套证书其实就是一对公钥和私钥；</li>\n<li>服务器会把公钥传输给客户端；</li>\n<li>客户端（浏览器）收到公钥后，会验证其是否合法有效，无效会有警告提醒，有效则会生成一串随机数，并用收到的公钥加密；</li>\n<li>客户端把加密后的随机字符串传输给服务器；</li>\n<li>服务器收到加密随机字符串后，先用私钥解密（公钥加密，私钥解密），获取到这一串随机数后，再用这串随机字符串加密传输的数据（该加密为对称加密，所谓对称加密，就是将数据和私钥也就是这个随机字符串&gt;通过某种算法混合在一起，这样除非知道私钥，否则无法获取数据内容）；</li>\n<li>服务器把加密后的数据传输给客户端；</li>\n<li>客户端收到数据后，再用自己的私钥也就是那个随机字符串解密；</li>\n</ul>\n<h2 id=\"配置-with-http-ssl-module-模块\"><a href=\"#配置-with-http-ssl-module-模块\" class=\"headerlink\" title=\"配置 with-http_ssl_module 模块\"></a>配置 with-http_ssl_module 模块</h2><p>首先需要申请一个证书，可以申请一个免费的。<br>参考下面的 <code>其他方式</code> 部分可以直接在云服务厂商可视化界面申请并下载~<br>然后会得到nginx版本证书，一个公钥（证书），一个私钥，将其上传到服务器。</p>\n<p>先确认<code>nginx</code>安装时已编译<code>http_ssl</code>模块，也就是执行<code>nginx -V</code>命令查看是否存在 <code>--with-http_ssl_module</code>。如果没有，则需要重新编译nginx将该模块加入。<br>若有的话此步骤跳过<br>若ssl模块没有先编译一下</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> /usr/<span class=\"built_in\">local</span>/src/nginx-1.12.1/  <span class=\"comment\">#nginx版本号可能不同哟</span></span><br><span class=\"line\"></span><br><span class=\"line\">./configure --<span class=\"built_in\">help</span> | grep -i ssl</span><br><span class=\"line\">  --with-http_ssl_module </span><br><span class=\"line\">  </span><br><span class=\"line\">./configure --prefix=/usr/<span class=\"built_in\">local</span>/nginx --with-http_ssl_module</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"生成-ssl-秘钥对\"><a href=\"#生成-ssl-秘钥对\" class=\"headerlink\" title=\"生成 ssl 秘钥对\"></a>生成 ssl 秘钥对</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> /usr/<span class=\"built_in\">local</span>/nginx/conf</span><br><span class=\"line\"></span><br><span class=\"line\">yum install -y openssl</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用RSA算法生产key\"><a href=\"#使用RSA算法生产key\" class=\"headerlink\" title=\"使用RSA算法生产key\"></a>使用RSA算法生产key</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">openssl genrsa -des3 -out tmp.key 2048</span><br><span class=\"line\"><span class=\"comment\"># 生成一个rsa类型的密钥，且长度为2048，但是我们有发现，让我们设置密码，如果每次有人访问我们的站点，都需要输入密码，太麻烦了</span></span><br></pre></td></tr></table></figure>\n\n<p>所以我们要转换私钥，取消密码（其实tmp.key与zhdy.key密钥内容是一样的，只不过一个有密码一个没有）：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">openssl rsa -<span class=\"keyword\">in</span> tmp.key -out zhdy.key </span><br><span class=\"line\"></span><br><span class=\"line\">rm -f tmp.key</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"创建证书申请\"><a href=\"#创建证书申请\" class=\"headerlink\" title=\"创建证书申请\"></a>创建证书申请</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">openssl req -new -key zhdy.key -out zhdy.csr</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"创建自签名的证书\"><a href=\"#创建自签名的证书\" class=\"headerlink\" title=\"创建自签名的证书\"></a>创建自签名的证书</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">openssl x509 -req -days 365 -<span class=\"keyword\">in</span> zhdy.csr -signkey zhdy.key -out zhdy.crt</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Nginx-配置-ssl\"><a href=\"#Nginx-配置-ssl\" class=\"headerlink\" title=\"Nginx 配置 ssl\"></a>Nginx 配置 ssl</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    listen 443;</span><br><span class=\"line\">    server_name huguobo.site; <span class=\"comment\"># 换成你自己的域名服务哟</span></span><br><span class=\"line\">    index index.html index.php;</span><br><span class=\"line\">    root /path/to/your/file </span><br><span class=\"line\">    ssl on;</span><br><span class=\"line\">    ssl_certificate zhdy.crt;</span><br><span class=\"line\">    ssl_certificate_key zhdy.key;</span><br><span class=\"line\">    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># ssl on; 代表着打开ssl</span></span><br><span class=\"line\"><span class=\"comment\">#ssl_certificate zhdy.crt; 公钥</span></span><br><span class=\"line\"><span class=\"comment\"># ssl_certificate_key zhdy.key; 私钥</span></span><br><span class=\"line\"><span class=\"comment\"># ssl_protocols TLSv1 TLSv1.1 TLSv1.2; 三种不同的协议</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nginx -t</span><br><span class=\"line\">nginx restart</span><br></pre></td></tr></table></figure>\n\n<p>由于已经设置了443，所以我们使用curl -x 是不生效的。<br>我们修改下/etc/hosts为: <code>yourip www.aaa.com</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl https://haha.com</span><br></pre></td></tr></table></figure>\n\n<p>报错显示为“此证书非安全证书”，但是ssl是已经成功配置了</p>\n<h2 id=\"其他方式（更快捷）\"><a href=\"#其他方式（更快捷）\" class=\"headerlink\" title=\"其他方式（更快捷）\"></a>其他方式（更快捷）</h2><p>后来发现各个厂商也提供申请证书的入口，也提供 DNS 和 文件验证两种配置,大家也可以自行参考配置<br><a href=\"https://console.cloud.tencent.com/ssl\" target=\"_blank\" rel=\"noopener\">腾讯云ssl控制台</a><br><a href=\"https://cloud.tencent.com/document/product/400/35244\" target=\"_blank\" rel=\"noopener\">nginx配置文档</a></p>\n<p>这种从供应商处可以直接下载到证书，然后nginx的配置秘钥和证书都在 nginx 文件夹下</p>\n<p>从客户端传送文件到云主机（MAC）</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scp  ./2_huguobo.site.key ./1_huguobo.site_bundle.crt  root@118.24.215.220:/usr/<span class=\"built_in\">local</span>/nginx/conf</span><br></pre></td></tr></table></figure>\n\n<p>登录云主机 nginx 配置</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Settings for a TLS enabled server.</span></span><br><span class=\"line\"></span><br><span class=\"line\">    server &#123;</span><br><span class=\"line\">        listen       443 ssl http2 default_server;</span><br><span class=\"line\">        listen       [::]:443 ssl http2 default_server;</span><br><span class=\"line\">        server_name  huguobo.site;</span><br><span class=\"line\"></span><br><span class=\"line\">        ssl on;</span><br><span class=\"line\">        ssl_certificate <span class=\"string\">\"/usr/local/nginx/conf/1_huguobo.site_bundle.crt\"</span>;</span><br><span class=\"line\">        ssl_certificate_key <span class=\"string\">\"/usr/local/nginx/conf/2_huguobo.site.key\"</span>;</span><br><span class=\"line\">        ssl_session_cache shared:SSL:1m;</span><br><span class=\"line\">        ssl_session_timeout  10m;</span><br><span class=\"line\">        ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class=\"line\">        ssl_prefer_server_ciphers on;</span><br><span class=\"line\">        ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE; <span class=\"comment\">#请按照这个套件配置，配置加密套件，写法遵循 openssl 标准。</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># Load configuration files for the default server block.</span></span><br><span class=\"line\">        include /etc/nginx/default.d/*.conf;</span><br><span class=\"line\"></span><br><span class=\"line\">        location / &#123;</span><br><span class=\"line\">           root /home/hexoBlog; <span class=\"comment\"># your path</span></span><br><span class=\"line\">           index index.html;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        error_page 404 /404.html;</span><br><span class=\"line\">            location = /40x.html &#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        error_page 500 502 503 504 /50x.html;</span><br><span class=\"line\">            location = /50x.html &#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"强制HTTPS\"><a href=\"#强制HTTPS\" class=\"headerlink\" title=\"强制HTTPS\"></a>强制HTTPS</h2><p>我没有做强制https。但是需要的话，改下 nginx 配置文件即可<br>http 默认是<code>80</code>端口 ，https 是<code>443</code>端口</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server&#123;</span><br><span class=\"line\">      listen 80;    <span class=\"comment\">#表示监听80端口</span></span><br><span class=\"line\">      server_name huguobo.site</span><br><span class=\"line\">      location / &#123;    <span class=\"comment\">#将80端口强制转为https</span></span><br><span class=\"line\">          rewrite (.*) https://huguobo.site<span class=\"variable\">$1</span> permanent;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n"},{"title":"关于这个网站","date":"2019-08-30T07:53:09.000Z","_content":"\n## WHAT\n个人生活记录网站。(希望能通过备案)\n希望把所有有意义的东西都记录下来，包括但不限于技术范围。\n个人使用，能帮助到人就更好了。\n\n\n## WHY\n上学时候的 [Blog](http://huguobo.github.io) 用的是 [jekyll](https://jekyllrb.com/)+ [GithubPages](https://pages.github.com/)。\n好久没有更新和维护了, 不是很熟悉 ruby，也不想继续浪费 github 的资源。\n加上发觉自己工作后的积累和沉淀明显不够，开始着手使用基于 [node](https://nodejs.org) 的 [hexo](https://hexo.io/zh-cn/) 和自己的云服务器搭建了这个网站。\n\n## HOW\n富强、民主、文明、和谐、自由、平等、公正、法治、爱国、敬业、诚信、友善。\n合法、合规、合理。\nLOVE AND PEACE。","source":"_posts/新网站.md","raw":"---\ntitle: 关于这个网站\ndate: 2019-08-30 15:53:09\ncategories: \n- daily\ntags: \n- 白话\n---\n\n## WHAT\n个人生活记录网站。(希望能通过备案)\n希望把所有有意义的东西都记录下来，包括但不限于技术范围。\n个人使用，能帮助到人就更好了。\n\n\n## WHY\n上学时候的 [Blog](http://huguobo.github.io) 用的是 [jekyll](https://jekyllrb.com/)+ [GithubPages](https://pages.github.com/)。\n好久没有更新和维护了, 不是很熟悉 ruby，也不想继续浪费 github 的资源。\n加上发觉自己工作后的积累和沉淀明显不够，开始着手使用基于 [node](https://nodejs.org) 的 [hexo](https://hexo.io/zh-cn/) 和自己的云服务器搭建了这个网站。\n\n## HOW\n富强、民主、文明、和谐、自由、平等、公正、法治、爱国、敬业、诚信、友善。\n合法、合规、合理。\nLOVE AND PEACE。","slug":"新网站","published":1,"updated":"2019-09-02T01:37:30.425Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck03fz4aj0006oloxsnupr663","content":"<h2 id=\"WHAT\"><a href=\"#WHAT\" class=\"headerlink\" title=\"WHAT\"></a>WHAT</h2><p>个人生活记录网站。(希望能通过备案)<br>希望把所有有意义的东西都记录下来，包括但不限于技术范围。<br>个人使用，能帮助到人就更好了。</p>\n<h2 id=\"WHY\"><a href=\"#WHY\" class=\"headerlink\" title=\"WHY\"></a>WHY</h2><p>上学时候的 <a href=\"http://huguobo.github.io\" target=\"_blank\" rel=\"noopener\">Blog</a> 用的是 <a href=\"https://jekyllrb.com/\" target=\"_blank\" rel=\"noopener\">jekyll</a>+ <a href=\"https://pages.github.com/\" target=\"_blank\" rel=\"noopener\">GithubPages</a>。<br>好久没有更新和维护了, 不是很熟悉 ruby，也不想继续浪费 github 的资源。<br>加上发觉自己工作后的积累和沉淀明显不够，开始着手使用基于 <a href=\"https://nodejs.org\" target=\"_blank\" rel=\"noopener\">node</a> 的 <a href=\"https://hexo.io/zh-cn/\" target=\"_blank\" rel=\"noopener\">hexo</a> 和自己的云服务器搭建了这个网站。</p>\n<h2 id=\"HOW\"><a href=\"#HOW\" class=\"headerlink\" title=\"HOW\"></a>HOW</h2><p>富强、民主、文明、和谐、自由、平等、公正、法治、爱国、敬业、诚信、友善。<br>合法、合规、合理。<br>LOVE AND PEACE。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"WHAT\"><a href=\"#WHAT\" class=\"headerlink\" title=\"WHAT\"></a>WHAT</h2><p>个人生活记录网站。(希望能通过备案)<br>希望把所有有意义的东西都记录下来，包括但不限于技术范围。<br>个人使用，能帮助到人就更好了。</p>\n<h2 id=\"WHY\"><a href=\"#WHY\" class=\"headerlink\" title=\"WHY\"></a>WHY</h2><p>上学时候的 <a href=\"http://huguobo.github.io\" target=\"_blank\" rel=\"noopener\">Blog</a> 用的是 <a href=\"https://jekyllrb.com/\" target=\"_blank\" rel=\"noopener\">jekyll</a>+ <a href=\"https://pages.github.com/\" target=\"_blank\" rel=\"noopener\">GithubPages</a>。<br>好久没有更新和维护了, 不是很熟悉 ruby，也不想继续浪费 github 的资源。<br>加上发觉自己工作后的积累和沉淀明显不够，开始着手使用基于 <a href=\"https://nodejs.org\" target=\"_blank\" rel=\"noopener\">node</a> 的 <a href=\"https://hexo.io/zh-cn/\" target=\"_blank\" rel=\"noopener\">hexo</a> 和自己的云服务器搭建了这个网站。</p>\n<h2 id=\"HOW\"><a href=\"#HOW\" class=\"headerlink\" title=\"HOW\"></a>HOW</h2><p>富强、民主、文明、和谐、自由、平等、公正、法治、爱国、敬业、诚信、友善。<br>合法、合规、合理。<br>LOVE AND PEACE。</p>\n"},{"title":"程序员夫妇的周末","date":"2019-09-01T02:40:28.000Z","_content":"\n![weekend](/images/weekend.jpeg)\n\nhave a nice day~","source":"_posts/weekend.md","raw":"---\ntitle: 程序员夫妇的周末\ndate: 2019-09-01 10:40:28\ncategories: \n- daily\ntags:\n- 日常\n- 白话\n---\n\n![weekend](/images/weekend.jpeg)\n\nhave a nice day~","slug":"weekend","published":1,"updated":"2019-09-02T01:37:27.401Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck03fz4ak0007oloxajw9adhb","content":"<p><img src=\"/images/weekend.jpeg\" alt=\"weekend\"></p>\n<p>have a nice day~</p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"/images/weekend.jpeg\" alt=\"weekend\"></p>\n<p>have a nice day~</p>\n"},{"title":"Travis-CI 持续集成 hexo 到云服务器","date":"2019-09-01T10:35:40.000Z","_content":"\n> 烦：每次本地提交代码到 GitHub 上后还要自己手动同步文件到云服务器，完成所谓的部署工作有点麻烦和脱节。\n> 懒：程序员等所有自称工程师进步的先决动力，想实现一个我每次提交代码后，后面的构建，打包和部署都自动进行的流程。\n> 因为本身代码托管在 Github 上，所以就开始折腾 Travis-CI了。\n\n\n## 什么是CI\n持续集成服务（Continuous Integration，简称 CI）。\n一般指的是提供一个运行环境，自动化执行单元测试，规范检查，基于环境的构建，服务部署等流水线作业。\n持续集成的目的，就是让产品可以快速迭代，同时还能保持高质量。\n另外，这个是工程化实践，如果你觉得自己手动操作比整这些繁琐的流程方便多了，我觉得也是没问题的。\n\n## Travis CI \n[Travis CI](https://travis-ci.com/) 对 Github 上的开源项目提供免费服务，这要求必须有 Github 账号。界面也很赞~，让我想起了前东家的 PLUS 发布系统。 \n![travis](/images/travis.png)\n可以使用 github 账号直接登录， public 的仓库也直接同步到 Travis 上了， 选择想开启 Travis CI 的仓库，打开开关即可。详细配置不细说了，图形化界面，进去就知道了。\n\n### .travis.yml\nTravis-CI配置文件，存放在项目根目录下。\n支持多种语言，在配置文件中 `language: node_js`\n一个比较完整的生命周期\n\n```bash\nbefore_install\ninstall\nbefore_script\nscript\naftersuccess or afterfailure\n[OPTIONAL] before_deploy\n[OPTIONAL] deploy\n[OPTIONAL] after_deploy\nafter_script\n```\n详细配置参考 [官方文档](https://docs.travis-ci.com)\n\n## 一些准备工作\n由于后面的免密登录和部署流程会涉及一些环境和配置类的操作，这个部分介绍下前置条件。\n\n### SCP命令\nscp 命令用于linux下的跨主机之间的文件和目录复制\n在首次连接服务器时，会弹出公钥确认的提示。这会导致某些自动化任务，由于初次连接服务器而导致自动化任务中断，\n可在 StrictHostKeyChecking选项，用 -o 参数指定后，则不检查该项。\n\n```bash\nscp [可选参数] file_source file_target\n#将public目录下的所有文件复制到$DEPLOY_IP下的/path/to/blog目录中。不检查key，\nscp -o StrictHostKeyChecking=no -r public/*  user@$DEPLOY_IP:/path/to/blog/\n#可用-i指定私钥。\nscp -o  StrictHostKeyChecking=no -i .ssh/id_rsa yourfile user@destinate_ip:/dest_folder\n#或将自己的公钥放到目标机的authorized_keys文件里，使自己为目标机的信任机器，实现无密码登录\n#这个是在生成ssh key 后，将公钥放到authorized_keys文件中。使用密钥对可以实现不输入密码\ncd ~/.ssh\ncat id_rsa.pub >> authorized_keys\n```\n\n### rsync 命令\n最终采用了 rsync 命令，我觉得都行，主要是这个同步成功了。\n```bash\nrsync -e \"ssh -o PubkeyAuthentication=yes  -o stricthostkeychecking=no\" -r --delete-after --quiet $TRAVIS_BUILD_DIR/public/* root@$DEPLOY_IP:/opt/hexoBlog\n```\n\n### centOS使用gem\n因为后面要使用 `gem install travis` ,所以可能会需要 升级 ruby 和 切换 gem 源（亲测 ruby 版本低会安装报错，gem 用官方源真的是动都不动啊，太难了）\n\n\n#### 切换gem源\n```bash\n$ gem sources --add https://gems.ruby-china.com/ --remove https://rubygems.org/\n$ gem sources -l\nhttps://gems.ruby-china.com\n# 确保只有 gems.ruby-china.com\n$ gem update --system \n$ gem -v\n2.6.3\n```\n#### 升级Ruby\n安装[RAM](https://rvm.io/), 一款ruby版本管理工具，类似 node 的 nvm。\n```bash\ngpg --keyserver hkp://keys.gnupg.net --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3 7D2BAF1CF37B13E2069D6956105BD0E739499BDB\ncurl -sSL https://get.rvm.io | bash -s stable\nsource /etc/profile.d/rvm.sh\nrvm -v\n```\n\n安装新版 ruby\n```bash\nrvm install 2.6\n```\n\n## 自动部署到远程服务器\n对于项目的构建来说都是 执行配置文件中写好的脚本，这个项目可能 就是 `npm install && hexo clean && hexo g`, 那么怎么执行最后一步，把文件同步传输到 云服务器上呢。 我们使用CI就是手动过程太繁琐，重复没有意义，怎么实现 `免密` 部署呢。\n\n登录到 `云服务器(centOS 7.x)`,进行如下操作\n### gem install travis 并登录\n```bash\ngem install travis #  这步失败的话请看上面关于升级ruby和切换gem源的部分\ntravis login\n```\n登录 github 账号密码，这个安全直接连接的 github 服务\n![login](/images/login.png)\n\n### 生成 ssh key 并输出对应加密的私钥到 travis \n进到云服务器对应的 git 仓库目录里\n```bash\nssh-keygen -t rsa -b 4096 -C 'build@travis-ci.org' -f ./deploy_rsa\ntravis encrypt-file deploy_rsa --add\nssh-copy-id -i deploy_rsa.pub <ssh-user>@<deploy-host>\n\nrm -f deploy_rsa deploy_rsa.pub\ngit add deploy_rsa.enc .travis.yml\n```\n项目根目录下的 `deploy_rsa.enc` 文件就是我们加密的私钥文件， `.travis.yml` 是我们的配置文件。\n$encrypted_XXXXXX_key 和 $encrypted_XXXXXXXX_iv 是travis 帮忙生成的环境变量，已经同步到 huguobo/hexo-blog 这个项目上了。\n![iv](/images/iv.png)\n\n还有一点可能会用上，因为 travis 第一次登录远程服务器会出现 SSH 主机验证，这边会有一个主机信任问题。官方给出的方案是添加 addons 配置，然后修改 .travis.yml 的相关配置\n```bash\naddons:\n  ssh_known_hosts: your-ip\n\nbefore_deploy:\n- openssl aes-256-cbc -K $encrypted_<...>_key -iv $encrypted_<...>_iv -in deploy_rsa.enc -out /tmp/deploy_rsa -d\n- eval \"$(ssh-agent -s)\"\n- chmod 600 /tmp/deploy_rsa\n- ssh-add /tmp/deploy_rsa\n```\n\n最终的部署配置, 我的是静态页面，部署就是同步文件到服务器固定目录，用的是 `rsync`，其中 -e \"ssh -o PubkeyAuthentication=yes  -o stricthostkeychecking=no\" 参数可以跳过第一次登录的验证。\n```bash\ndeploy:\n  provider: script\n  skip_cleanup: true\n  script: rsync -e \"ssh -o PubkeyAuthentication=yes  -o stricthostkeychecking=no\" -r --delete-after --quiet $TRAVIS_BUILD_DIR/public/* root@$DEPLOY_IP:/opt/hexoBlog\n  on:\n    branch: master\n```\n其他的 yml 配置需要自己根据情况配置了~\n\n## 我最终的 .travis.yml 配置\n\n```bash\nlanguage: node_js\n\nnode_js:\n  - \"10\"\n\ncache:\n  apt: true\n  directories:\n    - node_modules\n\naddons:\n  ssh_known_hosts: $DEPLOY_IP\n\ninstall:\n  - npm install hexo-cli@2.0.0 -g\n  - npm install\n\nscript:\n  - hexo clean \n  - hexo g\n\nbefore_deploy:\n- openssl aes-256-cbc -K $encrypted_25ad2a76f550_key -iv $encrypted_25ad2a76f550_iv -in deploy_rsa.enc -out deploy_rsa -d\n- eval \"$(ssh-agent -s)\"\n- chmod 600 deploy_rsa\n- ssh-add deploy_rsa\n\ndeploy:\n  provider: script\n  skip_cleanup: true\n  script: rsync -e \"ssh -o PubkeyAuthentication=yes  -o stricthostkeychecking=no\" -r --delete-after --quiet $TRAVIS_BUILD_DIR/public/* root@$DEPLOY_IP:/opt/hexoBlog\n  on:\n    branch: master\n\n# deploy:\n#   provider: script\n#   skip_cleanup: true\n#   script: scp -o StrictHostKeyChecking=no -r public/*  root@$DEPLOY_IP:/opt/hexoBlog/\n#   on:\n#      branch: master\n\nbranches:\n  only:\n    - master\n\nnotifications:\n  email:\n    - huguobo2010@126.com\n  on_success: change\n  on_failure: always\n```\n\n## 总结\n折腾了大半天，终于看到了 CI-Success 的邮件, 网站也是成功的状态，云主机对应目录的文件也确实更新了。\n以后写博客 终于 只用 git push ，其他的等邮件通知了~~\n另外 文中的 id_rsa.enc 文件一开始我直接 vim 复制的都是乱码，一开始一直报错 `bad decrypt` ，后来上主机 git clone 仓库直接仓库内生成并添加的，这可能是个坑点。\n还有最后用 `rsync` 代替了 `scp`\n最后也把 openssl 放在了 before_deploy 阶段，放在 before_install也是没问题的，这些都是因人而异啦。\n![success](/images/success.png)\n\n## 参考文章\n- https://oncletom.io/2016/travis-ssh-deploy/\n- http://www.ruanyifeng.com/blog/2017/12/travis_ci_tutorial.html\n- https://gems.ruby-china.com/","source":"_posts/Travis-CI持续集成Hexo到云服务器.md","raw":"---\ntitle: Travis-CI 持续集成 hexo 到云服务器\ndate: 2019-09-01 18:35:40\ncategories: \n- CI\ntags:\n- travis\n- CI\n- hexo\n- blog\n---\n\n> 烦：每次本地提交代码到 GitHub 上后还要自己手动同步文件到云服务器，完成所谓的部署工作有点麻烦和脱节。\n> 懒：程序员等所有自称工程师进步的先决动力，想实现一个我每次提交代码后，后面的构建，打包和部署都自动进行的流程。\n> 因为本身代码托管在 Github 上，所以就开始折腾 Travis-CI了。\n\n\n## 什么是CI\n持续集成服务（Continuous Integration，简称 CI）。\n一般指的是提供一个运行环境，自动化执行单元测试，规范检查，基于环境的构建，服务部署等流水线作业。\n持续集成的目的，就是让产品可以快速迭代，同时还能保持高质量。\n另外，这个是工程化实践，如果你觉得自己手动操作比整这些繁琐的流程方便多了，我觉得也是没问题的。\n\n## Travis CI \n[Travis CI](https://travis-ci.com/) 对 Github 上的开源项目提供免费服务，这要求必须有 Github 账号。界面也很赞~，让我想起了前东家的 PLUS 发布系统。 \n![travis](/images/travis.png)\n可以使用 github 账号直接登录， public 的仓库也直接同步到 Travis 上了， 选择想开启 Travis CI 的仓库，打开开关即可。详细配置不细说了，图形化界面，进去就知道了。\n\n### .travis.yml\nTravis-CI配置文件，存放在项目根目录下。\n支持多种语言，在配置文件中 `language: node_js`\n一个比较完整的生命周期\n\n```bash\nbefore_install\ninstall\nbefore_script\nscript\naftersuccess or afterfailure\n[OPTIONAL] before_deploy\n[OPTIONAL] deploy\n[OPTIONAL] after_deploy\nafter_script\n```\n详细配置参考 [官方文档](https://docs.travis-ci.com)\n\n## 一些准备工作\n由于后面的免密登录和部署流程会涉及一些环境和配置类的操作，这个部分介绍下前置条件。\n\n### SCP命令\nscp 命令用于linux下的跨主机之间的文件和目录复制\n在首次连接服务器时，会弹出公钥确认的提示。这会导致某些自动化任务，由于初次连接服务器而导致自动化任务中断，\n可在 StrictHostKeyChecking选项，用 -o 参数指定后，则不检查该项。\n\n```bash\nscp [可选参数] file_source file_target\n#将public目录下的所有文件复制到$DEPLOY_IP下的/path/to/blog目录中。不检查key，\nscp -o StrictHostKeyChecking=no -r public/*  user@$DEPLOY_IP:/path/to/blog/\n#可用-i指定私钥。\nscp -o  StrictHostKeyChecking=no -i .ssh/id_rsa yourfile user@destinate_ip:/dest_folder\n#或将自己的公钥放到目标机的authorized_keys文件里，使自己为目标机的信任机器，实现无密码登录\n#这个是在生成ssh key 后，将公钥放到authorized_keys文件中。使用密钥对可以实现不输入密码\ncd ~/.ssh\ncat id_rsa.pub >> authorized_keys\n```\n\n### rsync 命令\n最终采用了 rsync 命令，我觉得都行，主要是这个同步成功了。\n```bash\nrsync -e \"ssh -o PubkeyAuthentication=yes  -o stricthostkeychecking=no\" -r --delete-after --quiet $TRAVIS_BUILD_DIR/public/* root@$DEPLOY_IP:/opt/hexoBlog\n```\n\n### centOS使用gem\n因为后面要使用 `gem install travis` ,所以可能会需要 升级 ruby 和 切换 gem 源（亲测 ruby 版本低会安装报错，gem 用官方源真的是动都不动啊，太难了）\n\n\n#### 切换gem源\n```bash\n$ gem sources --add https://gems.ruby-china.com/ --remove https://rubygems.org/\n$ gem sources -l\nhttps://gems.ruby-china.com\n# 确保只有 gems.ruby-china.com\n$ gem update --system \n$ gem -v\n2.6.3\n```\n#### 升级Ruby\n安装[RAM](https://rvm.io/), 一款ruby版本管理工具，类似 node 的 nvm。\n```bash\ngpg --keyserver hkp://keys.gnupg.net --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3 7D2BAF1CF37B13E2069D6956105BD0E739499BDB\ncurl -sSL https://get.rvm.io | bash -s stable\nsource /etc/profile.d/rvm.sh\nrvm -v\n```\n\n安装新版 ruby\n```bash\nrvm install 2.6\n```\n\n## 自动部署到远程服务器\n对于项目的构建来说都是 执行配置文件中写好的脚本，这个项目可能 就是 `npm install && hexo clean && hexo g`, 那么怎么执行最后一步，把文件同步传输到 云服务器上呢。 我们使用CI就是手动过程太繁琐，重复没有意义，怎么实现 `免密` 部署呢。\n\n登录到 `云服务器(centOS 7.x)`,进行如下操作\n### gem install travis 并登录\n```bash\ngem install travis #  这步失败的话请看上面关于升级ruby和切换gem源的部分\ntravis login\n```\n登录 github 账号密码，这个安全直接连接的 github 服务\n![login](/images/login.png)\n\n### 生成 ssh key 并输出对应加密的私钥到 travis \n进到云服务器对应的 git 仓库目录里\n```bash\nssh-keygen -t rsa -b 4096 -C 'build@travis-ci.org' -f ./deploy_rsa\ntravis encrypt-file deploy_rsa --add\nssh-copy-id -i deploy_rsa.pub <ssh-user>@<deploy-host>\n\nrm -f deploy_rsa deploy_rsa.pub\ngit add deploy_rsa.enc .travis.yml\n```\n项目根目录下的 `deploy_rsa.enc` 文件就是我们加密的私钥文件， `.travis.yml` 是我们的配置文件。\n$encrypted_XXXXXX_key 和 $encrypted_XXXXXXXX_iv 是travis 帮忙生成的环境变量，已经同步到 huguobo/hexo-blog 这个项目上了。\n![iv](/images/iv.png)\n\n还有一点可能会用上，因为 travis 第一次登录远程服务器会出现 SSH 主机验证，这边会有一个主机信任问题。官方给出的方案是添加 addons 配置，然后修改 .travis.yml 的相关配置\n```bash\naddons:\n  ssh_known_hosts: your-ip\n\nbefore_deploy:\n- openssl aes-256-cbc -K $encrypted_<...>_key -iv $encrypted_<...>_iv -in deploy_rsa.enc -out /tmp/deploy_rsa -d\n- eval \"$(ssh-agent -s)\"\n- chmod 600 /tmp/deploy_rsa\n- ssh-add /tmp/deploy_rsa\n```\n\n最终的部署配置, 我的是静态页面，部署就是同步文件到服务器固定目录，用的是 `rsync`，其中 -e \"ssh -o PubkeyAuthentication=yes  -o stricthostkeychecking=no\" 参数可以跳过第一次登录的验证。\n```bash\ndeploy:\n  provider: script\n  skip_cleanup: true\n  script: rsync -e \"ssh -o PubkeyAuthentication=yes  -o stricthostkeychecking=no\" -r --delete-after --quiet $TRAVIS_BUILD_DIR/public/* root@$DEPLOY_IP:/opt/hexoBlog\n  on:\n    branch: master\n```\n其他的 yml 配置需要自己根据情况配置了~\n\n## 我最终的 .travis.yml 配置\n\n```bash\nlanguage: node_js\n\nnode_js:\n  - \"10\"\n\ncache:\n  apt: true\n  directories:\n    - node_modules\n\naddons:\n  ssh_known_hosts: $DEPLOY_IP\n\ninstall:\n  - npm install hexo-cli@2.0.0 -g\n  - npm install\n\nscript:\n  - hexo clean \n  - hexo g\n\nbefore_deploy:\n- openssl aes-256-cbc -K $encrypted_25ad2a76f550_key -iv $encrypted_25ad2a76f550_iv -in deploy_rsa.enc -out deploy_rsa -d\n- eval \"$(ssh-agent -s)\"\n- chmod 600 deploy_rsa\n- ssh-add deploy_rsa\n\ndeploy:\n  provider: script\n  skip_cleanup: true\n  script: rsync -e \"ssh -o PubkeyAuthentication=yes  -o stricthostkeychecking=no\" -r --delete-after --quiet $TRAVIS_BUILD_DIR/public/* root@$DEPLOY_IP:/opt/hexoBlog\n  on:\n    branch: master\n\n# deploy:\n#   provider: script\n#   skip_cleanup: true\n#   script: scp -o StrictHostKeyChecking=no -r public/*  root@$DEPLOY_IP:/opt/hexoBlog/\n#   on:\n#      branch: master\n\nbranches:\n  only:\n    - master\n\nnotifications:\n  email:\n    - huguobo2010@126.com\n  on_success: change\n  on_failure: always\n```\n\n## 总结\n折腾了大半天，终于看到了 CI-Success 的邮件, 网站也是成功的状态，云主机对应目录的文件也确实更新了。\n以后写博客 终于 只用 git push ，其他的等邮件通知了~~\n另外 文中的 id_rsa.enc 文件一开始我直接 vim 复制的都是乱码，一开始一直报错 `bad decrypt` ，后来上主机 git clone 仓库直接仓库内生成并添加的，这可能是个坑点。\n还有最后用 `rsync` 代替了 `scp`\n最后也把 openssl 放在了 before_deploy 阶段，放在 before_install也是没问题的，这些都是因人而异啦。\n![success](/images/success.png)\n\n## 参考文章\n- https://oncletom.io/2016/travis-ssh-deploy/\n- http://www.ruanyifeng.com/blog/2017/12/travis_ci_tutorial.html\n- https://gems.ruby-china.com/","slug":"Travis-CI持续集成Hexo到云服务器","published":1,"updated":"2019-09-02T01:37:01.948Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck03fz4al0008oloxtwsjddgs","content":"<blockquote>\n<p>烦：每次本地提交代码到 GitHub 上后还要自己手动同步文件到云服务器，完成所谓的部署工作有点麻烦和脱节。<br>懒：程序员等所有自称工程师进步的先决动力，想实现一个我每次提交代码后，后面的构建，打包和部署都自动进行的流程。<br>因为本身代码托管在 Github 上，所以就开始折腾 Travis-CI了。</p>\n</blockquote>\n<h2 id=\"什么是CI\"><a href=\"#什么是CI\" class=\"headerlink\" title=\"什么是CI\"></a>什么是CI</h2><p>持续集成服务（Continuous Integration，简称 CI）。<br>一般指的是提供一个运行环境，自动化执行单元测试，规范检查，基于环境的构建，服务部署等流水线作业。<br>持续集成的目的，就是让产品可以快速迭代，同时还能保持高质量。<br>另外，这个是工程化实践，如果你觉得自己手动操作比整这些繁琐的流程方便多了，我觉得也是没问题的。</p>\n<h2 id=\"Travis-CI\"><a href=\"#Travis-CI\" class=\"headerlink\" title=\"Travis CI\"></a>Travis CI</h2><p><a href=\"https://travis-ci.com/\" target=\"_blank\" rel=\"noopener\">Travis CI</a> 对 Github 上的开源项目提供免费服务，这要求必须有 Github 账号。界面也很赞~，让我想起了前东家的 PLUS 发布系统。<br><img src=\"/images/travis.png\" alt=\"travis\"><br>可以使用 github 账号直接登录， public 的仓库也直接同步到 Travis 上了， 选择想开启 Travis CI 的仓库，打开开关即可。详细配置不细说了，图形化界面，进去就知道了。</p>\n<h3 id=\"travis-yml\"><a href=\"#travis-yml\" class=\"headerlink\" title=\".travis.yml\"></a>.travis.yml</h3><p>Travis-CI配置文件，存放在项目根目录下。<br>支持多种语言，在配置文件中 <code>language: node_js</code><br>一个比较完整的生命周期</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">before_install</span><br><span class=\"line\">install</span><br><span class=\"line\">before_script</span><br><span class=\"line\">script</span><br><span class=\"line\">aftersuccess or afterfailure</span><br><span class=\"line\">[OPTIONAL] before_deploy</span><br><span class=\"line\">[OPTIONAL] deploy</span><br><span class=\"line\">[OPTIONAL] after_deploy</span><br><span class=\"line\">after_script</span><br></pre></td></tr></table></figure>\n\n<p>详细配置参考 <a href=\"https://docs.travis-ci.com\" target=\"_blank\" rel=\"noopener\">官方文档</a></p>\n<h2 id=\"一些准备工作\"><a href=\"#一些准备工作\" class=\"headerlink\" title=\"一些准备工作\"></a>一些准备工作</h2><p>由于后面的免密登录和部署流程会涉及一些环境和配置类的操作，这个部分介绍下前置条件。</p>\n<h3 id=\"SCP命令\"><a href=\"#SCP命令\" class=\"headerlink\" title=\"SCP命令\"></a>SCP命令</h3><p>scp 命令用于linux下的跨主机之间的文件和目录复制<br>在首次连接服务器时，会弹出公钥确认的提示。这会导致某些自动化任务，由于初次连接服务器而导致自动化任务中断，<br>可在 StrictHostKeyChecking选项，用 -o 参数指定后，则不检查该项。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scp [可选参数] file_source file_target</span><br><span class=\"line\"><span class=\"comment\">#将public目录下的所有文件复制到$DEPLOY_IP下的/path/to/blog目录中。不检查key，</span></span><br><span class=\"line\">scp -o StrictHostKeyChecking=no -r public/*  user@<span class=\"variable\">$DEPLOY_IP</span>:/path/to/blog/</span><br><span class=\"line\"><span class=\"comment\">#可用-i指定私钥。</span></span><br><span class=\"line\">scp -o  StrictHostKeyChecking=no -i .ssh/id_rsa yourfile user@destinate_ip:/dest_folder</span><br><span class=\"line\"><span class=\"comment\">#或将自己的公钥放到目标机的authorized_keys文件里，使自己为目标机的信任机器，实现无密码登录</span></span><br><span class=\"line\"><span class=\"comment\">#这个是在生成ssh key 后，将公钥放到authorized_keys文件中。使用密钥对可以实现不输入密码</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> ~/.ssh</span><br><span class=\"line\">cat id_rsa.pub &gt;&gt; authorized_keys</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"rsync-命令\"><a href=\"#rsync-命令\" class=\"headerlink\" title=\"rsync 命令\"></a>rsync 命令</h3><p>最终采用了 rsync 命令，我觉得都行，主要是这个同步成功了。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rsync -e <span class=\"string\">\"ssh -o PubkeyAuthentication=yes  -o stricthostkeychecking=no\"</span> -r --delete-after --quiet <span class=\"variable\">$TRAVIS_BUILD_DIR</span>/public/* root@<span class=\"variable\">$DEPLOY_IP</span>:/opt/hexoBlog</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"centOS使用gem\"><a href=\"#centOS使用gem\" class=\"headerlink\" title=\"centOS使用gem\"></a>centOS使用gem</h3><p>因为后面要使用 <code>gem install travis</code> ,所以可能会需要 升级 ruby 和 切换 gem 源（亲测 ruby 版本低会安装报错，gem 用官方源真的是动都不动啊，太难了）</p>\n<h4 id=\"切换gem源\"><a href=\"#切换gem源\" class=\"headerlink\" title=\"切换gem源\"></a>切换gem源</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ gem sources --add https://gems.ruby-china.com/ --remove https://rubygems.org/</span><br><span class=\"line\">$ gem sources -l</span><br><span class=\"line\">https://gems.ruby-china.com</span><br><span class=\"line\"><span class=\"comment\"># 确保只有 gems.ruby-china.com</span></span><br><span class=\"line\">$ gem update --system </span><br><span class=\"line\">$ gem -v</span><br><span class=\"line\">2.6.3</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"升级Ruby\"><a href=\"#升级Ruby\" class=\"headerlink\" title=\"升级Ruby\"></a>升级Ruby</h4><p>安装<a href=\"https://rvm.io/\" target=\"_blank\" rel=\"noopener\">RAM</a>, 一款ruby版本管理工具，类似 node 的 nvm。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gpg --keyserver hkp://keys.gnupg.net --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3 7D2BAF1CF37B13E2069D6956105BD0E739499BDB</span><br><span class=\"line\">curl -sSL https://get.rvm.io | bash -s stable</span><br><span class=\"line\"><span class=\"built_in\">source</span> /etc/profile.d/rvm.sh</span><br><span class=\"line\">rvm -v</span><br></pre></td></tr></table></figure>\n\n<p>安装新版 ruby</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rvm install 2.6</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"自动部署到远程服务器\"><a href=\"#自动部署到远程服务器\" class=\"headerlink\" title=\"自动部署到远程服务器\"></a>自动部署到远程服务器</h2><p>对于项目的构建来说都是 执行配置文件中写好的脚本，这个项目可能 就是 <code>npm install &amp;&amp; hexo clean &amp;&amp; hexo g</code>, 那么怎么执行最后一步，把文件同步传输到 云服务器上呢。 我们使用CI就是手动过程太繁琐，重复没有意义，怎么实现 <code>免密</code> 部署呢。</p>\n<p>登录到 <code>云服务器(centOS 7.x)</code>,进行如下操作</p>\n<h3 id=\"gem-install-travis-并登录\"><a href=\"#gem-install-travis-并登录\" class=\"headerlink\" title=\"gem install travis 并登录\"></a>gem install travis 并登录</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gem install travis <span class=\"comment\">#  这步失败的话请看上面关于升级ruby和切换gem源的部分</span></span><br><span class=\"line\">travis login</span><br></pre></td></tr></table></figure>\n\n<p>登录 github 账号密码，这个安全直接连接的 github 服务<br><img src=\"/images/login.png\" alt=\"login\"></p>\n<h3 id=\"生成-ssh-key-并输出对应加密的私钥到-travis\"><a href=\"#生成-ssh-key-并输出对应加密的私钥到-travis\" class=\"headerlink\" title=\"生成 ssh key 并输出对应加密的私钥到 travis\"></a>生成 ssh key 并输出对应加密的私钥到 travis</h3><p>进到云服务器对应的 git 仓库目录里</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-keygen -t rsa -b 4096 -C <span class=\"string\">'build@travis-ci.org'</span> -f ./deploy_rsa</span><br><span class=\"line\">travis encrypt-file deploy_rsa --add</span><br><span class=\"line\">ssh-copy-id -i deploy_rsa.pub &lt;ssh-user&gt;@&lt;deploy-host&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">rm -f deploy_rsa deploy_rsa.pub</span><br><span class=\"line\">git add deploy_rsa.enc .travis.yml</span><br></pre></td></tr></table></figure>\n\n<p>项目根目录下的 <code>deploy_rsa.enc</code> 文件就是我们加密的私钥文件， <code>.travis.yml</code> 是我们的配置文件。<br>$encrypted_XXXXXX_key 和 $encrypted_XXXXXXXX_iv 是travis 帮忙生成的环境变量，已经同步到 huguobo/hexo-blog 这个项目上了。<br><img src=\"/images/iv.png\" alt=\"iv\"></p>\n<p>还有一点可能会用上，因为 travis 第一次登录远程服务器会出现 SSH 主机验证，这边会有一个主机信任问题。官方给出的方案是添加 addons 配置，然后修改 .travis.yml 的相关配置</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">addons:</span><br><span class=\"line\">  ssh_known_hosts: your-ip</span><br><span class=\"line\"></span><br><span class=\"line\">before_deploy:</span><br><span class=\"line\">- openssl aes-256-cbc -K <span class=\"variable\">$encrypted_</span>&lt;...&gt;_key -iv <span class=\"variable\">$encrypted_</span>&lt;...&gt;_iv -<span class=\"keyword\">in</span> deploy_rsa.enc -out /tmp/deploy_rsa -d</span><br><span class=\"line\">- <span class=\"built_in\">eval</span> <span class=\"string\">\"<span class=\"variable\">$(ssh-agent -s)</span>\"</span></span><br><span class=\"line\">- chmod 600 /tmp/deploy_rsa</span><br><span class=\"line\">- ssh-add /tmp/deploy_rsa</span><br></pre></td></tr></table></figure>\n\n<p>最终的部署配置, 我的是静态页面，部署就是同步文件到服务器固定目录，用的是 <code>rsync</code>，其中 -e “ssh -o PubkeyAuthentication=yes  -o stricthostkeychecking=no” 参数可以跳过第一次登录的验证。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">  provider: script</span><br><span class=\"line\">  skip_cleanup: <span class=\"literal\">true</span></span><br><span class=\"line\">  script: rsync -e <span class=\"string\">\"ssh -o PubkeyAuthentication=yes  -o stricthostkeychecking=no\"</span> -r --delete-after --quiet <span class=\"variable\">$TRAVIS_BUILD_DIR</span>/public/* root@<span class=\"variable\">$DEPLOY_IP</span>:/opt/hexoBlog</span><br><span class=\"line\">  on:</span><br><span class=\"line\">    branch: master</span><br></pre></td></tr></table></figure>\n\n<p>其他的 yml 配置需要自己根据情况配置了~</p>\n<h2 id=\"我最终的-travis-yml-配置\"><a href=\"#我最终的-travis-yml-配置\" class=\"headerlink\" title=\"我最终的 .travis.yml 配置\"></a>我最终的 .travis.yml 配置</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">language: node_js</span><br><span class=\"line\"></span><br><span class=\"line\">node_js:</span><br><span class=\"line\">  - <span class=\"string\">\"10\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">cache:</span><br><span class=\"line\">  apt: <span class=\"literal\">true</span></span><br><span class=\"line\">  directories:</span><br><span class=\"line\">    - node_modules</span><br><span class=\"line\"></span><br><span class=\"line\">addons:</span><br><span class=\"line\">  ssh_known_hosts: <span class=\"variable\">$DEPLOY_IP</span></span><br><span class=\"line\"></span><br><span class=\"line\">install:</span><br><span class=\"line\">  - npm install hexo-cli@2.0.0 -g</span><br><span class=\"line\">  - npm install</span><br><span class=\"line\"></span><br><span class=\"line\">script:</span><br><span class=\"line\">  - hexo clean </span><br><span class=\"line\">  - hexo g</span><br><span class=\"line\"></span><br><span class=\"line\">before_deploy:</span><br><span class=\"line\">- openssl aes-256-cbc -K <span class=\"variable\">$encrypted_25ad2a76f550_key</span> -iv <span class=\"variable\">$encrypted_25ad2a76f550_iv</span> -<span class=\"keyword\">in</span> deploy_rsa.enc -out deploy_rsa -d</span><br><span class=\"line\">- <span class=\"built_in\">eval</span> <span class=\"string\">\"<span class=\"variable\">$(ssh-agent -s)</span>\"</span></span><br><span class=\"line\">- chmod 600 deploy_rsa</span><br><span class=\"line\">- ssh-add deploy_rsa</span><br><span class=\"line\"></span><br><span class=\"line\">deploy:</span><br><span class=\"line\">  provider: script</span><br><span class=\"line\">  skip_cleanup: <span class=\"literal\">true</span></span><br><span class=\"line\">  script: rsync -e <span class=\"string\">\"ssh -o PubkeyAuthentication=yes  -o stricthostkeychecking=no\"</span> -r --delete-after --quiet <span class=\"variable\">$TRAVIS_BUILD_DIR</span>/public/* root@<span class=\"variable\">$DEPLOY_IP</span>:/opt/hexoBlog</span><br><span class=\"line\">  on:</span><br><span class=\"line\">    branch: master</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># deploy:</span></span><br><span class=\"line\"><span class=\"comment\">#   provider: script</span></span><br><span class=\"line\"><span class=\"comment\">#   skip_cleanup: true</span></span><br><span class=\"line\"><span class=\"comment\">#   script: scp -o StrictHostKeyChecking=no -r public/*  root@$DEPLOY_IP:/opt/hexoBlog/</span></span><br><span class=\"line\"><span class=\"comment\">#   on:</span></span><br><span class=\"line\"><span class=\"comment\">#      branch: master</span></span><br><span class=\"line\"></span><br><span class=\"line\">branches:</span><br><span class=\"line\">  only:</span><br><span class=\"line\">    - master</span><br><span class=\"line\"></span><br><span class=\"line\">notifications:</span><br><span class=\"line\">  email:</span><br><span class=\"line\">    - huguobo2010@126.com</span><br><span class=\"line\">  on_success: change</span><br><span class=\"line\">  on_failure: always</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>折腾了大半天，终于看到了 CI-Success 的邮件, 网站也是成功的状态，云主机对应目录的文件也确实更新了。<br>以后写博客 终于 只用 git push ，其他的等邮件通知了~~<br>另外 文中的 id_rsa.enc 文件一开始我直接 vim 复制的都是乱码，一开始一直报错 <code>bad decrypt</code> ，后来上主机 git clone 仓库直接仓库内生成并添加的，这可能是个坑点。<br>还有最后用 <code>rsync</code> 代替了 <code>scp</code><br>最后也把 openssl 放在了 before_deploy 阶段，放在 before_install也是没问题的，这些都是因人而异啦。<br><img src=\"/images/success.png\" alt=\"success\"></p>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><ul>\n<li><a href=\"https://oncletom.io/2016/travis-ssh-deploy/\" target=\"_blank\" rel=\"noopener\">https://oncletom.io/2016/travis-ssh-deploy/</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2017/12/travis_ci_tutorial.html\" target=\"_blank\" rel=\"noopener\">http://www.ruanyifeng.com/blog/2017/12/travis_ci_tutorial.html</a></li>\n<li><a href=\"https://gems.ruby-china.com/\" target=\"_blank\" rel=\"noopener\">https://gems.ruby-china.com/</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>烦：每次本地提交代码到 GitHub 上后还要自己手动同步文件到云服务器，完成所谓的部署工作有点麻烦和脱节。<br>懒：程序员等所有自称工程师进步的先决动力，想实现一个我每次提交代码后，后面的构建，打包和部署都自动进行的流程。<br>因为本身代码托管在 Github 上，所以就开始折腾 Travis-CI了。</p>\n</blockquote>\n<h2 id=\"什么是CI\"><a href=\"#什么是CI\" class=\"headerlink\" title=\"什么是CI\"></a>什么是CI</h2><p>持续集成服务（Continuous Integration，简称 CI）。<br>一般指的是提供一个运行环境，自动化执行单元测试，规范检查，基于环境的构建，服务部署等流水线作业。<br>持续集成的目的，就是让产品可以快速迭代，同时还能保持高质量。<br>另外，这个是工程化实践，如果你觉得自己手动操作比整这些繁琐的流程方便多了，我觉得也是没问题的。</p>\n<h2 id=\"Travis-CI\"><a href=\"#Travis-CI\" class=\"headerlink\" title=\"Travis CI\"></a>Travis CI</h2><p><a href=\"https://travis-ci.com/\" target=\"_blank\" rel=\"noopener\">Travis CI</a> 对 Github 上的开源项目提供免费服务，这要求必须有 Github 账号。界面也很赞~，让我想起了前东家的 PLUS 发布系统。<br><img src=\"/images/travis.png\" alt=\"travis\"><br>可以使用 github 账号直接登录， public 的仓库也直接同步到 Travis 上了， 选择想开启 Travis CI 的仓库，打开开关即可。详细配置不细说了，图形化界面，进去就知道了。</p>\n<h3 id=\"travis-yml\"><a href=\"#travis-yml\" class=\"headerlink\" title=\".travis.yml\"></a>.travis.yml</h3><p>Travis-CI配置文件，存放在项目根目录下。<br>支持多种语言，在配置文件中 <code>language: node_js</code><br>一个比较完整的生命周期</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">before_install</span><br><span class=\"line\">install</span><br><span class=\"line\">before_script</span><br><span class=\"line\">script</span><br><span class=\"line\">aftersuccess or afterfailure</span><br><span class=\"line\">[OPTIONAL] before_deploy</span><br><span class=\"line\">[OPTIONAL] deploy</span><br><span class=\"line\">[OPTIONAL] after_deploy</span><br><span class=\"line\">after_script</span><br></pre></td></tr></table></figure>\n\n<p>详细配置参考 <a href=\"https://docs.travis-ci.com\" target=\"_blank\" rel=\"noopener\">官方文档</a></p>\n<h2 id=\"一些准备工作\"><a href=\"#一些准备工作\" class=\"headerlink\" title=\"一些准备工作\"></a>一些准备工作</h2><p>由于后面的免密登录和部署流程会涉及一些环境和配置类的操作，这个部分介绍下前置条件。</p>\n<h3 id=\"SCP命令\"><a href=\"#SCP命令\" class=\"headerlink\" title=\"SCP命令\"></a>SCP命令</h3><p>scp 命令用于linux下的跨主机之间的文件和目录复制<br>在首次连接服务器时，会弹出公钥确认的提示。这会导致某些自动化任务，由于初次连接服务器而导致自动化任务中断，<br>可在 StrictHostKeyChecking选项，用 -o 参数指定后，则不检查该项。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scp [可选参数] file_source file_target</span><br><span class=\"line\"><span class=\"comment\">#将public目录下的所有文件复制到$DEPLOY_IP下的/path/to/blog目录中。不检查key，</span></span><br><span class=\"line\">scp -o StrictHostKeyChecking=no -r public/*  user@<span class=\"variable\">$DEPLOY_IP</span>:/path/to/blog/</span><br><span class=\"line\"><span class=\"comment\">#可用-i指定私钥。</span></span><br><span class=\"line\">scp -o  StrictHostKeyChecking=no -i .ssh/id_rsa yourfile user@destinate_ip:/dest_folder</span><br><span class=\"line\"><span class=\"comment\">#或将自己的公钥放到目标机的authorized_keys文件里，使自己为目标机的信任机器，实现无密码登录</span></span><br><span class=\"line\"><span class=\"comment\">#这个是在生成ssh key 后，将公钥放到authorized_keys文件中。使用密钥对可以实现不输入密码</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> ~/.ssh</span><br><span class=\"line\">cat id_rsa.pub &gt;&gt; authorized_keys</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"rsync-命令\"><a href=\"#rsync-命令\" class=\"headerlink\" title=\"rsync 命令\"></a>rsync 命令</h3><p>最终采用了 rsync 命令，我觉得都行，主要是这个同步成功了。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rsync -e <span class=\"string\">\"ssh -o PubkeyAuthentication=yes  -o stricthostkeychecking=no\"</span> -r --delete-after --quiet <span class=\"variable\">$TRAVIS_BUILD_DIR</span>/public/* root@<span class=\"variable\">$DEPLOY_IP</span>:/opt/hexoBlog</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"centOS使用gem\"><a href=\"#centOS使用gem\" class=\"headerlink\" title=\"centOS使用gem\"></a>centOS使用gem</h3><p>因为后面要使用 <code>gem install travis</code> ,所以可能会需要 升级 ruby 和 切换 gem 源（亲测 ruby 版本低会安装报错，gem 用官方源真的是动都不动啊，太难了）</p>\n<h4 id=\"切换gem源\"><a href=\"#切换gem源\" class=\"headerlink\" title=\"切换gem源\"></a>切换gem源</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ gem sources --add https://gems.ruby-china.com/ --remove https://rubygems.org/</span><br><span class=\"line\">$ gem sources -l</span><br><span class=\"line\">https://gems.ruby-china.com</span><br><span class=\"line\"><span class=\"comment\"># 确保只有 gems.ruby-china.com</span></span><br><span class=\"line\">$ gem update --system </span><br><span class=\"line\">$ gem -v</span><br><span class=\"line\">2.6.3</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"升级Ruby\"><a href=\"#升级Ruby\" class=\"headerlink\" title=\"升级Ruby\"></a>升级Ruby</h4><p>安装<a href=\"https://rvm.io/\" target=\"_blank\" rel=\"noopener\">RAM</a>, 一款ruby版本管理工具，类似 node 的 nvm。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gpg --keyserver hkp://keys.gnupg.net --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3 7D2BAF1CF37B13E2069D6956105BD0E739499BDB</span><br><span class=\"line\">curl -sSL https://get.rvm.io | bash -s stable</span><br><span class=\"line\"><span class=\"built_in\">source</span> /etc/profile.d/rvm.sh</span><br><span class=\"line\">rvm -v</span><br></pre></td></tr></table></figure>\n\n<p>安装新版 ruby</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rvm install 2.6</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"自动部署到远程服务器\"><a href=\"#自动部署到远程服务器\" class=\"headerlink\" title=\"自动部署到远程服务器\"></a>自动部署到远程服务器</h2><p>对于项目的构建来说都是 执行配置文件中写好的脚本，这个项目可能 就是 <code>npm install &amp;&amp; hexo clean &amp;&amp; hexo g</code>, 那么怎么执行最后一步，把文件同步传输到 云服务器上呢。 我们使用CI就是手动过程太繁琐，重复没有意义，怎么实现 <code>免密</code> 部署呢。</p>\n<p>登录到 <code>云服务器(centOS 7.x)</code>,进行如下操作</p>\n<h3 id=\"gem-install-travis-并登录\"><a href=\"#gem-install-travis-并登录\" class=\"headerlink\" title=\"gem install travis 并登录\"></a>gem install travis 并登录</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gem install travis <span class=\"comment\">#  这步失败的话请看上面关于升级ruby和切换gem源的部分</span></span><br><span class=\"line\">travis login</span><br></pre></td></tr></table></figure>\n\n<p>登录 github 账号密码，这个安全直接连接的 github 服务<br><img src=\"/images/login.png\" alt=\"login\"></p>\n<h3 id=\"生成-ssh-key-并输出对应加密的私钥到-travis\"><a href=\"#生成-ssh-key-并输出对应加密的私钥到-travis\" class=\"headerlink\" title=\"生成 ssh key 并输出对应加密的私钥到 travis\"></a>生成 ssh key 并输出对应加密的私钥到 travis</h3><p>进到云服务器对应的 git 仓库目录里</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-keygen -t rsa -b 4096 -C <span class=\"string\">'build@travis-ci.org'</span> -f ./deploy_rsa</span><br><span class=\"line\">travis encrypt-file deploy_rsa --add</span><br><span class=\"line\">ssh-copy-id -i deploy_rsa.pub &lt;ssh-user&gt;@&lt;deploy-host&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">rm -f deploy_rsa deploy_rsa.pub</span><br><span class=\"line\">git add deploy_rsa.enc .travis.yml</span><br></pre></td></tr></table></figure>\n\n<p>项目根目录下的 <code>deploy_rsa.enc</code> 文件就是我们加密的私钥文件， <code>.travis.yml</code> 是我们的配置文件。<br>$encrypted_XXXXXX_key 和 $encrypted_XXXXXXXX_iv 是travis 帮忙生成的环境变量，已经同步到 huguobo/hexo-blog 这个项目上了。<br><img src=\"/images/iv.png\" alt=\"iv\"></p>\n<p>还有一点可能会用上，因为 travis 第一次登录远程服务器会出现 SSH 主机验证，这边会有一个主机信任问题。官方给出的方案是添加 addons 配置，然后修改 .travis.yml 的相关配置</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">addons:</span><br><span class=\"line\">  ssh_known_hosts: your-ip</span><br><span class=\"line\"></span><br><span class=\"line\">before_deploy:</span><br><span class=\"line\">- openssl aes-256-cbc -K <span class=\"variable\">$encrypted_</span>&lt;...&gt;_key -iv <span class=\"variable\">$encrypted_</span>&lt;...&gt;_iv -<span class=\"keyword\">in</span> deploy_rsa.enc -out /tmp/deploy_rsa -d</span><br><span class=\"line\">- <span class=\"built_in\">eval</span> <span class=\"string\">\"<span class=\"variable\">$(ssh-agent -s)</span>\"</span></span><br><span class=\"line\">- chmod 600 /tmp/deploy_rsa</span><br><span class=\"line\">- ssh-add /tmp/deploy_rsa</span><br></pre></td></tr></table></figure>\n\n<p>最终的部署配置, 我的是静态页面，部署就是同步文件到服务器固定目录，用的是 <code>rsync</code>，其中 -e “ssh -o PubkeyAuthentication=yes  -o stricthostkeychecking=no” 参数可以跳过第一次登录的验证。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">  provider: script</span><br><span class=\"line\">  skip_cleanup: <span class=\"literal\">true</span></span><br><span class=\"line\">  script: rsync -e <span class=\"string\">\"ssh -o PubkeyAuthentication=yes  -o stricthostkeychecking=no\"</span> -r --delete-after --quiet <span class=\"variable\">$TRAVIS_BUILD_DIR</span>/public/* root@<span class=\"variable\">$DEPLOY_IP</span>:/opt/hexoBlog</span><br><span class=\"line\">  on:</span><br><span class=\"line\">    branch: master</span><br></pre></td></tr></table></figure>\n\n<p>其他的 yml 配置需要自己根据情况配置了~</p>\n<h2 id=\"我最终的-travis-yml-配置\"><a href=\"#我最终的-travis-yml-配置\" class=\"headerlink\" title=\"我最终的 .travis.yml 配置\"></a>我最终的 .travis.yml 配置</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">language: node_js</span><br><span class=\"line\"></span><br><span class=\"line\">node_js:</span><br><span class=\"line\">  - <span class=\"string\">\"10\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">cache:</span><br><span class=\"line\">  apt: <span class=\"literal\">true</span></span><br><span class=\"line\">  directories:</span><br><span class=\"line\">    - node_modules</span><br><span class=\"line\"></span><br><span class=\"line\">addons:</span><br><span class=\"line\">  ssh_known_hosts: <span class=\"variable\">$DEPLOY_IP</span></span><br><span class=\"line\"></span><br><span class=\"line\">install:</span><br><span class=\"line\">  - npm install hexo-cli@2.0.0 -g</span><br><span class=\"line\">  - npm install</span><br><span class=\"line\"></span><br><span class=\"line\">script:</span><br><span class=\"line\">  - hexo clean </span><br><span class=\"line\">  - hexo g</span><br><span class=\"line\"></span><br><span class=\"line\">before_deploy:</span><br><span class=\"line\">- openssl aes-256-cbc -K <span class=\"variable\">$encrypted_25ad2a76f550_key</span> -iv <span class=\"variable\">$encrypted_25ad2a76f550_iv</span> -<span class=\"keyword\">in</span> deploy_rsa.enc -out deploy_rsa -d</span><br><span class=\"line\">- <span class=\"built_in\">eval</span> <span class=\"string\">\"<span class=\"variable\">$(ssh-agent -s)</span>\"</span></span><br><span class=\"line\">- chmod 600 deploy_rsa</span><br><span class=\"line\">- ssh-add deploy_rsa</span><br><span class=\"line\"></span><br><span class=\"line\">deploy:</span><br><span class=\"line\">  provider: script</span><br><span class=\"line\">  skip_cleanup: <span class=\"literal\">true</span></span><br><span class=\"line\">  script: rsync -e <span class=\"string\">\"ssh -o PubkeyAuthentication=yes  -o stricthostkeychecking=no\"</span> -r --delete-after --quiet <span class=\"variable\">$TRAVIS_BUILD_DIR</span>/public/* root@<span class=\"variable\">$DEPLOY_IP</span>:/opt/hexoBlog</span><br><span class=\"line\">  on:</span><br><span class=\"line\">    branch: master</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># deploy:</span></span><br><span class=\"line\"><span class=\"comment\">#   provider: script</span></span><br><span class=\"line\"><span class=\"comment\">#   skip_cleanup: true</span></span><br><span class=\"line\"><span class=\"comment\">#   script: scp -o StrictHostKeyChecking=no -r public/*  root@$DEPLOY_IP:/opt/hexoBlog/</span></span><br><span class=\"line\"><span class=\"comment\">#   on:</span></span><br><span class=\"line\"><span class=\"comment\">#      branch: master</span></span><br><span class=\"line\"></span><br><span class=\"line\">branches:</span><br><span class=\"line\">  only:</span><br><span class=\"line\">    - master</span><br><span class=\"line\"></span><br><span class=\"line\">notifications:</span><br><span class=\"line\">  email:</span><br><span class=\"line\">    - huguobo2010@126.com</span><br><span class=\"line\">  on_success: change</span><br><span class=\"line\">  on_failure: always</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>折腾了大半天，终于看到了 CI-Success 的邮件, 网站也是成功的状态，云主机对应目录的文件也确实更新了。<br>以后写博客 终于 只用 git push ，其他的等邮件通知了~~<br>另外 文中的 id_rsa.enc 文件一开始我直接 vim 复制的都是乱码，一开始一直报错 <code>bad decrypt</code> ，后来上主机 git clone 仓库直接仓库内生成并添加的，这可能是个坑点。<br>还有最后用 <code>rsync</code> 代替了 <code>scp</code><br>最后也把 openssl 放在了 before_deploy 阶段，放在 before_install也是没问题的，这些都是因人而异啦。<br><img src=\"/images/success.png\" alt=\"success\"></p>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><ul>\n<li><a href=\"https://oncletom.io/2016/travis-ssh-deploy/\" target=\"_blank\" rel=\"noopener\">https://oncletom.io/2016/travis-ssh-deploy/</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2017/12/travis_ci_tutorial.html\" target=\"_blank\" rel=\"noopener\">http://www.ruanyifeng.com/blog/2017/12/travis_ci_tutorial.html</a></li>\n<li><a href=\"https://gems.ruby-china.com/\" target=\"_blank\" rel=\"noopener\">https://gems.ruby-china.com/</a></li>\n</ul>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"ck03fz4af0002oloxrg21ox0i","category_id":"ck03fz4al0009olox14vi2qbo","_id":"ck03fz4an000dolox5usy89y0"},{"post_id":"ck03fz4aj0006oloxsnupr663","category_id":"ck03fz4am000bolox6vd3vdcm","_id":"ck03fz4ap000jolox14im8wrm"},{"post_id":"ck03fz4ak0007oloxajw9adhb","category_id":"ck03fz4am000bolox6vd3vdcm","_id":"ck03fz4aq000moloxpx35unje"},{"post_id":"ck03fz4ac0000olox0agk6jws","category_id":"ck03fz4ah0004oloxj3nwuoan","_id":"ck03fz4aq000qoloxv5utt5h9"},{"post_id":"ck03fz4ac0000olox0agk6jws","category_id":"ck03fz4ap000ioloxaoa3ruhi","_id":"ck03fz4ar000tolox7ffm2w2h"},{"post_id":"ck03fz4al0008oloxtwsjddgs","category_id":"ck03fz4aq000nolox0vj39cq6","_id":"ck03fz4ar000voloxniz92x0k"}],"PostTag":[{"post_id":"ck03fz4ac0000olox0agk6jws","tag_id":"ck03fz4aj0005olox9334m7qc","_id":"ck03fz4ao000goloxlsgpndgf"},{"post_id":"ck03fz4ac0000olox0agk6jws","tag_id":"ck03fz4al000aolox8y0vellv","_id":"ck03fz4ap000holoxton8m4gd"},{"post_id":"ck03fz4ac0000olox0agk6jws","tag_id":"ck03fz4am000colox5s5umgt9","_id":"ck03fz4ap000loloxqotsudwi"},{"post_id":"ck03fz4af0002oloxrg21ox0i","tag_id":"ck03fz4an000folox8bqigmoz","_id":"ck03fz4aq000polox7eqb0o26"},{"post_id":"ck03fz4af0002oloxrg21ox0i","tag_id":"ck03fz4ap000kolox41snftjo","_id":"ck03fz4aq000roloxh6hm83ck"},{"post_id":"ck03fz4aj0006oloxsnupr663","tag_id":"ck03fz4aq000ooloxz8ml2sir","_id":"ck03fz4ar000uoloxc9z168a7"},{"post_id":"ck03fz4ak0007oloxajw9adhb","tag_id":"ck03fz4aq000soloxgikwu903","_id":"ck03fz4as000yolox3ih9zmtb"},{"post_id":"ck03fz4ak0007oloxajw9adhb","tag_id":"ck03fz4aq000ooloxz8ml2sir","_id":"ck03fz4as000zoloxjnnppk21"},{"post_id":"ck03fz4al0008oloxtwsjddgs","tag_id":"ck03fz4ar000xoloxibnayz9c","_id":"ck03fz4as0013olox3h0a6z5a"},{"post_id":"ck03fz4al0008oloxtwsjddgs","tag_id":"ck03fz4as0010oloxgh2a7lhz","_id":"ck03fz4as0014oloxnyzj3o7q"},{"post_id":"ck03fz4al0008oloxtwsjddgs","tag_id":"ck03fz4as0011oloxovxlkm5x","_id":"ck03fz4as0015oloxt8exx8n1"},{"post_id":"ck03fz4al0008oloxtwsjddgs","tag_id":"ck03fz4as0012oloxilagbll9","_id":"ck03fz4at0016olox41vh5nhv"},{"post_id":"ck03fz4ac0000olox0agk6jws","tag_id":"ck03g67ll000071ox7vj8j183","_id":"ck03g67lm000171oxq68nl9nv"}],"Tag":[{"name":"SSH","_id":"ck03fz4aj0005olox9334m7qc"},{"name":"SSL","_id":"ck03fz4al000aolox8y0vellv"},{"name":"HTTPS","_id":"ck03fz4am000colox5s5umgt9"},{"name":"nginx","_id":"ck03fz4an000folox8bqigmoz"},{"name":"devOps","_id":"ck03fz4ap000kolox41snftjo"},{"name":"白话","_id":"ck03fz4aq000ooloxz8ml2sir"},{"name":"日常","_id":"ck03fz4aq000soloxgikwu903"},{"name":"travis","_id":"ck03fz4ar000xoloxibnayz9c"},{"name":"CI","_id":"ck03fz4as0010oloxgh2a7lhz"},{"name":"hexo","_id":"ck03fz4as0011oloxovxlkm5x"},{"name":"blog","_id":"ck03fz4as0012oloxilagbll9"},{"name":"加密算法","_id":"ck03g67ll000071ox7vj8j183"}]}}