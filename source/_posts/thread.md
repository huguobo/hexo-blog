---
title: 操作系统中的进程和线程
date: 2019-10-10 11:07:04
categories: 
- OS
tags:
- thread
- linux
- OS
---

> 作为一个前端工程师，即使接触了node后，对于linux和操作系统等计算机基础知识的欠缺还是一个很大的问题。大学的操作系统课靠着死记硬背就过去了，现在还是要还，通过本文的梳理，希望能真正的理解操作系统中进程和线程的概念

## 定义
- 进程（Process）： 操作系统中拥有资源和调度的基本单位。
- 线程（Thread）： 线程就是进程中并发执行的基本单元，线程也因此被称为“轻量级进程”。

[进程与现成的一个简单解释-阮一峰](http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html)

##  进程和线程的关系
- 一个进程可以拥有多个线程，一个线程必须要有一个父进程
- 线程之间共享父进程的共享资源，相互之间协同完成进程所要完成的任务
- 一个线程可以创建和撤销另一个线程，同一个进程的多个线程之间可以并发执行

## 进程之间的交互
通过TCP/IP的端口来实现

## 线程之间的交互
线程的通信就比较简单，有一大块共享的内存，只要大家的指针是同一个就可以看到各自的内存。

## 进程的多层调度
从硬盘上的可执行文件转为内存中的执行进程涉及到如下两层调度。

### 作业调度
作业调度是将硬盘上执行文件调度到内存中成为进程的过程，经历过该调度的进程处于就绪状态等待分配CPU资源。多个作业请求调度时，有许多经典算法可以采用：
- 先来先服务
- 优先级调度
- 短作业优先

### 进程调度
进程调度是指在就绪队列中排队的就绪进程获取CPU时间片资源的过程。进程调度算法是需要介绍的重点,从较大的方向上分，其主要包括两类:

1.基于优先权调度的算法
- 静态优先权调度
- 动态优先权调度
- 抢占式调度
- 非抢占式调度

2.基于时间片轮转的调度算法
基于时间片的调度算法将就绪进程排列成一个队列，为队列中每个就绪进程分配指定的时间片资源。若在规定的时间片内进程未执行完毕，那么该进程将再次加入队列的尾部等待下一次时间片资源分配。


## 同步机制
经典的线程同步问题：
1. 生产者与消费者问题：消费者线程和生产者线程同时访问一个总大小为N的临界资源池。当资源池中资源数目为N时，生产者线程不能往其中添加数据，此时临界资源池记为满状态。当资源池中资源数目为0时，消费者线程不能从资源池中拿去数据，此时临界资源池记为空状态。在这样一个场景下，需要实现三个点:
- 消费者线程和生产者线程临界资源池的访问是互斥的。
- 临界资源池在满状态时，生产者线程放入数据操作必须阻塞，等待资源池非满状态时才能继续放入
- 临界资源池空状态时，消费者线程取数据的操作必须阻塞，等待资源池非空状态时才能继续取出。
**解决方法：互斥锁和条件变量**

2. 哲学家就餐问题
![](/../images/dinning.png)
五个哲学家们围坐在一个圆桌上，每个哲学家左右两侧都放了一只筷子。当哲学家们想要就就餐时，会试图拿起离自己最近的筷子。一只一只这样拿筷子。当哲学家拿齐一双筷子后，就开始就餐。就餐完毕后将所有筷子放回原处，开始思考哲学。
那么为什么要构造出这样一个关于哲学家就餐的场景呢？
主要是构建出一个因为线程同步不当而造成死锁的场景，倘若哲学家门同时拿起来自己左侧的筷子后，当哲学再次试图去拿右侧筷子时，所有哲学家都无法获取就餐机会，陷入僵局。这也是进程同步中的死锁问题。
**解决方法：**
- 至多允许四个哲学家同时去拿左边的筷子，最终保证至少有一个科学家能进餐，并且用完之后释放筷子，从而使更多的哲学家能够拿到筷子。
- 规定奇数号科学家先拿左边的筷子，然后拿右边的筷子。偶数号科学家先拿右边的筷子，然后那左边的筷子。
- 仅当科学家左右两只筷子都能用的时候，才允许他进餐

3.读者-写者问题
对于一个文件，存在多个线程同时读取以及多个线程同时写入。在这种条件下要求对文件的访问不能混乱。那么要求读线程和写线程必须满足如下要求:
- 读线程和写线程之间对文件的访问是互斥的
- 写线程之间对文件的访问是互斥的
- 读线程之间对文件的访问不需要互斥
**解决办法：读写锁**

## 死锁
首先自己分析下产生死锁的原因：竞争贡献资源&进程/线程间推进顺序不合理

其实线程产生死锁有4个必要条件
- 互斥条件，线程对资源的获取具有排他性，在获取资源的同时独占资源，不允许其他线程访问共享资源。
- 请求和保持条件，线程在获取某个资源之后，若再次申请或许新的资源但被阻塞时，并不释放已占有的资源。
- 不剥夺条件，线程获取资源之后，不会因为其他线程竞争而放弃资源。只能等到使用完毕或者主动释放。
- 环路条件,当线程之间发生死锁的时候，必然存在一个线程->资源之间的环形链路。比如线程P1等到线程P2占用的某个资源，线程P2等待线程P1占用的谋和资源
  
## 死锁的解决方法
- 预防：破坏死锁产生的必要条件
- 避免：[银行家算法](https://zh.wikipedia.org/zh-hans/%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95)
- 检测：提供发现机制，杀死死锁进程

## 通信机制
进程/线程之间的同步其实是一种通信机制，但是同步机制只是一种小规模的数据通信。此处介绍的通信机制是应对较大规模的数据传输。此处以进程之间的通信机制为例介绍

- 共享存储系统
共享存储系统比较容易理解，就是多个进程拥有共同存储空间，通过修改/读取同一块区域达到通信目的。
- 消息传递系统
消息传递系统是指进程之间通过格式化数据报文交换信息，最容易理解的便是计算机网络数据报文交换。位于不同计算机上应用的通信也是进程通信的一种场景
- 管道通信
所谓"管道"是指用于连接一个读进程和一个写进程以实现他们之间的通信的一个文件。向管道(共享文件)输入的发送进程，以字符流的形式输入大量数据到管道中，从管道接收输出的接收进程，将读取大量数据。